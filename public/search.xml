<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>TensorFlow-0-入门</title>
    <url>/2017/09/26/TensorFlow/TensorFlow-0-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>本节介绍TensorFlow最最最基本的东西。<br><img src="https://coderdock-1251264493.picsh.myqcloud.com/tensorflow.png" alt="TensorFlow"></p>
<a id="more"></a>
<p>&emsp;&emsp;对于TensorFlow的使用，网上已经有很多的教程，包括TensorFlow的中文社区有很好的翻译教程，只要安装好TensorFlow后，有着Python编程基础和基础的机器学习及神经网络所要求的基础数学知识，都是很好上手的。所以在这个系列的文章中，我不会着眼于环境搭建，以及详细的原理讲解，而更多的是源码级别的讲解，即对自己<code>玩过的</code>代码添加注释，表达感慨。</p>
<h1 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h1><p>我使用的平台是Ubuntu 16.04，安装方式是Anaconda,参照网址是：<a href="https://www.tensorfly.cn/tfdoc/get_started/os_setup.html" target="_blank" rel="noopener">https://www.tensorfly.cn/tfdoc/get_started/os_setup.html</a></p>
<h1 id="2-第一个测试程序"><a href="#2-第一个测试程序" class="headerlink" title="2.第一个测试程序"></a>2.第一个测试程序</h1><p>到此处认为你已经安装好了你的TensorFlow环境，我们来看官方推荐的第一个例子：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow as tf</span><br><span class="line"><span class="keyword">import</span> numpy as np</span><br><span class="line"></span><br><span class="line"># 使用 NumPy 生成假数据(phony data), 总共 <span class="number">100</span> 个点.</span><br><span class="line">x_data = np.<span class="built_in">float</span>32(np.random.rand(<span class="number">2</span>, <span class="number">100</span>)) # 生成 <span class="number">2</span>*<span class="number">100</span>的矩阵</span><br><span class="line">y_data = np.dot([<span class="number">0.100</span>, <span class="number">0.200</span>], x_data) + <span class="number">0.300</span> <span class="comment">//以 [0.1, 0.2]和 偏置生成虚拟的数据</span></span><br><span class="line"></span><br><span class="line"># 构造一个线性模型</span><br><span class="line">b = tf.Variable(tf.zeros([<span class="number">1</span>]))          #构建一个参数未知的线性模型 y= W*x_data + b</span><br><span class="line">W = tf.Variable(tf.random_uniform([<span class="number">1</span>, <span class="number">2</span>], <span class="number">-1.0</span>, <span class="number">1.0</span>))   #由均匀分布得到初始化的W值</span><br><span class="line">y = tf.matmul(W, x_data) + b            #构建线性模型</span><br><span class="line"></span><br><span class="line"># 最小化方差</span><br><span class="line">loss = tf.reduce_mean(tf.square(y - y_data))</span><br><span class="line">optimizer = tf.train.GradientDescentOptimizer(<span class="number">0.5</span>)   #下降步伐为<span class="number">0.5</span></span><br><span class="line">train = optimizer.minimize(loss)</span><br><span class="line"></span><br><span class="line"># 初始化变量</span><br><span class="line">init = tf.initialize_all_variables()</span><br><span class="line"></span><br><span class="line"># 启动图 (graph)</span><br><span class="line">sess = tf.Session()</span><br><span class="line">sess.run(init)</span><br><span class="line"></span><br><span class="line"># 拟合平面</span><br><span class="line"><span class="keyword">for</span> step <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">201</span>):</span><br><span class="line">    sess.run(train)</span><br><span class="line">    <span class="keyword">if</span> step % <span class="number">20</span> == <span class="number">0</span>:</span><br><span class="line">        print(step, sess.run(W), sess.run(b))</span><br><span class="line"></span><br><span class="line"># 得到最佳拟合结果 W: [[<span class="number">0.100</span>  <span class="number">0.200</span>]], b: [<span class="number">0.300</span>]</span><br></pre></td></tr></table></figure>
<p>上面这个程序虽然很简单，但是TenSorflow的基本元素基本都涉及到了，</p>
<ul>
<li>先创建虚拟的x_data,然后设定要预测的参数值。</li>
<li>构建线性模型</li>
<li>构建一个TensorFlow会话</li>
<li>执行会话<br>经过200次梯度下降后，我们的预测值如下：<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">0 </span>[[-<span class="number">0.32990205</span>  <span class="number">0.94440365</span>]] [ <span class="number">0.27961046</span>]</span><br><span class="line"><span class="symbol">20 </span>[[ <span class="number">0.04070586</span>  <span class="number">0.33752358</span>]] [ <span class="number">0.2542021</span>]</span><br><span class="line"><span class="symbol">40 </span>[[ <span class="number">0.09684953</span>  <span class="number">0.23069493</span>]] [ <span class="number">0.28419915</span>]</span><br><span class="line"><span class="symbol">60 </span>[[ <span class="number">0.10159973</span>  <span class="number">0.20767325</span>]] [ <span class="number">0.29472959</span>]</span><br><span class="line"><span class="symbol">80 </span>[[ <span class="number">0.10094509</span>  <span class="number">0.20211281</span>]] [ <span class="number">0.29826969</span>]</span><br><span class="line"><span class="symbol">100 </span>[[ <span class="number">0.10037546</span>  <span class="number">0.20062292</span>]] [ <span class="number">0.2994363</span>]</span><br><span class="line"><span class="symbol">120 </span>[[ <span class="number">0.10013281</span>  <span class="number">0.20019153</span>]] [ <span class="number">0.29981709</span>]</span><br><span class="line"><span class="symbol">140 </span>[[ <span class="number">0.10004479</span>  <span class="number">0.20006029</span>]] [ <span class="number">0.29994076</span>]</span><br><span class="line"><span class="symbol">160 </span>[[ <span class="number">0.10001478</span>  <span class="number">0.20001923</span>]] [ <span class="number">0.29998085</span>]</span><br><span class="line"><span class="symbol">180 </span>[[ <span class="number">0.10000481</span>  <span class="number">0.20000617</span>]] [ <span class="number">0.29999381</span>]</span><br><span class="line"><span class="symbol">200 </span>[[ <span class="number">0.10000155</span>  <span class="number">0.20000197</span>]] [ <span class="number">0.29999802</span>]</span><br></pre></td></tr></table></figure>




</li>
</ul>
<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>TensorFlow</category>
      </categories>
      <tags>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title>Fuchsia系统构建</title>
    <url>/2019/11/03/Fuchsia/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>构建Fuchsia系统</p>
<a id="more"></a>
<p>从零开始尝试构建Fuchsia系统。官方资料<code>https://fuchsia.dev/fuchsia-src/getting_started.md</code>。</p>
<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p><code>sudo apt-get install build-essential curl git python unzip</code></p>
<h2 id="获取源码"><a href="#获取源码" class="headerlink" title="获取源码"></a>获取源码</h2><p>使用命令创建一个新的检出：</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">curl -s <span class="string">"https://fuchsia.googlesource.com/fuchsia/+/master/scripts/bootstrap?format=TEXT"</span> | <span class="type">base64</span> --decode | <span class="type">bash</span></span><br></pre></td></tr></table></figure>

<p>该脚本会在当前目录下创建一个<code>fuchsia</code>文件夹，并在fuchsia文件夹下创建<code>.jiri_root</code>目录，该目录中包含<code>jiri</code>命令，fuchsia工程就是通过<code>jiri</code>命令管理的。我们可以将jiri的路径加入<code>PATH</code>中，方便使用。</p>
<p>脚本中的最后一条命令为<code>jiri update</code>因为网络或其他原因中断下载，可以重新直接使用<code>jiri update</code>命令进行继续下载。</p>
<h2 id="构建工程"><a href="#构建工程" class="headerlink" title="构建工程"></a>构建工程</h2><p>使用命令：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">fx <span class="keyword">set</span> core.x64 <span class="comment">--with</span> //<span class="comment">bundles:kitchen_sink</span></span><br><span class="line">fx <span class="comment">build</span></span><br></pre></td></tr></table></figure>
<p>构建成功后使用</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">fx <span class="keyword">run</span></span><br></pre></td></tr></table></figure>
<p>使用qemu运行系统</p>
<h2 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h2><ul>
<li>git版本问题<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ninja: Entering directory `/home/bo/Ext4/fuchsia_pro/fuchsia/out/default.zircon'</span><br><span class="line">[47935/47935] STAMP obj/default.stamp</span><br><span class="line">ninja: Entering directory `/home/bo/Ext4/fuchsia_pro/fuchsia/out/default'</span><br><span class="line">[47/61429] ACTION //build/info:latest-<span class="keyword">commit</span>-<span class="built_in">date</span>(//<span class="keyword">build</span>/toolchain/fuchsia:x64)</span><br><span class="line"><span class="keyword">FAILED</span>: gen/latest-<span class="keyword">commit</span>-date.txt gen/<span class="keyword">minimum</span>-utc-stamp.txt</span><br><span class="line">/usr/<span class="keyword">bin</span>/env ../../<span class="keyword">build</span>/info/gen-latest-<span class="keyword">commit</span>-date.sh ../../integration/ gen/latest-<span class="keyword">commit</span>-date.txt gen/<span class="keyword">minimum</span>-utc-stamp.txt</span><br><span class="line">fatal: <span class="literal">unknown</span> <span class="built_in">date</span> <span class="keyword">format</span> unix</span><br><span class="line">[<span class="number">54</span>/<span class="number">61429</span>] <span class="keyword">ACTION</span> //<span class="keyword">build</span>/images/zedboot:zedboot.manifest(//<span class="keyword">build</span>/toolchain/fuchsia:x64)</span><br><span class="line">ninja: <span class="keyword">build</span> stopped: subcommand failed.</span><br><span class="line">Hint: run <span class="string">`fx build`</span> <span class="keyword">with</span> the <span class="keyword">option</span> <span class="string">`--log LOGFILE`</span> <span class="keyword">to</span> generate a debug <span class="keyword">log</span> <span class="keyword">if</span> you <span class="keyword">are</span> reporting a bug.</span><br></pre></td></tr></table></figure>
主要原因为<code>fatal: unknown date format unix</code>是git版本较旧，更新git即可<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">sudo<span class="built_in"> add-apt-repository </span>ppa:git-core/ppa</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Fuchsia</category>
        <category>系统构建</category>
      </categories>
      <tags>
        <tag>Fuchsia系统</tag>
      </tags>
  </entry>
  <entry>
    <title>SLAM-0-基础</title>
    <url>/2017/10/02/SLAM/SLAM-0-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>SLAM的基础概念。</p>
<a id="more"></a>
<p>&emsp;&emsp;SLAM是<code>Simultaneous Localization and Mapping</code>的缩写，同时定位与地图构建。</p>
<h1 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1.基础概念"></a>1.基础概念</h1><ul>
<li>单目相机：只使用一个相机的进行SLAM的做法称作单目SLAM(Monocular SLAM)。但只有二维信息，没有深度信息。如果想要恢复三维结构信息，那么必须改变相机的视角——y移动相机。</li>
<li>视差：近处的物体移动快，远处的物体运动慢。当相机移动时，就会形成视差。</li>
<li>尺度：单目SLAM估计的轨迹与地图与真实的轨迹与地图相差一个因子，称之为<code>尺度</code>。但是单目SLAM无法仅凭图像确定真实尺度，成为<code>尺度不确定性</code>。</li>
<li>双目相机：双目相机有两个单目相机组成，两个相机之间的距离是已知的，成为<code>基线</code>。与人眼的测量的原理相类似。这个技术需要大量计算才能估计每一个像素点的深度。(双目相机的测量距离与基线相关，基线越大，测量距离越大)双目相机非常耗费计算资源，往往需要FPGA或GPU加速。</li>
<li>深度相机，又称RGB-D相机，其是通过红外结构光或者Time-of-Flight（飞行时间）。像激光传感器那样向物体发射光并接收返回的光。常见的RGB-D相机有<code>Kinect</code>、<code>xtion Pro Live</code>、<code>RealSence</code>。</li>
</ul>
<h1 id="2-框架介绍"><a href="#2-框架介绍" class="headerlink" title="2.框架介绍"></a>2.框架介绍</h1><p>经典框架图：<br><img src="https://download.broadview.com.cn/Original/17055494d435efcc231f" alt="SLAM框架"><br>SLAM流程如下：</p>
<ul>
<li>1.传感器信息读取：进行相机信息的读取和预处理。可能还会有码盘、惯性传感器等信息的读取和同步。</li>
<li>2.视觉里程计(Visual Odometry)：视觉里程计的任务是估算相邻图像间相机的运动，以及局部地图的样子。</li>
<li>3.后端优化（Optimization）:后端接受不同时刻视觉里程计测量的相机位姿，以及回环检测的信息，对它们进行优化，得到全局一致的轨迹和地图。</li>
<li><ol start="4">
<li>回环检测：回环检测判断机器人是否到达过先前的位置，如果检测到回环，会把信息提供给后端处理。</li>
</ol>
</li>
<li>5.建图：根据估计的轨迹，建立与任务要求对应的地图。</li>
</ul>
<p>&emsp;&emsp;在视觉SLAM中，前端和计算机视觉研究领域更为相关。比如图像的特征提取与匹配。后端则主要是滤波与非线性优化算法。</p>
<h1 id="3-方程"><a href="#3-方程" class="headerlink" title="3.方程"></a>3.方程</h1><p>抽象数学模型：</p>
<p>$$<br>x_k=f(x_{k-1}, u_k, w_k)<br>$$<br>$x_k$为位置信息，$u_k$为输入，$w_k$为噪声。<br>观测方程：</p>
<p>$$<br>z_{k,j}=h(y_j,x_k,v_{k,j})<br>$$<br>在$x_k$位置看到路标点$y_j$,产生一个标志$z_{k,j}$。$v_{k,j}$为噪声。</p>
<p>这两个工程方程描述了最基本的SLAM问题，SLAM建模问题就是一个状态估计问题。</p>
<p>分类：分为线性/非线性、高斯、非高斯系统。</p>
<ul>
<li>线性高斯系统(Linear Gauss)是最简单的</li>
</ul>
]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello CoderDock</title>
    <url>/2017/10/13/TensorFlow/TensorFlow-3-Numpy/</url>
    <content><![CDATA[<p>介绍NumPy的基础用法。</p>
<a id="more"></a>

<h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h1><p>&emsp;&emsp;Numpy的主要操作对象是多维数组。、</p>
<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>TensorFlow</category>
      </categories>
      <tags>
        <tag>TensorFlow</tag>
        <tag>NumPy</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow-2-概念1</title>
    <url>/2017/10/02/TensorFlow/TensorFlow-2-%E6%A6%82%E5%BF%B51/</url>
    <content><![CDATA[<p>机器学习分类的基础概念。</p>
<a id="more"></a>
<h1 id="1-特征缩放"><a href="#1-特征缩放" class="headerlink" title="1.特征缩放"></a>1.特征缩放</h1><h2 id="1-1-调节比例（Rescaling）"><a href="#1-1-调节比例（Rescaling）" class="headerlink" title="1.1 调节比例（Rescaling）"></a>1.1 调节比例（Rescaling）</h2><p>这种方法是将数据的特征缩放到[0,1]或[-1,1]之间。缩放到什么范围取决于数据的性质。对于这种方法的公式如下：<br>$$x’ = \frac{x - min(x)}{max(x) - min(x)}$$</p>
<h2 id="1-2-标准化-Standardization"><a href="#1-2-标准化-Standardization" class="headerlink" title="1.2 标准化(Standardization)"></a>1.2 标准化(Standardization)</h2><p>$$<br>x’ = \frac{x - \bar x}{\sigma}<br>$$<br><img src="https://coderdock-1251264493.picsh.myqcloud.com/%E6%96%B9%E5%B7%AE.png" alt="方差"></p>
<h1 id="2-正规方程求解"><a href="#2-正规方程求解" class="headerlink" title="2.正规方程求解"></a>2.正规方程求解</h1><p>有时使用正规方程求解会是更好地方案:</p>
<p>$$<br>\theta=(X^TX)^{-1}X^Ty<br>$$</p>
<h1 id="3-逻辑回归"><a href="#3-逻辑回归" class="headerlink" title="3.逻辑回归"></a>3.逻辑回归</h1><h2 id="3-1模型"><a href="#3-1模型" class="headerlink" title="3.1模型"></a>3.1模型</h2><p>$$<br>0&lt;=h_{\theta}(x)&lt;=1<br>$$<br>$$<br>h(\theta)=g(\theta^Tx)<br>$$<br>estimate probability that y=1 on input x</p>
<p>Sigmod(Logistic) function:</p>
<p>$$<br>g(z) = \frac{1}{1+e^{-z}}<br>$$</p>
<h2 id="3-2判定边界"><a href="#3-2判定边界" class="headerlink" title="3.2判定边界"></a>3.2判定边界</h2><p>决定何时的模型和参数，能够对进行分类操作。</p>
<p>在这种情况下，平方差的代价函数就不再适用，我们重新定义代价函数：</p>
<p>$$<br>J(\theta)=frac{1}{m}\sum_{i=1}^mCost(h_\theta(x^{(i)}),y^{(i)})<br>$$<br>其中：</p>
<p>$$<br>Cost(h_\theta(x),y)=<br>\begin{cases}<br>-log(h_\theta(x)) &amp; \text {if y = 1}\<br>-log(1-h_\theta(x)) &amp; \text {if y = 0}<br>\end{cases}<br>$$<br>代价函数说明：<br>当实际的y=1并且$h_\theta$也是1时，误差为0，当y=1但$h_\theta$不为1时误差随着$h_\theta$的变小而变大；当实际的y=0且$h_\theta$也为0时代价为0，当y=0,但$h_\theta$不为0时误差随着$h_\theta$的变大而变大。</p>
<p>再次进行简化，那么我们的代价函数Cost为：</p>
<p>$$<br>Cost(h_\theta(x),y)=-y<em>log(h_\theta(x))-(1-y)</em>log(1-h_\theta(x))<br>$$<br>代入到代价函数得到：</p>
<p>$$<br>J(\theta)=-\frac{1}{m}\sum_{i=1}^my^{(i)}*log(h_\theta(x^{(i)})+(1-y^{(i)})log(1-h_\theta(x^{(1)})))<br>$$</p>
<p>那么在我们得到代价函数后，我们就能够使用梯度下降算法来使得我们的代价函数最小：<br>Repeat{</p>
<p>$$<br>\theta_j:=\theta_j-\alpha\frac{\partial}{\partial\theta_j}J(\theta)<br>$$</p>
<p>}<br>同样在此处也需要注意同时更新的问题。</p>
<h1 id="4-简化代价函数"><a href="#4-简化代价函数" class="headerlink" title="4.简化代价函数"></a>4.简化代价函数</h1><p>$$<br>\theta_j:=\theta_j-\alpha\frac{\partial}{\partial\theta_j}J(\theta)<br>$$<br>$\theta$更新过程：<br><img src="https://img.my.csdn.net/uploads/201407/16/1405496972_1821.png" alt="推导过程"><br>所以最后$\theta$为：</p>
<p>$$<br>\theta_j:=\theta_j-\alpha\frac{1}{m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x^{(i)}_j<br>$$</p>
<p>梯度下降并不是唯一的算法，还存在：</p>
<ul>
<li>共轭梯度法</li>
<li>BFGS（变尺度法）</li>
<li>L-BFGS（限制变尺度法）</li>
</ul>
<h1 id="5-分类1-VS-N"><a href="#5-分类1-VS-N" class="headerlink" title="5.分类1 VS N"></a>5.分类1 VS N</h1><p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>TensorFlow</category>
      </categories>
      <tags>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow-1-概念0</title>
    <url>/2017/09/29/TensorFlow/TensorFlow-1-%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>机器学习回归的基础概念。</p>
<a id="more"></a>

<h1 id="1-监督学习-VS-无监督学习"><a href="#1-监督学习-VS-无监督学习" class="headerlink" title="1.监督学习 VS 无监督学习"></a>1.监督学习 VS 无监督学习</h1><ul>
<li>监督学习不仅给出了输入，还给出了输出，用处是，给出一个新的输入，预测出新的输入<ul>
<li>回归：对于预测模型是线性的，称之为回归</li>
<li>分类：对于预测模型是非线性的，称之为分类</li>
</ul>
</li>
<li>无监督学习：只给出了输入，由模型自动更加输入数据的特征进行聚类。</li>
</ul>
<h1 id="2-线性回归"><a href="#2-线性回归" class="headerlink" title="2.线性回归"></a>2.线性回归</h1><p>线性模型的公式为：</p>
<p>$$<br>h(\theta)=\theta_1x+\theta_0<br>$$<br>那么其代价函数函数(Cost Function)就为：</p>
<p>$$<br>J(\theta_0,\theta_1)={\frac{1}{2m}}=\sum_{i=1}^m(h_{\theta}(\theta^i)-y^i)^2<br>$$</p>
<h1 id="3-梯度下降"><a href="#3-梯度下降" class="headerlink" title="3.梯度下降"></a>3.梯度下降</h1><h2 id="3-1定义"><a href="#3-1定义" class="headerlink" title="3.1定义"></a>3.1定义</h2><p>求参数的偏微分 repeat until convergence {<br>$$<br>\theta_j:=\theta_j-\alpha\frac{\partial}{\partial\theta_j}J(\theta_0,\theta_1)<br>$$<br>}<br>这个公式的含义就是在偏微分为正时，为上升趋势，我们减少$\theta$。我们让每一个影响参数都朝着输出的方向进行，最终得到最小值。</p>
<p>注意事项：<br> $\theta_j$ 应该是在同时更新的，不能用上一周期的$\theta_j$来计算当前周期的 $\theta_{j-n}$ </p>
<p>正确方式：<br>temp0 =$=\theta_0-\alpha\frac{\partial}{\partial\theta_0}J(\theta_0,\theta_1)$<br>temp1 =$=\theta_1-\alpha\frac{\partial}{\partial\theta_1}J(\theta_0,\theta_1)$<br>$\theta_0$=temp0<br>$\theta_1$=temp1</p>
<p>错误方式：<br>temp0 =$=\theta_0-\alpha\frac{\partial}{\partial\theta_0}J(\theta_0,\theta_1)$<br>$\theta_0$=temp0<br>temp1 =$=\theta_1-\alpha\frac{\partial}{\partial\theta_1}J(\theta_0,\theta_1)$<br>$\theta_1$=temp1</p>
<h2 id="3-2推导"><a href="#3-2推导" class="headerlink" title="3.2推导"></a>3.2推导</h2><p>$\frac{\partial}{\partial\theta_j}J(\theta_0,\theta_1)=\frac{\partial}{\partial\theta_j}\frac{1}{2m}\sum_{i=1}^m(h_{\theta}(x^{(i)})-y^{(i)})$<br>则上面的梯度下降算法对于两个参数来说，就变成了：<br>Repeat{</p>
<p>$$<br>\theta_0:=\theta_0-\alpha\frac{1}{m}\sum_{i=1}^m(h_{\theta}(x^{(i)})-y^{(i)})<br>$$<br>$$<br>\theta_1:=\theta_1-\alpha\frac{1}{m}\sum_{i=1}^m((h_{\theta}(x^{(i)})-y^{(i)})*x^{(i)})<br>$$<br>}</p>
<p>由上可知，在每一个循环周期内，我们使用到了所有的样本数据，所以这个算法也被成为<strong>批量梯度下降</strong>。</p>
<h1 id="4-多维特征定义"><a href="#4-多维特征定义" class="headerlink" title="4.多维特征定义"></a>4.多维特征定义</h1><p>多维特征模型： $h_{\theta}(x)=\theta_0+\theta_1x_1+\theta_2x_2+\theta_2x_3+…$}<br>用矩阵表示为：<br>$h(\theta)=<br>\begin{equation}<br>\left[ \begin{array}{ccc}<br>x_1 &amp; x_2 &amp; x_3<br>\end{array}<br>\right ]<br>*<br>\left[ \begin{array}{ccc}<br>\theta_1 &amp;<br>\theta_2 &amp;<br>\theta_3<br>\end{array}<br>\right ]^T<br>\end{equation}$</p>
<ul>
<li>$x^{(i)}$：表示第i个训练实例</li>
<li>$x_j^{(i)}$ :第i个训练实例的参数j</li>
</ul>
<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>TensorFlow</category>
      </categories>
      <tags>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟开发板-Linux环境搭建</title>
    <url>/2017/04/28/VirtualBoard/%E8%99%9A%E6%8B%9F%E5%BC%80%E5%8F%91%E6%9D%BF-Linux%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>&emsp;&emsp;本章介绍使用qemu搭建Linux开发环境<br><img src="https://img.blog.csdn.net/20171228133356110?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzk4OTI4NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Linux"></p>
<a id="more"></a>
<h1 id="1-Linux源码下载"><a href="#1-Linux源码下载" class="headerlink" title="1.Linux源码下载"></a>1.Linux源码下载</h1><p>Linux Source: <a href="https://www.kernel.org/" target="_blank" rel="noopener">https://www.kernel.org/</a></p>
<h1 id="2-编译过程"><a href="#2-编译过程" class="headerlink" title="2.编译过程"></a>2.编译过程</h1><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">ARCH</span>=arm</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">CROSS_COMPILE</span>=arm-linux-gnueabihf-</span><br><span class="line">make vexpress_defconfig</span><br><span class="line"><span class="comment">#生成zImage</span></span><br><span class="line">make -j4</span><br><span class="line"><span class="comment">#下面这条会生成uImage供uboot使用</span></span><br><span class="line">make uImage <span class="attribute">LOADADDR</span>=0x60003000</span><br><span class="line">make modules</span><br><span class="line">make dtbs</span><br></pre></td></tr></table></figure>
<h1 id="3-各种镜像格式介绍"><a href="#3-各种镜像格式介绍" class="headerlink" title="3.各种镜像格式介绍"></a>3.各种镜像格式介绍</h1><ul>
<li>vmlinux编译出来的最原始的内核elf文件，未压缩。</li>
<li>zImage是vmlinux经过objcopy gzip压缩后的文件， objcopy实现由vmlinux的elf文件拷贝成纯二进制数据文件。</li>
<li>bzImage bz表示“big zImage”，不是用bzip2压缩的。两者的不同之处在于，zImage解压缩内核到低端内存(第一个640K)，bzImage解压缩内核到高端内存(1M以上)。如果内核比较小，那么采用zImage或bzImage都行，如果比较大应该用bzImage。</li>
<li>uImageU-boot专用的映像文件，它是在zImage之前加上一个长度为0x40的tag。</li>
<li>vmlinuz  是bzImage/zImage文件的拷贝或指向bzImage/zImage的链接。</li>
<li>initrd   是“initial ramdisk”的简写。一般被用来临时的引导硬件到实际内核vmlinuz能够接管并继续引导的状态。<h1 id="3-qemu启动"><a href="#3-qemu启动" class="headerlink" title="3.qemu启动"></a>3.qemu启动</h1><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">qemu</span>-system-<span class="meta">arm</span> -nographic  -sd vexpress.img -M vexpress-a9   -m <span class="number">512</span>M -kernel ./arch/<span class="meta">arm</span>/<span class="keyword">boot/zImage </span>-dtb ./arch/<span class="meta">arm</span>/<span class="keyword">boot/dts/vexpress-v2p-ca9.dtb </span>-smp <span class="number">4</span> -append <span class="string">" earlyprintk console=ttyAMA0"</span></span><br></pre></td></tr></table></figure>
在启动文件系统的时候出错，那是因为我们还没有制作根文件系统<h1 id="4-生成根文件系统"><a href="#4-生成根文件系统" class="headerlink" title="4.生成根文件系统"></a>4.生成根文件系统</h1><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">qemu-img create -f raw vexpress.img 100M</span><br><span class="line">fdisk vexpress.img                      <span class="comment">#在其中进行分区</span></span><br><span class="line">sudo losetup <span class="string">/dev/loop0</span> vexpress.img    <span class="comment">#将image挂载到loop0上</span></span><br><span class="line">sudo partx -u <span class="string">/dev/loop0</span>                <span class="comment">#刷新分区</span></span><br><span class="line">sudo mkfs.ext3 <span class="string">/dev/loop0p1</span></span><br><span class="line">mkdir rootfs</span><br><span class="line">sudo mount -o loop <span class="string">/dev/loop0p1</span> <span class="string">./rootfs</span>  <span class="comment">#将rootfs挂载到loo0p1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sudo partx -d <span class="string">/dev/loop0</span>          <span class="comment">#卸载</span></span><br><span class="line">sudo losetup -d <span class="string">/dev/loop0</span>        <span class="comment">#卸载</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="5-生成根文件系统"><a href="#5-生成根文件系统" class="headerlink" title="5.生成根文件系统"></a>5.生成根文件系统</h1><h2 id="5-1编译BusyBox"><a href="#5-1编译BusyBox" class="headerlink" title="5.1编译BusyBox"></a>5.1编译BusyBox</h2><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">配置成下面这种方式：</span><br><span class="line"></span><br><span class="line">Busybox<span class="built_in"> Settings </span> ---&gt;</span><br><span class="line">    Build Options  ---&gt;</span><br><span class="line">        [*] Build BusyBox as a static binary (<span class="literal">no</span> shared libs)</span><br><span class="line">        (arm-linux-gnueabihf-) Cross Compiler prefix</span><br><span class="line"></span><br><span class="line">make <span class="attribute">ARCH</span>=arm <span class="attribute">CROSS_COMPILE</span>=arm-linux-gnueabihf-</span><br><span class="line">make install      # 在 ./_install/下生成文件</span><br></pre></td></tr></table></figure>
<p>出现下面输出说明生成成功</p>
<h2 id="5-2制作根文件系统"><a href="#5-2制作根文件系统" class="headerlink" title="5.2制作根文件系统"></a>5.2制作根文件系统</h2><p>拷贝运行库</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">cp -arf _install/* rootfs/</span><br><span class="line">cp -arf arm-linux-gcc/<span class="class"><span class="keyword">lib</span>/* <span class="title">rootfs</span></span></span><br><span class="line">rm <span class="class"><span class="keyword">lib</span>/*.<span class="title">a</span></span></span><br><span class="line">arm-linux-gnueabihf-stripe <span class="class"><span class="keyword">lib</span>/*</span></span><br></pre></td></tr></table></figure>
<p>创建文件夹</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p rootfs/<span class="keyword">proc</span>/</span><br><span class="line">sudo<span class="title"> mkdir</span> -p<span class="title"> rootfs/sys/</span></span><br><span class="line"><span class="title">sudo</span> mkdir -p<span class="title"> rootfs/tmp/</span></span><br><span class="line"><span class="title">sudo</span> mkdir -p<span class="title"> rootfs/root/</span></span><br><span class="line"><span class="title">sudo</span> mkdir -p<span class="title"> rootfs/var/</span></span><br><span class="line"><span class="title">sudo</span> mkdir -p<span class="title"> rootfs/mnt/</span></span><br></pre></td></tr></table></figure>
<p>创建节点</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p rootfs/dev/</span><br><span class="line">sudo mknod rootfs/dev/tty1 c <span class="number">4</span> <span class="number">1</span></span><br><span class="line">sudo mknod rootfs/dev/tty2 c <span class="number">4</span> <span class="number">2</span></span><br><span class="line">sudo mknod rootfs/dev/tty3 c <span class="number">4</span> <span class="number">3</span></span><br><span class="line">sudo mknod rootfs/dev/tty4 c <span class="number">4</span> <span class="number">4</span></span><br><span class="line">sudo mknod rootfs/dev/console c <span class="number">5</span> <span class="number">1</span></span><br><span class="line">sudo mknod rootfs/dev/<span class="literal">null</span> c <span class="number">1</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>添加配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">参考linux启动过程章节</span><br></pre></td></tr></table></figure>
<h1 id="6-启动命令"><a href="#6-启动命令" class="headerlink" title="6.启动命令"></a>6.启动命令</h1><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">qemu-system-arm -nographic  -sd vexpress.img -<span class="keyword">M</span> vexpress-a9   -<span class="keyword">m</span> 512M -kernel ./<span class="keyword">arch</span>/arm/<span class="keyword">boot</span>/zImage -dtb ./<span class="keyword">arch</span>/arm/<span class="keyword">boot</span>/dts/vexpress-v2p-ca9.dtb -smp 4 -<span class="keyword">append</span> <span class="string">"noinitrd root=/dev/mmcblk0p1 rw rootwait earlyprintk console=ttyAMA0"</span> -<span class="keyword">net</span> nic,vlan=0 -<span class="keyword">net</span> tap,vlan=0,ifname=tap30,script=<span class="keyword">no</span>,downscript=<span class="keyword">no</span></span><br></pre></td></tr></table></figure>
<h1 id="7-关闭qemu"><a href="#7-关闭qemu" class="headerlink" title="7.关闭qemu"></a>7.关闭qemu</h1><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">ps -A | <span class="keyword">grep</span> qemu-<span class="keyword">system</span>-arm | awk <span class="string">'&#123;print $1&#125;'</span> | xargs sudo <span class="keyword">kill</span> -<span class="number">9</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img.blog.csdn.net/20171228133356110?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzk4OTI4NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Linux"></p>
<h1 id="8-网络配置"><a href="#8-网络配置" class="headerlink" title="8.网络配置"></a>8.网络配置</h1><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">sudo apt-get <span class="keyword">install </span>uml-utilities</span><br><span class="line">sudo apt-get <span class="keyword">install </span><span class="keyword">bridge-utils</span></span><br><span class="line"><span class="keyword">sudo </span>tunctl -u root -t tap30   <span class="comment">#在主机上创建tap30设备</span></span><br><span class="line">ifconfig tap30 <span class="number">192</span>.<span class="number">168</span>.<span class="number">111</span>.<span class="number">1</span> promisc up   <span class="comment">#启用设备，并设置为混杂模式</span></span><br></pre></td></tr></table></figure>
<p>再启动脚本中添加如下几行，以使用网络</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">-net nic,<span class="attribute">vlan</span>=0 -net tap,<span class="attribute">vlan</span>=0,ifname=tap30,script=no,downscript=no</span><br></pre></td></tr></table></figure>
<p>进入虚拟机后使用</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">ifconfig</span> <span class="string">eth0</span> <span class="number">192.168</span><span class="number">.111</span><span class="number">.2</span> <span class="string">promisc</span> <span class="string">up</span> <span class="comment">#启用设备</span></span><br></pre></td></tr></table></figure>


<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>虚拟开发板</category>
        <category>Qemu</category>
      </categories>
      <tags>
        <tag>虚拟开发板</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟开发板-uboot添加实现命令</title>
    <url>/2017/04/29/VirtualBoard/%E8%99%9A%E6%8B%9F%E5%BC%80%E5%8F%91%E6%9D%BF-uboot%E6%B7%BB%E5%8A%A0%E5%AE%9E%E7%8E%B0%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>在本章会介绍uboot命令的相关结构体并添加自定义命令。</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">______   _______  _______ _________   _______  _______  ______</span><br><span class="line">|<span class="string">\     /</span>|<span class="string">(  ___ \ (  ___  )(  ___  )\__   __/  (  ____ \(       )(  __  \</span></span><br><span class="line">|<span class="string"> )   ( </span>||<span class="string"> (   ) )</span>|<span class="string"> (   ) </span>||<span class="string"> (   ) </span>|<span class="string">   ) (     </span>|<span class="string"> (    \/</span>|<span class="string"> () () </span>||<span class="string"> (  \  )</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>||<span class="string"> (__/ / </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>||<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string">     </span>|<span class="string"> </span>|<span class="string">      </span>|<span class="string"> </span>||<span class="string"> </span>||<span class="string"> </span>||<span class="string"> </span>|<span class="string">   ) </span>|</span><br><span class="line">|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>||<span class="string">  __ (  </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>||<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string">     </span>|<span class="string"> </span>|<span class="string">      </span>|<span class="string"> </span>|<span class="string">(_)</span>|<span class="string"> </span>||<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>|</span><br><span class="line">|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>||<span class="string"> (  \ \ </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>||<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string">     </span>|<span class="string"> </span>|<span class="string">      </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>||<span class="string"> </span>|<span class="string">   ) </span>|</span><br><span class="line">|<span class="string"> (___) </span>||<span class="string"> )___) )</span>|<span class="string"> (___) </span>||<span class="string"> (___) </span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string">     </span>|<span class="string"> (____/\</span>|<span class="string"> )   ( </span>||<span class="string"> (__/  )</span></span><br><span class="line"><span class="string">(_______)</span>|<span class="string">/ \___/ (_______)(_______)   )_(     (_______/</span>|<span class="string">/     \</span>|<span class="string">(______/</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h1 id="1-相关结构体分析"><a href="#1-相关结构体分析" class="headerlink" title="1.相关结构体分析"></a>1.相关结构体分析</h1><p>在uboot中与命令相关的一个结构体如下，该结构体的内容会被保存在二进制<code>u_boot_cmd</code>段，每当输入一个命令，就会依次在该段内寻找命令，然后执行相应的函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmd_tbl_s</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span>		*name;		<span class="comment">/* Command Name			*/</span></span><br><span class="line">	<span class="keyword">int</span>		maxargs;	<span class="comment">/* maximum number of arguments	*/</span></span><br><span class="line">	<span class="keyword">int</span>		repeatable;	<span class="comment">/* autorepeat allowed?		*/</span></span><br><span class="line">					<span class="comment">/* Implementation function	*/</span></span><br><span class="line">	<span class="keyword">int</span>		(*cmd)(struct cmd_tbl_s *, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">char</span> * <span class="keyword">const</span> []);</span><br><span class="line">	<span class="keyword">char</span>		*usage;		<span class="comment">/* Usage message	(short)	*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>	CONFIG_SYS_LONGHELP</span></span><br><span class="line">	<span class="keyword">char</span>		*help;		<span class="comment">/* Help  message	(long)	*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_AUTO_COMPLETE</span></span><br><span class="line">	<span class="comment">/* do auto completion on the arguments */</span></span><br><span class="line">	<span class="keyword">int</span>		(*complete)(<span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> argv[], <span class="keyword">char</span> last_char, <span class="keyword">int</span> maxv, <span class="keyword">char</span> *cmdv[]);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如下：就定义了一个imls命令，参数最多为1，可重复执行，实现函数为<code>do_imls</code>,之后是帮助文档。</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">U_BOOT_CMD(</span><br><span class="line">	imls,	<span class="number">1</span>,		<span class="number">1</span>,	do_imls,</span><br><span class="line">	<span class="string">"list all images found in flash"</span>,</span><br><span class="line">	<span class="string">"<span class="subst">\n</span>"</span></span><br><span class="line">	<span class="string">"    - Prints information about all images found at sector/block<span class="subst">\n</span>"</span></span><br><span class="line">	<span class="string">"      boundaries in nor/nand flash."</span></span><br><span class="line">);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<h1 id="2-增加自定义命令"><a href="#2-增加自定义命令" class="headerlink" title="2.增加自定义命令"></a>2.增加自定义命令</h1><p>在common目录下新建<code>hello_cmd.c</code>文件,输入一下内容：</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;common.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bootretry.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cli.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;console.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ctype.h&gt;</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> do_hello(cmd_tbl_t *cmdtp, <span class="built_in">int</span> flag, <span class="built_in">int</span> argc, char * <span class="keyword">const</span> argv[])</span><br><span class="line">&#123;</span><br><span class="line">	printf(<span class="string">"Hello World\n"</span>)<span class="comment">;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">U_BOOT_CMD(</span><br><span class="line">	hello, CONFIG_SYS_MAXARGS, <span class="number">1</span>,	do_hello,</span><br><span class="line">	<span class="string">"print Hello"</span>,</span><br><span class="line">	<span class="string">"print hello"</span></span><br><span class="line">	<span class="string">"      passing 'arg' as arguments"</span></span><br><span class="line">)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>在Makefile中输入：</p>
<figure class="highlight fix"><table><tr><td class="code"><pre><span class="line"><span class="attr">obj-y +</span>=<span class="string"> hello_cmd.o</span></span><br></pre></td></tr></table></figure>
<p>重新使用命令：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">make <span class="attribute">ARCH</span>=arm <span class="attribute">CROSS_COMPILE</span>=arm-linux-gnueabihf-</span><br></pre></td></tr></table></figure>
<p>重新编译后，进入uboot:</p>
<p><img src="https://img.blog.csdn.net/20171229103157977?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzk4OTI4NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="hello_cmd"></p>
<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>虚拟开发板</category>
        <category>Qemu</category>
      </categories>
      <tags>
        <tag>虚拟开发板</tag>
        <tag>uboot</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟开发板-Qemu调试uboot</title>
    <url>/2017/04/29/VirtualBoard/%E8%99%9A%E6%8B%9F%E5%BC%80%E5%8F%91%E6%9D%BF-Qemu%E8%B0%83%E8%AF%95uboot/</url>
    <content><![CDATA[<p>在本节介绍使用qemu + gdb调试uboot 和 kernel。</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">(  ___  )(  ____ \(       )|<span class="string">\     /</span>|<span class="string">      (  ____ \(  __  \ (  ___ \</span></span><br><span class="line">|<span class="string"> (   ) </span>||<span class="string"> (    \/</span>|<span class="string"> () () </span>||<span class="string"> )   ( </span>|<span class="string">      </span>|<span class="string"> (    \/</span>|<span class="string"> (  \  )</span>|<span class="string"> (   ) )</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>||<span class="string"> (__    </span>|<span class="string"> </span>||<span class="string"> </span>||<span class="string"> </span>||<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string">      </span>|<span class="string"> </span>|<span class="string">      </span>|<span class="string"> </span>|<span class="string">   ) </span>||<span class="string"> (__/ /</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>||<span class="string">  __)   </span>|<span class="string"> </span>|<span class="string">(_)</span>|<span class="string"> </span>||<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string">      </span>|<span class="string"> </span>|<span class="string"> ____ </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>||<span class="string">  __ (</span></span><br><span class="line">|<span class="string"> </span>|<span class="string"> /\</span>|<span class="string"> </span>||<span class="string"> (      </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>||<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string">      </span>|<span class="string"> </span>|<span class="string"> \_  )</span>|<span class="string"> </span>|<span class="string">   ) </span>||<span class="string"> (  \ \</span></span><br><span class="line">|<span class="string"> (_\ \ </span>||<span class="string"> (____/\</span>|<span class="string"> )   ( </span>||<span class="string"> (___) </span>|<span class="string">      </span>|<span class="string"> (___) </span>||<span class="string"> (__/  )</span>|<span class="string"> )___) )</span></span><br><span class="line"><span class="string">(____\/_)(_______/</span>|<span class="string">/     \</span>|<span class="string">(_______)      (_______)(______/ </span>|<span class="string">/ \___/</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="1-调试命令"><a href="#1-调试命令" class="headerlink" title="1.调试命令"></a>1.调试命令</h1><p>我们之前qemu启动uboot的命令为：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">qemu-system-arm -M vexpress-a9 -m <span class="number">256</span>M -nographic -kernel u-boot</span><br></pre></td></tr></table></figure>
<p>现在变为：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">qemu-system-arm -M vexpress-a9 -m <span class="number">256</span>M -nographic -kernel u-boot -gdb tcp::<span class="number">1234</span>  -S</span><br></pre></td></tr></table></figure>
<p>-S指在启动的时候释放CPU。<br>qemu会在启动的时候卡住。</p>
<h1 id="2-进行连接"><a href="#2-进行连接" class="headerlink" title="2.进行连接"></a>2.进行连接</h1><p>新打开一个终端，依次输入：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">arm-linux-gnueabihf-gdb</span> <span class="string">u-boot</span></span><br><span class="line"><span class="attr">target remote :</span> <span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p>出现以下画面说明成功：<br><img src="https://img.blog.csdn.net/20171229111500914?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzk4OTI4NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="debuguboot"></p>
<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>虚拟开发板</category>
        <category>Qemu</category>
      </categories>
      <tags>
        <tag>虚拟开发板</tag>
        <tag>uboot</tag>
        <tag>qemu</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟开发板-uboot环境搭建</title>
    <url>/2017/04/27/VirtualBoard/%E8%99%9A%E6%8B%9F%E5%BC%80%E5%8F%91%E6%9D%BF-uboot%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>&emsp;&emsp;在本节会介绍如何从头搭建使用qemu + uboot的虚拟开发环境。<br><img src="https://img.blog.csdn.net/20171227173636412?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzk4OTI4NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="uboot"></p>
<a id="more"></a>

<h1 id="1-下载安装-uboot-qemu-arm-linux-gnu"><a href="#1-下载安装-uboot-qemu-arm-linux-gnu" class="headerlink" title="1.下载安装 uboot qemu arm-linux-gnu"></a>1.下载安装 uboot qemu arm-linux-gnu</h1><ul>
<li>uboot : <a href="https://www.denx.de/wiki/U-Boot/" target="_blank" rel="noopener">https://www.denx.de/wiki/U-Boot/</a></li>
<li>qemu : sudo apt-get install qemu</li>
<li>arm-linux-gcc : sudo apt-get install gcc-arm-linux-gnueabi 或 <a href="https://www.linaro.org/" target="_blank" rel="noopener">https://www.linaro.org/</a></li>
</ul>
<h1 id="2-编译uboot"><a href="#2-编译uboot" class="headerlink" title="2. 编译uboot"></a>2. 编译uboot</h1><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">ARCH</span>=arm</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">CROSS_COMPILE</span>=arm-linux-gnueabi-</span><br><span class="line">make vexpress_ca9x4_config</span><br><span class="line">make -j4</span><br></pre></td></tr></table></figure>
<h1 id="3-qemu启动uboot"><a href="#3-qemu启动uboot" class="headerlink" title="3. qemu启动uboot"></a>3. qemu启动uboot</h1><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">qemu-system-arm -M vexpress-a9 -m <span class="number">256</span>M -nographic -kernel u-boot</span><br></pre></td></tr></table></figure>
<p><img src="https://img.blog.csdn.net/20171227173636412?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzk4OTI4NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="uboot"></p>
<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>虚拟开发板</category>
        <category>Qemu</category>
      </categories>
      <tags>
        <tag>虚拟开发板</tag>
        <tag>uboot</tag>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟开发板-字符设备驱动</title>
    <url>/2017/06/29/VirtualBoard/%E8%99%9A%E6%8B%9F%E5%BC%80%E5%8F%91%E6%9D%BF-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<figure class="highlight plain"><figcaption><span>_______      ______   _______</span></figcaption><table><tr><td class="code"><pre><span class="line">(  ____ \|\     &#x2F;|(  ___  )    (  __  \ (  ____ )|\     &#x2F;|</span><br><span class="line">| (    \&#x2F;| )   ( || (   ) |    | (  \  )| (    )|| )   ( |</span><br><span class="line">| |      | (___) || (___) |    | |   ) || (____)|| |   | |</span><br><span class="line">| |      |  ___  ||  ___  |    | |   | ||     __)( (   ) )</span><br><span class="line">| |      | (   ) || (   ) |    | |   ) || (\ (    \ \_&#x2F; &#x2F;</span><br><span class="line">| (____&#x2F;\| )   ( || )   ( |    | (__&#x2F;  )| ) \ \__  \   &#x2F;</span><br><span class="line">(_______&#x2F;|&#x2F;     \||&#x2F;     \|    (______&#x2F; |&#x2F;   \__&#x2F;   \_&#x2F;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h1 id="udev机制"><a href="#udev机制" class="headerlink" title="udev机制"></a>udev机制</h1><p>udev提供一个基于用户空间的动态设备节点管理和命名的解决方案。<br>udev提供内核sysfs和tmpfs的支持，sysfs为udev提供设备入口和uevent通道，tmpfs为udev设备文件存放空间。</p>
<h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><p>中断机制减少轮询所带来的CPU高占用率</p>
<h1 id="Poll"><a href="#Poll" class="headerlink" title="Poll"></a>Poll</h1><p>Poll机制解决解决阻塞问题。</p>
<h1 id="信号通知"><a href="#信号通知" class="headerlink" title="信号通知"></a>信号通知</h1><p>信号通知解决数据异步通知的问题</p>
<h1 id="原子-信号量"><a href="#原子-信号量" class="headerlink" title="原子 信号量"></a>原子 信号量</h1><p>原子与信号量机制解决操作同步所带来的问题。</p>
<p>#驱动源码</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/gpio_keys.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/workqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/irqreturn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/irqnr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/hardirq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/irqflags.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mach/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"mach/../../mx28_pins.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach/pinctrl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mach/mx28.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">class</span>* <span class="title">first_cha_class</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span>* <span class="title">first_cha_device</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *gpfcon = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *gpfdat = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span>* <span class="title">Key_fasync</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_BUTTON_PIN		MXS_PIN_TO_GPIO(PINID_SSP0_DATA4)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> irq_no = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> press_id = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* irqname = <span class="string">"BoKey"</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(btn_wait_queue)</span></span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> event_press = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>  press_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">atomic_t</span> open_flag = ATOMIC_INIT(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//atomic_read</span></span><br><span class="line"><span class="comment">//atomic_inc</span></span><br><span class="line"><span class="comment">//atomic_dec</span></span><br><span class="line"><span class="comment">//atom_dec_and_test</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">first_ch_read</span> <span class="params">(struct file * pfile, <span class="keyword">char</span> __user * puser, <span class="keyword">size_t</span> cnt, <span class="keyword">loff_t</span> * poff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">"read\n"</span>);</span><br><span class="line">    wait_event_interruptible(btn_wait_queue, event_press);</span><br><span class="line">    event_press = <span class="number">0</span>;</span><br><span class="line">    copy_to_user(puser, (<span class="keyword">const</span> <span class="keyword">void</span>*)&amp;(press_cnt), <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">first_ch_write</span><span class="params">(struct file * pfile, <span class="keyword">const</span> <span class="keyword">char</span> __user * pusr, <span class="keyword">size_t</span> cnt, <span class="keyword">loff_t</span> * poff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">4</span>;</span><br><span class="line">	printk(<span class="string">"write\n"</span>);</span><br><span class="line">    copy_from_user(&amp;val, pusr, count);</span><br><span class="line">    printk(<span class="string">"the val is %d\n"</span>,val);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">key_handler</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    press_cnt += <span class="number">1</span>;</span><br><span class="line">    printk(<span class="string">"K: key down %d\n"</span>, press_cnt);</span><br><span class="line">    event_press = <span class="number">1</span>;</span><br><span class="line">    wake_up_interruptible(&amp;btn_wait_queue);</span><br><span class="line">    kill_fasync(&amp;Key_fasync, SIGIO, POLL_IN);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">first_ch_open</span><span class="params">(struct inode * pnode, struct file * pfile)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> iRet = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(atomic_read(&amp;open_flag) != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        atomic_dec(&amp;open_flag);</span><br><span class="line">        <span class="keyword">return</span> -EBUSY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">"open\n"</span>);</span><br><span class="line">    gpio_free(GPIO_BUTTON_PIN);     <span class="comment">//先清除原先的复用功能</span></span><br><span class="line">	iRet = gpio_request(GPIO_BUTTON_PIN, <span class="string">"irqtest"</span>);</span><br><span class="line">	<span class="keyword">if</span> (iRet != <span class="number">0</span>) &#123;</span><br><span class="line">		printk(<span class="string">"request gpio failed \n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line">	&#125;</span><br><span class="line">    gpio_direction_input(GPIO_BUTTON_PIN);  <span class="comment">//设置输入功能</span></span><br><span class="line">	irq_no  = gpio_to_irq(GPIO_BUTTON_PIN);     <span class="comment">//得到中断号</span></span><br><span class="line">	set_irq_type(irq_no, IRQF_TRIGGER_FALLING);	<span class="comment">//下降沿中断</span></span><br><span class="line">    err = request_irq(irq_no, key_handler, IRQF_TRIGGER_FALLING, irqname,(<span class="keyword">void</span>*)&amp;press_id);</span><br><span class="line">    printk(<span class="string">"The err is %d\n"</span>, err);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">first_ch_poll</span><span class="params">(struct file *fp, poll_table * wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	poll_wait(fp, &amp;btn_wait_queue, wait);</span><br><span class="line">	<span class="keyword">if</span>(event_press)</span><br><span class="line">        mask |= POLLIN | POLLRDNORM;</span><br><span class="line">    <span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">first_ch_sync</span><span class="params">(<span class="keyword">int</span> fd, struct file* filp, <span class="keyword">int</span> on)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">"Async Set\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> fasync_helper(fd, filp, on, &amp;Key_fasync);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">first_ch_fops</span> = &#123;</span></span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .<span class="built_in">open</span> = first_ch_open,</span><br><span class="line">    .<span class="built_in">read</span> = first_ch_read,</span><br><span class="line">    .<span class="built_in">write</span> = first_ch_write,</span><br><span class="line">    .poll = first_ch_poll,</span><br><span class="line">    .fasync = first_ch_sync,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">first_ch_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> major = <span class="number">0</span>;</span><br><span class="line">    major =  register_chrdev(<span class="number">0</span>, <span class="string">"first_drv"</span>, &amp;first_ch_fops);       <span class="comment">//当输入为0时，由系统自动分配</span></span><br><span class="line">    printk(<span class="string">"The major is %d\n"</span>, major);</span><br><span class="line">    first_cha_class = class_create(THIS_MODULE, <span class="string">"first_drv"</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(first_cha_class))</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">"class create failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    first_cha_device = device_create(first_cha_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">"first_cha"</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(first_cha_device))</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">"create device failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//gpfcon = (volatile unsigned long *)ioremap(0x56000000, 0x10);</span></span><br><span class="line">    <span class="comment">//gpfdat = gpfcon + 1;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数操作集合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">first_ch_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    device_unregister(first_cha_device);</span><br><span class="line">    class_destroy(first_cha_class);</span><br><span class="line">    <span class="comment">//iounmap(gpfcon);</span></span><br><span class="line">    free_irq(irq_no,(<span class="keyword">void</span>*)&amp;press_id);</span><br><span class="line">    atomic_inc(&amp;open_flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module_init(first_ch_init);</span><br><span class="line">module_exit(first_ch_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE (<span class="string">"GPL"</span>);<span class="comment">//开源协议GPL 或者Dual BSD</span></span><br><span class="line">MODULE_AUTHOR (<span class="string">"TOM"</span>);<span class="comment">//作者</span></span><br><span class="line">MODULE_DESCRIPTION (<span class="string">"MY_TEST"</span>);<span class="comment">//描述此驱动</span></span><br></pre></td></tr></table></figure>
<h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">obj-m := first_cha.o</span><br><span class="line">KDIR := /home/bo/Documents/linux-<span class="number">2.6</span>.<span class="number">35.3</span></span><br><span class="line">all:</span><br><span class="line">	make -C $(KDIR) M=$(PWD) modules CROSS_COMPILE=arm-<span class="attribute">none</span>-linux-gnueabi- ARCH=arm</span><br><span class="line">clean:</span><br><span class="line">	rm -f *<span class="selector-class">.ko</span> *<span class="selector-class">.o</span> *<span class="selector-class">.mod</span><span class="selector-class">.o</span> *<span class="selector-class">.mod</span><span class="selector-class">.c</span> *<span class="selector-class">.symvers</span> *<span class="selector-class">.bak</span> *.<span class="attribute">order</span></span><br></pre></td></tr></table></figure>

<h1 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h1><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">My_SigFun</span><span class="params">(<span class="keyword">int</span> nSigNum)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> nStatus = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> Oflags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pfd</span>[1];</span></span><br><span class="line">	signal(SIGIO, My_SigFun);</span><br><span class="line">	fd = <span class="built_in">open</span>(<span class="string">"/dev/first_cha"</span>, O_RDWR);</span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"open failed\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将当前进程PID设置为fd文件所对应驱动程序将要发送SIGIO,SIGUSR信号进程PID</span></span><br><span class="line">    fcntl(fd, F_SETOWN, getpid());</span><br><span class="line">    <span class="comment">//获取fd的打开方式</span></span><br><span class="line">    Oflags = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="comment">//将fd的打开方式设置为FASYNC --- 即 支持异步通知</span></span><br><span class="line">    <span class="comment">//该行代码执行会触发 驱动程序中 file_operations-&gt;fasync 函数 ------fasync函数调用fasync_helper初始化一个fasync_struct结构体，该结构体描述了将要发送信号的进程PID (fasync_struct-&gt;fa_file-&gt;f_owner-&gt;pid)</span></span><br><span class="line">    fcntl(fd, F_SETFL, Oflags | FASYNC);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">write</span>(fd, &amp;val, <span class="number">4</span>);</span><br><span class="line">	pfd[<span class="number">0</span>].fd = fd;</span><br><span class="line">	pfd[<span class="number">0</span>].events = POLLIN;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		nStatus = poll(pfd, <span class="number">1</span>, <span class="number">5000</span>);</span><br><span class="line">		<span class="keyword">if</span>(nStatus == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"timeout\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">		<span class="built_in">read</span>(fd, &amp;val);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"A: cnt: %d\n"</span>, val);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">My_SigFun</span><span class="params">(<span class="keyword">int</span> nSigNum)</span>		<span class="comment">// kill -USR1 pid</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Get Sig\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>虚拟开发板</category>
        <category>Qemu</category>
      </categories>
      <tags>
        <tag>虚拟开发板</tag>
        <tag>字符设备</tag>
      </tags>
  </entry>
  <entry>
    <title>ViVado 找不到设备</title>
    <url>/2017/07/28/Zynq/ViVado-%E6%89%BE%E4%B8%8D%E5%88%B0%E8%AE%BE%E5%A4%87/</url>
    <content><![CDATA[<p>Vivado 在Linux上找不到设备是因为jtag驱动没安装，</p>
<p>情况如下：<br><img src="https://img.blog.csdn.net/20170307195938050?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQ2lyc19x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image"></p>
<a id="more"></a>
<p>而在Linux上需要以下几条命令进行安装：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">sudo -s</span><br><span class="line">cd <span class="regexp">/opt/</span>Xilinx<span class="regexp">/Vivado/</span><span class="number">2017.1</span><span class="regexp">/data/</span>xicom<span class="regexp">/cable_drivers/</span>lin64/</span><br><span class="line">cp -a install_script<span class="regexp">/ /</span>opt/</span><br><span class="line">cd /opt</span><br><span class="line">.<span class="regexp">/install_script/</span>install_drivers/install_drivers</span><br></pre></td></tr></table></figure>
<p>官方回复见此处：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">https:<span class="regexp">//</span>www.xilinx.com<span class="regexp">/support/</span>answers<span class="regexp">/54381.html</span></span><br></pre></td></tr></table></figure>




<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>Zynq</category>
        <category>Vivado</category>
      </categories>
      <tags>
        <tag>Vivado</tag>
      </tags>
  </entry>
  <entry>
    <title>常用命令</title>
    <url>/2019/10/02/%E6%97%A5%E5%B8%B8/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>日常用到的命令记录。</p>
<a id="more"></a>
<ul>
<li>使用命令查看当前目录下目录的大小<code>du -h --max-depth=1</code></li>
<li>挂载移动硬盘、Upan无法卸载，使用fuser命令查看占用进程，然后使用kill命令杀死占用进程即可<code>sudo fuser -m -v Ext4</code></li>
</ul>
]]></content>
      <categories>
        <category>日常</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM要分清</title>
    <url>/2016/12/24/ARM&amp;Linux/ARM%E5%9F%BA%E7%A1%80/ARM%E8%A6%81%E5%88%86%E6%B8%85/</url>
    <content><![CDATA[<p>&emsp;&emsp;总是有人在说，我是搞ARM的，到底是说的ARM架构还是ARM系列，这点要搞清楚！<br><img src="https://upload-images.jianshu.io/upload_images/7774609-4c8561ce252293b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="aRM.png"></p>
<a id="more"></a>
<p>&emsp;&emsp;在Dock看来，ARM有两个概念，ARM架构、ARM系列,不同的架构，不同的系列在性能、功耗、尤其是价格方面有着很大的不同。</p>
<h1 id="1-ARM公司"><a href="#1-ARM公司" class="headerlink" title="1. ARM公司"></a>1. ARM公司</h1><p>&emsp;&emsp;<code>ARM</code>(Advanced RISC Machine)公司作为半导体行业最为著名的公司，你不能不知道。详情看度娘<a href="https://baike.baidu.com/item/arm%E5%85%AC%E5%8F%B8/2265170?fr=aladdin" target="_blank" rel="noopener">ARM</a>。<br>下面我们重点说<code>架构</code>和<code>系列</code>两个概念。</p>
<h1 id="2-ARM架构"><a href="#2-ARM架构" class="headerlink" title="2. ARM架构"></a>2. ARM架构</h1><p>&emsp;&emsp;ARM架构指的就是这颗芯片内核所用的指令集的版本。C++语言还有<code>C++10</code>、<code>C++11</code>版本之说，更何况内核呢？</p>
<p>&emsp;&emsp;最为显著的就是总线宽度。”Thumb指令集”为16位，”ARM指令集”为32位,以及”ISA指令集”为64位。这也就从根本上区分了每一个ARM内核有所不同。当然ARM还有很多很多不同的拓展功能，如<code>Java加速器-Jazelle</code>、<code>TrustZone技术</code>、<code>SIMD</code>等，这些不同的组合就组成了不同的ARM架构。</p>
<h2 id="2-1-ARMv4-ARMv5-ARMv6-ARMv7"><a href="#2-1-ARMv4-ARMv5-ARMv6-ARMv7" class="headerlink" title="2.1 ARMv4 ARMv5 ARMv6 ARMv7"></a>2.1 ARMv4 ARMv5 ARMv6 ARMv7</h2><p>&emsp;&emsp;这是市面上最老的ARM架构版本了。只支持32位地址空间，ARM7系列的一些芯片用到了这个指令集。</p>
<p>&emsp;&emsp;ARMv5相较于v4架构增加了DSP指令优化。</p>
<p>&emsp;&emsp;ARMv6 在存储系统、异常处理等方面做了很多改进，最为重要的是增加了对多媒体处理的支持。</p>
<p>&emsp;&emsp;ARMv7增加了NEON GPU多媒体处理支持，将DSP和媒体处理能力提高了近四倍，并且支持改良的浮点运算。满足下一代3D图形应用的需求，也就是从v7开始，ARMv7架构的处理器芯片开始应用于智能终端设备。</p>
<h2 id="2-2-ARMv8"><a href="#2-2-ARMv8" class="headerlink" title="2.2 ARMv8"></a>2.2 ARMv8</h2><p>&emsp;&emsp;2011年11月，ARM公司发布了新一代处理器架构ARMv8的部分技术细节。这是ARM公司的首款支持64位指令集的处理器架构。但其支持AArch32 AArch64两套指令集，为的就是向前兼容32位的应用。</p>
<h2 id="2-3-拓展"><a href="#2-3-拓展" class="headerlink" title="2.3 拓展"></a>2.3 拓展</h2><p>&emsp;&emsp;有时候我们又能看到<code>ARMv5TEJ</code>等词汇，这又是什么意思，后面的每一个字母代表一种拓展功能。如 T-Thumb指令集、E-增强型DSP指令 J-Java加速器。</p>
<h1 id="3-ARM系列"><a href="#3-ARM系列" class="headerlink" title="3. ARM系列"></a>3. ARM系列</h1><p>&emsp;&emsp;在相同的指令集下，搭配不同的部件就可以组成不同的功能的处理器。比如有无内存管理，有无调试功能等。</p>
<h2 id="3-1-ARM7-11"><a href="#3-1-ARM7-11" class="headerlink" title="3.1 ARM7-11"></a>3.1 ARM7-11</h2><p>&emsp;&emsp;ARM7 - ARM11是比较老的一些处理器器了。其主要的分别大致如下：</p>
<ul>
<li>ARM7是低功耗的32位处理器，主要特点是没有MMU(内存管理)，如果有人给你说他用ARM7跑系统，你就可以<code>呵呵</code>了。</li>
<li>相较于ARM7,增加了MMU和Cache,指令集执行效率相比于ARM7有很大提高，最高可达300MIPS。</li>
<li>ARM11,基于ARMv6指令集架构，在实时性和浮点处理方面有很大提高。</li>
</ul>
<h2 id="3-2-ARM-Cortex"><a href="#3-2-ARM-Cortex" class="headerlink" title="3.2 ARM-Cortex"></a>3.2 ARM-Cortex</h2><p>&emsp;&emsp;在ARM11以后，ARM就不再以数字进行ARM处理器系列进行区分，而是使用<code>Cortex</code>进行命名。主要区分为一下三个系列：</p>
<ul>
<li>Cortex-A 和 Cortex-A50 系列 - 面向开放式操作系统的高性能处理器。</li>
<li>Cortex-R 系列- 面向实时应用的卓越性能。</li>
<li>Cortex-M 系列 - 面向具有确定性的微控制器应用的成本功耗敏感型解决方案。</li>
</ul>
<p>&emsp;&emsp;ARM Cortex-A 内核基于ARMv7-A架构，基本上都可以支持ARM、Thumb-2、Thumb指令集、Java加速扩展的Jazelle技术、ThustZone的安全扩展、针对浮点FPU的VFP硬件扩展、DSP &amp; SIMD 扩展、并行多数据SIMD的NEON多媒体处理器扩展、主流的嵌入式OS（Linux、Android、Windows Mobile、Windows Phone、Symbian）、以及支持分支预测branch prediction。但各处理器在VFP/NEON的类型、半精度浮点（16-bit half precision floating-point）的支持、多核MPCore、流水线pipeline、单MHz处理性能、L1/L2 cache控制器、乱序执行、指令dual-issue并发等方面有略有不同。</p>
<p>&emsp;&emsp;Cortex-R系列的内核接触不多，主要用于实时控制领域。我所知道的在Xilinx的MPSOC芯片中就使用了两颗R-5内核作为对A-9内核的实时增强。</p>
<p>&emsp;&emsp;Cortex-M处理器家族更多的集中在低性能端，但是这些处理器相比于许多微控制器使用的传统处理器性能仍然很强大。例如，Cortex-M4和Cortex-M7处理器应用在许多高性能的微控制器产品中，最大的时钟频率可以达到400Mhz。如我们最熟悉的Stm32就是基于Cortex-M系列处理器。</p>
<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>ARM&amp;Linux</category>
        <category>ARM基础</category>
      </categories>
      <tags>
        <tag>ARM</tag>
        <tag>ARM架构</tag>
        <tag>ARM系列</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中断处理机制之我见</title>
    <url>/2017/06/14/ARM&amp;Linux/Linux%E9%A9%B1%E5%8A%A8/Linux%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E4%B9%8B%E6%88%91%E8%A7%81/</url>
    <content><![CDATA[<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>ARM&amp;Linux</category>
        <category>Linux驱动</category>
      </categories>
  </entry>
  <entry>
    <title>Linux MTD架构分析</title>
    <url>/2017/08/27/ARM&amp;Linux/Linux%E9%A9%B1%E5%8A%A8/Linux-MTD%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>介绍Linux MTD子系统架构划分。</p>
<a id="more"></a>
<p>MTD，Memory Technology Device即内存技术设备，在Linux内核中，引入MTD层为NOR FLASH和NAND FLASH设备提供统一接口。MTD将文件系统与底层FLASH存储器进行了隔离。</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">字符设备节点					块设备节点</span><br><span class="line">	|<span class="string">							</span>|</span><br><span class="line">MTD字符设备					MTD块设备驱动</span><br><span class="line">		\                  /</span><br><span class="line">		 \				  /</span><br><span class="line">			MTD原始设备</span><br><span class="line">				|</span><br><span class="line"><span class="string">			Flash驱动程序</span></span><br><span class="line"><span class="string">				</span>|</span><br><span class="line">			   硬件</span><br></pre></td></tr></table></figure>
<p><strong>Flash硬件驱动层</strong>：Flash硬件驱动层负责对Flash硬件的读、写和擦除操作。MTD设备的Nand Flash芯片的驱动则drivers/mtd/nand/子目录下,Nor Flash芯片驱动位于drivers/mtd/chips/子目录下。</p>
<p><strong>MTD原始设备层：</strong>用于描述MTD原始设备的数据结构是mtd_info，它定义了大量的关于MTD的数据和操作函数。其中<strong>mtdcore.c</strong>:  MTD原始设备接口相关实现<strong>，mtdpart.c</strong> :  MTD分区接口相关实现。</p>
<p><strong>MTD设备层：</strong>基于MTD原始设备，linux系统可以定义出MTD的<strong>块设备（主设备号31）</strong>和<strong>字符设备（设备号90）</strong>。其中<strong>mtdchar.c</strong> :  MTD字符设备接口相关实现，<strong>mtdblock.c</strong> : MTD块设备接口相关实现。</p>
<p><strong>设备节点：</strong>通过mknod在/dev子目录下建立<strong>MTD块设备节点（主设备号为31）</strong>和<strong>MTD字符设备节点（主设备号为90）</strong>。通过访问此设备节点即可访问MTD字符设备和块设备。<br><img src="https://img.blog.csdn.net/20140319203528000?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHdqMTAzODYyMDk1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="MTD分层"></p>
<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>ARM&amp;Linux</category>
        <category>Linux驱动</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>MTD</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux启动过程之我见</title>
    <url>/2017/06/01/ARM&amp;Linux/Linux%E9%A9%B1%E5%8A%A8/Linux%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E4%B9%8B%E6%88%91%E8%A7%81/</url>
    <content><![CDATA[<p>本章介绍Linux启动过程和涉及的各个文件的作用。</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">_________ _       __________________</span><br><span class="line">\__   __/( (    /|<span class="string">\__   __/\__   __/</span></span><br><span class="line"><span class="string">   ) (   </span>|<span class="string">  \  ( </span>|<span class="string">   ) (      ) (</span></span><br><span class="line"><span class="string">   </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string">   \ </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string">      </span>|<span class="string"> </span>|</span><br><span class="line">   |<span class="string"> </span>|<span class="string">   </span>|<span class="string"> (\ \) </span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string">      </span>|<span class="string"> </span>|</span><br><span class="line">   |<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string"> \   </span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string">      </span>|<span class="string"> </span>|</span><br><span class="line">___) (___|<span class="string"> )  \  </span>|<span class="string">___) (___   </span>|<span class="string"> </span>|</span><br><span class="line">\_______/|<span class="string">/    )_)\_______/   )_(</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="Init进程"><a href="#Init进程" class="headerlink" title="Init进程"></a>Init进程</h1><p>&emsp;&emsp;Init进程是第一个启动的进程，ID号为1，这个程序通常位于<code>/sbin.init</code>，改程序的源码位于<code>init/main.c</code>。当然我们也可以指定自己编写的初始化启动程序，传入启动参数的时候传入<code>init=xxx</code>即可。</p>
<p>&emsp;&emsp;<code>/sbin/init</code>、<code>/etc/init</code>、<code>/bin/init</code>、<code>/bin/sh</code>都是作为Init程序的备选者，有一个存在就会进入不再返回。</p>
<p>&emsp;&emsp;busybox的Init会先<code>设置信号处理函数</code>、<code>初始化控制台</code>、<code>解析inittab</code>等三项工作。</p>
<h1 id="解析Inittab"><a href="#解析Inittab" class="headerlink" title="解析Inittab"></a>解析Inittab</h1><p><code>inittab</code>中每一个条目定义了一个子进程。其条目格式如下:</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">id : <span class="type">runlevels</span> : <span class="type">action</span> : <span class="type">process</span></span><br></pre></td></tr></table></figure>
<ul>
<li>id 表示这个进程要使用的控制台,(标准输入、标准输出、标准错误输出)</li>
<li>runlevels 列出来运行的级别 为空则代表所有级别</li>
<li>action 要执行的动作</li>
<li>process 要执行的程序</li>
</ul>
<h2 id="Action详解"><a href="#Action详解" class="headerlink" title="Action详解"></a>Action详解</h2><table>
<thead>
<tr>
<th align="center">action名称</th>
<th align="center">执行条件</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">sysinit</td>
<td align="center">系统启动后最先执行</td>
<td align="center">只执行一次，init执行完成后才能执行其他操作</td>
</tr>
<tr>
<td align="center">wait</td>
<td align="center">系统执行完sysinit后</td>
<td align="center">只执行一次，init进程等待它执行完成后才执行其他操作</td>
</tr>
<tr>
<td align="center">once</td>
<td align="center">系统执行完wait进程后</td>
<td align="center">只执行一次， init不等它执行完成</td>
</tr>
<tr>
<td align="center">respwan</td>
<td align="center">启动完once进程后</td>
<td align="center">init进程发现子进程退出时，重新启动它</td>
</tr>
<tr>
<td align="center">askfirst</td>
<td align="center">启动完respwan进程后</td>
<td align="center">输出“Please Press Enter to activcate this console”等用户输入回车键后才启动子进程</td>
</tr>
<tr>
<td align="center">shutdown</td>
<td align="center">系统关机时启动</td>
<td align="center">重启 关闭系统命令时</td>
</tr>
<tr>
<td align="center">ctrlaltdel</td>
<td align="center">按下 Ctrl + Alt +Del 时</td>
<td align="center">-</td>
</tr>
</tbody></table>
<h3 id="inittab文件实例"><a href="#inittab文件实例" class="headerlink" title="inittab文件实例"></a>inittab文件实例</h3><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"># /etc/inittab</span><br><span class="line"><span class="meta">::sysinit:/etc/init.d/rcS</span></span><br><span class="line"><span class="meta">ttySAC0:askfirst:~/bin/sh</span></span><br><span class="line"><span class="meta">::shutdown:/bin/umount</span> -a</span><br></pre></td></tr></table></figure>
<p>同样在<code>rcS</code>一般只有两行</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#/bin/sh</span></span><br><span class="line"><span class="string">ifconfig</span> <span class="string">eth0</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.100</span></span><br><span class="line"><span class="string">mount</span> <span class="string">-a</span></span><br></pre></td></tr></table></figure>
<p>那么 <code>mount -a</code>依据那个文件呢？</p>
<h2 id="fastab文件"><a href="#fastab文件" class="headerlink" title="fastab文件"></a>fastab文件</h2><p>一个典型的fstab文件如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"># &lt;file system&gt;&lt;dir&gt;&lt;type&gt;&lt;options&gt;&lt;dump&gt;&lt;pass&gt;</span><br><span class="line">none                   /dev/pts      devpts    defaults                <span class="number">0</span>      <span class="number">0</span></span><br><span class="line">none                   /dev/shm      tmpfs     defaults                <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"></span><br><span class="line">/dev/cdrom             /media/cd     iso9660   ro,user,noauto,unhide   <span class="number">0</span>      <span class="number">0</span></span><br><span class="line">/dev/dvd               /media/dvd    udf       ro,user,noauto,unhide   <span class="number">0</span>      <span class="number">0</span></span><br><span class="line">/dev/fd0               /media/fl     <span class="built_in">auto</span>      user,noauto             <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"></span><br><span class="line">/dev/hda1              swap          swap      defaults                <span class="number">0</span>      <span class="number">0</span></span><br><span class="line">/dev/hda4              /             ext3      defaults                <span class="number">0</span>      <span class="number">1</span></span><br><span class="line">/dev/hda3              /home         xfs       rw,suid,exec,<span class="built_in">auto</span>,nouser,async <span class="number">0</span>      <span class="number">2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>file systems 不是我们通常理解的文件系统，而是指设备（硬盘及其分区，DVD光驱等）。它告知我们设备（分区）的名字，这是你在命令行中挂载（mount）、卸载（umount）设备时要用到的。so one should substitute for this entry the device name, remote partition, or similar.</li>
<li>挂载目录</li>
<li>type 指挂载设备或分区为何种文件系统类型（例如：ext2, ext3, reiserfs, xfs, jfs, smbfs, iso9660, vfat, ntfs, swap等）。 archLinux支持许多文件系统。 要得到一个完整的支持名单查找mount man-page。典型 的名字包括这些：ext2, ext3, reiserfs, xfs, jfs, smbfs, iso9660, vfat, ntfs, swap和auto, ‘auto’ 不是一个文件系统，而是让mount命令自动判断文件类型，特别对于可移动设备，软盘，DVD驱动器，这样做是很有必要的，因为可能每次挂载的文件类型不一致。</li>
<li>选项，这部分是最有用的设置，它能使你所挂载的设备在开机时自动加载、使中文显示不出现乱码、限制对挂载分区读写权限。它是与mount命令的用法相关的。<ul>
<li>noatime   关闭atime特性，提高性能，这是一个很老的特性，放心关闭，还能减少loadcycle</li>
<li>defaults  使用默认设置。等于rw,suid,dev,exec,auto,nouser,async，具体含义看下面的解释</li>
<li>auto  在启动或在终端中输入mount -a时自动挂载</li>
<li>noauto  设备（分区）只能手动挂载</li>
<li>iocharset＝   在＝号后面加入你的本地编码，似乎在这个设备（分区）中做文件IO的时候就会自动做编码的格式转换。</li>
<li>ro  挂载为只读权限</li>
<li>rw   挂载为读写权限</li>
<li>exec     是一个默认设置项，它使在那个分区中的可执行的二进制文件能够执行。</li>
<li>noexec  二进制文件不允许执行。千万不要在你的root分区中用这个选项</li>
<li>sync      所有的I/O将以同步方式进行</li>
<li>async  所有的I/O将以非同步方式进行</li>
</ul>
</li>
<li>dump 备份相关</li>
<li>pass sck会检查这个头目下的数字来决定检查文件系统的顺序（looks at the number substituted for <pass> and determines in which order the file systems should be checked）。允许的数字是0, 1, 和2。 文件系统的<pass>选项是0将不会被fsck utility检查。root文件系统应该拥有最高的优先权， 1，而所有其它的文件系统，如果你想让它被check的话，应该写成2。</li>
</ul>
<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>ARM&amp;Linux</category>
        <category>Linux驱动</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Init</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM指令之必知必会</title>
    <url>/2016/12/27/ARM&amp;Linux/ARM%E5%9F%BA%E7%A1%80/ARM%E6%8C%87%E4%BB%A4%E4%B9%8B%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
    <content><![CDATA[<p>&emsp;&emsp;作为一个嵌入式开发者，ARM汇编指令虽然用的不多。但也是一个必须要掌握的项目。<br><img src="https://img.blog.csdn.net/20171226140842368?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzk4OTI4NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="ARM汇编"></p>
<a id="more"></a>
<ul>
<li><p>跳转指令<br><code>b</code> <code>bl</code>这两条指令都是跳转到相应的标号处，所不同的是<code>bl</code>还会将返回地址保存在<code>lr</code>返回寄存器中。</p>
</li>
<li><p>内存传送指令<br><code>mov</code>会是我们经常要用到的一条指令。有寄存器转移<code>mov r1, r0</code>和立即数转移两种方式<code>mov r1, #1224</code></p>
</li>
<li><p>地址读取伪指令 <code>ldr</code>也有两种方式<code>ldr r1, =1234</code> 和取标号地址<code>ldr r1, =label</code></p>
</li>
<li><p>内存访问指令</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ldr </span><span class="built_in">r1</span>, [<span class="built_in">r2</span>, <span class="number">#3</span>]    //将<span class="built_in">r2</span>+<span class="number">3</span>地址处的内容读取到<span class="built_in">r1</span>中</span><br><span class="line"><span class="keyword">ldr </span><span class="built_in">r1</span>, [<span class="built_in">r2</span>], <span class="number">#4</span>    //将<span class="built_in">r2</span>地址处的内容读取到<span class="built_in">r1</span>，然后<span class="built_in">r2</span><span class="symbol">=r2</span>+<span class="number">4</span></span><br><span class="line"><span class="keyword">str </span><span class="built_in">r1</span>, [<span class="built_in">r2</span>, <span class="number">#4</span>]    //将<span class="built_in">r1</span>中的内容保存到 <span class="built_in">r2</span>+<span class="number">4</span> 地址处</span><br><span class="line"><span class="keyword">str </span><span class="built_in">r1</span>, [<span class="built_in">r2</span>], <span class="number">#4</span>    //将<span class="built_in">r1</span>中的数据保存到<span class="built_in">r2</span>地址处，然后<span class="built_in">r2</span><span class="symbol">=r2</span>+<span class="number">4</span></span><br></pre></td></tr></table></figure></li>
<li><p>加减指令</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add </span><span class="built_in">r1</span>, <span class="built_in">r2</span>, <span class="number">#1</span>      // <span class="built_in">r1</span> = <span class="built_in">r2</span> + <span class="number">1</span></span><br><span class="line"><span class="keyword">sub </span><span class="built_in">r1</span>, <span class="built_in">r2</span>, <span class="number">#1</span>      // <span class="built_in">r1</span> = <span class="built_in">r2</span> - <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>状态寄存器访问指令</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">msr </span><span class="keyword">cpsr, </span><span class="built_in">r0</span>    //<span class="keyword">cpsp </span>= <span class="built_in">r0</span></span><br><span class="line"><span class="keyword">mrs </span><span class="built_in">r0</span>, <span class="keyword">cpsr </span>   //<span class="built_in">r0</span> = <span class="keyword">cpsr</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>ARM&amp;Linux</category>
        <category>ARM基础</category>
      </categories>
      <tags>
        <tag>ARM指令</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux统一设备模型之我见</title>
    <url>/2017/06/06/ARM&amp;Linux/Linux%E9%A9%B1%E5%8A%A8/Linux%E7%BB%9F%E4%B8%80%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B%E4%B9%8B%E6%88%91%E8%A7%81/</url>
    <content><![CDATA[<p>Linux设备模型为内核建立起一个统一的设备模型，从而有一个对系统结构的一般性抽象描述。</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">______   _______          _________ _______  _______</span><br><span class="line">(  __  \ (  ____ \|<span class="string">\     /</span>|<span class="string">\__   __/(  ____ \(  ____ \</span></span><br><span class="line">|<span class="string"> (  \  )</span>|<span class="string"> (    \/</span>|<span class="string"> )   ( </span>|<span class="string">   ) (   </span>|<span class="string"> (    \/</span>|<span class="string"> (    \/</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">   ) </span>||<span class="string"> (__    </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string">      </span>|<span class="string"> (__</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>||<span class="string">  __)   ( (   ) )   </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string">      </span>|<span class="string">  __)</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">   ) </span>||<span class="string"> (       \ \_/ /    </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string">      </span>|<span class="string"> (</span></span><br><span class="line">|<span class="string"> (__/  )</span>|<span class="string"> (____/\  \   /  ___) (___</span>|<span class="string"> (____/\</span>|<span class="string"> (____/\</span></span><br><span class="line"><span class="string">(______/ (_______/   \_/   \_______/(_______/(_______/</span></span><br><span class="line"></span><br><span class="line"><span class="string">_______  _______  ______   _______  _</span></span><br><span class="line"><span class="string">(       )(  ___  )(  __  \ (  ____ \( \</span></span><br><span class="line">|<span class="string"> () () </span>||<span class="string"> (   ) </span>||<span class="string"> (  \  )</span>|<span class="string"> (    \/</span>|<span class="string"> (</span></span><br><span class="line">|<span class="string"> </span>||<span class="string"> </span>||<span class="string"> </span>||<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>||<span class="string"> </span>|<span class="string">   ) </span>||<span class="string"> (__    </span>|<span class="string"> </span>|</span><br><span class="line">|<span class="string"> </span>|<span class="string">(_)</span>|<span class="string"> </span>||<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>||<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>||<span class="string">  __)   </span>|<span class="string"> </span>|</span><br><span class="line">|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>||<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>||<span class="string"> </span>|<span class="string">   ) </span>||<span class="string"> (      </span>|<span class="string"> </span>|</span><br><span class="line">|<span class="string"> )   ( </span>||<span class="string"> (___) </span>||<span class="string"> (__/  )</span>|<span class="string"> (____/\</span>|<span class="string"> (____/\</span></span><br><span class="line">|<span class="string">/     \</span>|<span class="string">(_______)(______/ (_______/(_______/</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h1><p>在 Linux 2.5 内核的开发过程中，人们设计了一套新的设备模型，目的是为了对计算机上的所有设备进行统一地表示和操作，包括设备本身和设备之间的连接关系。这个模型是在分析了 PCI 和 USB 的总线驱动过程中得到的，这两个总线类型能代表当前系统中的大多数设备类型，它们都有完善的热挺拔机制和电源管理的支持，也都有级连机制的支持，以桥接的 PCI/USB 总线控制器的方式可以支持更多的 PCI/USB 设备。为了给所有设备添加统一的电源管理的支持，而不是让每个设备中去独立实现电源管理的支持，人们考虑的是如何尽可能地重用代码；而且在有层次模型的 PCI/USB 总线中，必须以合理形式展示出这个层次关系，这也是电源管理等所要求的必须有层次结构。</p>
<p>如在一个典型的 PC 系统中，中央处理器(CPU)能直接控制的是 PCI 总线设备，而 USB 总线设备是以一个 PCI 设备(PCI-USB桥)的形式接入在 PCI 总线设备上，外部 USB 设备再接入在 USB 总线设备上；当计算机执行挂起(suspend)操作时， Linux 内核应该以 “外部USB设备-&gt;USB总线设备-&gt;PCI总线设备” 的顺序通知每一个设备将电源挂起；执行恢复(resume)时则以相反的顺序通知；反之如果不按此顺序则将有设备得不到正确的电源状态变迁的通知，将无法正常工作。</p>
<h1 id="2-Linux统一设备模型"><a href="#2-Linux统一设备模型" class="headerlink" title="2.Linux统一设备模型"></a>2.Linux统一设备模型</h1><h2 id="2-1-基本结构"><a href="#2-1-基本结构" class="headerlink" title="2.1 基本结构"></a>2.1 基本结构</h2><table>
<thead>
<tr>
<th>类型</th>
<th>所包含的内容</th>
<th>对应的内核数据结构</th>
</tr>
</thead>
<tbody><tr>
<td>设备（Device）</td>
<td>设备是此模型中最基本的类型，以设备本身的连接按层次组织</td>
<td>struct device</td>
</tr>
<tr>
<td>设备驱动（Device Drivver）</td>
<td>在一个系统中安装多个相同设备，只需要一份驱动程序的支持</td>
<td>struct device_driver</td>
</tr>
<tr>
<td>总线类型(Bus Types)</td>
<td>在整个总线级别对此总线上连接的所有设备进行管理</td>
<td>struct bus_type</td>
</tr>
<tr>
<td>设备类别(Device Classes)</td>
<td>按照功能进行分类组织的设备层次树,如键盘在输入类下</td>
<td>struct class</td>
</tr>
</tbody></table>
<h2 id="2-1-基本连接"><a href="#2-1-基本连接" class="headerlink" title="2.1 基本连接"></a>2.1 基本连接</h2><p>从内核在实现它们时所使用的数据结构来说， Linux 统一设备模型又是以两种基本数据结构进行树型和链表型结构组织的：</p>
<ul>
<li>kobject: 在 Linux 设备模型中最基本的对象，它的功能是提供引用计数和维持父子(parent)结构、平级(sibling)目录关系，上面的 device, device_driver 等各对象都是以 kobject 基础功能之上实现的。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> &#123;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>              *name;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">entry</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>          *<span class="title">parent</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kset</span>             *<span class="title">kset</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span>        *<span class="title">ktype</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_dirent</span>     *<span class="title">sd</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kref</span>             <span class="title">kref</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> state_initialized:<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> state_in_sysfs:<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> state_add_uevent_sent:<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> state_remove_uevent_sent:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
其中 struct kref 内含一个 atomic_t 类型用于引用计数， parent 是单个指向父节点的指针， entry 用于父 kset 以链表头结构将 kobject 结构维护成双向链表；</li>
<li>kset: 它用来对同类型对象提供一个包装集合，在内核数据结构上它也是由内嵌一个 kboject 实现，因而它同时也是一个 kobject (面向对象 OOP 概念中的继承关系) ，具有 kobject 的全部功能。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">truct kset &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">        <span class="keyword">spinlock_t</span> list_lock;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kset_uevent_ops</span> *<span class="title">uevent_ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
其中的 struct list_head list 用于将集合中的 kobject 按 struct list_head entry 维护成双向链表。</li>
</ul>
<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>ARM&amp;Linux</category>
        <category>Linux驱动</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>统一设备模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux输入子系统之我见(一)</title>
    <url>/2017/06/02/ARM&amp;Linux/Linux%E9%A9%B1%E5%8A%A8/Linux%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%88%91%E8%A7%81-%E4%B8%80/</url>
    <content><![CDATA[<p>本章介绍Linux输入子系统的基本概念。</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">_________ _        _______          _________</span><br><span class="line">\__   __/( (    /|<span class="string">(  ____ )</span>|<span class="string">\     /</span>|<span class="string">\__   __/</span></span><br><span class="line"><span class="string">   ) (   </span>|<span class="string">  \  ( </span>||<span class="string"> (    )</span>||<span class="string"> )   ( </span>|<span class="string">   ) (</span></span><br><span class="line"><span class="string">   </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string">   \ </span>|<span class="string"> </span>||<span class="string"> (____)</span>||<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>|</span><br><span class="line">   |<span class="string"> </span>|<span class="string">   </span>|<span class="string"> (\ \) </span>||<span class="string">  _____)</span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>|</span><br><span class="line">   |<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string"> \   </span>||<span class="string"> (      </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>|</span><br><span class="line">___) (___|<span class="string"> )  \  </span>||<span class="string"> )      </span>|<span class="string"> (___) </span>|<span class="string">   </span>|<span class="string"> </span>|</span><br><span class="line">\_______/|<span class="string">/    )_)</span>|<span class="string">/       (_______)   )_(</span></span><br><span class="line"></span><br><span class="line"><span class="string"> _______           ______   _______           _______</span></span><br><span class="line"><span class="string">(  ____ \</span>|<span class="string">\     /</span>|<span class="string">(  ___ \ (  ____ \</span>|<span class="string">\     /</span>|<span class="string">(  ____ \</span></span><br><span class="line">|<span class="string"> (    \/</span>|<span class="string"> )   ( </span>||<span class="string"> (   ) )</span>|<span class="string"> (    \/( \   / )</span>|<span class="string"> (    \/</span></span><br><span class="line">|<span class="string"> (_____ </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>||<span class="string"> (__/ / </span>|<span class="string"> (_____  \ (_) / </span>|<span class="string"> (_____</span></span><br><span class="line"><span class="string">(_____  )</span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>||<span class="string">  __ (  (_____  )  \   /  (_____  )</span></span><br><span class="line"><span class="string">      ) </span>||<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>||<span class="string"> (  \ \       ) </span>|<span class="string">   ) (         ) </span>|</span><br><span class="line">/\____) ||<span class="string"> (___) </span>||<span class="string"> )___) )/\____) </span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string">   /\____) </span>|</span><br><span class="line">\_______)(_______)|<span class="string">/ \___/ \_______)   \_/   \_______)</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h1 id="1-分层"><a href="#1-分层" class="headerlink" title="1.分层"></a>1.分层</h1><p>Linux输入子系统分为三层：</p>
<ul>
<li>输入子系统事件处理层(EventHandler)：用户编程的接口，并处理驱动层提交的数据。</li>
<li>输入子系统核心层(InputCore)，为设备驱动层提供接口，核心层会自动把数据提交给事件处理层。</li>
<li>输入子系统设备驱动层，实现对硬件的读写访问，中断设置、并把硬件产生的事件转换为核心层定义的规范提交给事件处理层</li>
</ul>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">                    核心层</span><br><span class="line">                    /    \</span><br><span class="line">                  /        \</span><br><span class="line">          事件处理层           设备驱动层</span><br><span class="line">                /            (键盘、鼠标、TS)</span><br><span class="line">               /</span><br><span class="line">          设备节点</span><br><span class="line">（/dev/input/event*）</span><br><span class="line"> (<span class="regexp">/dev/input</span><span class="regexp">/misc)</span></span><br></pre></td></tr></table></figure>
<p>输入子系统核心代码为driver/input/input.c</p>
<h1 id="2-编程要点"><a href="#2-编程要点" class="headerlink" title="2.编程要点"></a>2.编程要点</h1><p>在使用Linux输入子系统进行编程时，需要进行一下三步：</p>
<ul>
<li>分配Input Device结构体</li>
<li>在该结构体中设置该设备支持的事件类型及具体事件</li>
<li>编写硬件处理函数，如使用中断监听按键的动作</li>
<li>将需要处理的事件提交到InputCore</li>
<li>将该设备注册到子系统中<h2 id="2-1-输入子系统支持的事件类型"><a href="#2-1-输入子系统支持的事件类型" class="headerlink" title="2.1 输入子系统支持的事件类型"></a>2.1 输入子系统支持的事件类型</h2><table>
<thead>
<tr>
<th align="center">事件码</th>
<th align="center">数字值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">EV_SYN</td>
<td align="center">0x00</td>
<td align="center">同步事件</td>
</tr>
<tr>
<td align="center">EV_KEY</td>
<td align="center">0x01</td>
<td align="center">按键事件</td>
</tr>
<tr>
<td align="center">EV_REL</td>
<td align="center">0x02</td>
<td align="center">相对坐标</td>
</tr>
<tr>
<td align="center">EV_ABS</td>
<td align="center">0x03</td>
<td align="center">绝对坐标</td>
</tr>
<tr>
<td align="center">EV_MSC</td>
<td align="center">０x04</td>
<td align="center">其他</td>
</tr>
<tr>
<td align="center">EV_SW</td>
<td align="center">0x05</td>
<td align="center">开关</td>
</tr>
<tr>
<td align="center">EV_LED</td>
<td align="center">0x11</td>
<td align="center">按键　设备灯</td>
</tr>
<tr>
<td align="center">EV_SND</td>
<td align="center">０x12</td>
<td align="center">声音</td>
</tr>
<tr>
<td align="center">EV_REP</td>
<td align="center">0x14</td>
<td align="center">重复</td>
</tr>
<tr>
<td align="center">EV_FF</td>
<td align="center">0x15</td>
<td align="center">力反馈</td>
</tr>
<tr>
<td align="center">EV_PWR</td>
<td align="center">0x16</td>
<td align="center">电源</td>
</tr>
<tr>
<td align="center">EV_FF_STATUS</td>
<td align="center">0x17</td>
<td align="center">力反馈状态</td>
</tr>
<tr>
<td align="center">我们所实现的每个设备驱动都可以选择一个或多个进行上报给InputCore</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"># 3.简单示例</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">include</span> &lt;linux/input.h&gt;</span><br><span class="line"> #<span class="keyword">include</span> &lt;linux/<span class="keyword">module</span>.h&gt;</span><br><span class="line"> #<span class="keyword">include</span> &lt;linux/init.h&gt;</span><br><span class="line"></span><br><span class="line"> #<span class="keyword">include</span> &lt;asm/irq.h&gt;</span><br><span class="line"> #<span class="keyword">include</span> &lt;asm/io.h&gt;</span><br><span class="line"></span><br><span class="line"> static <span class="keyword">struct</span> input_dev *button_dev;</span><br><span class="line"></span><br><span class="line"> static void button<span class="constructor">_interrupt(<span class="params">int</span> <span class="params">irq</span>, <span class="params">void</span><span class="operator">*</span><span class="params">dummy</span>, <span class="params">struct</span> <span class="params">pt_regs</span> <span class="operator">*</span><span class="params">fp</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">        <span class="comment">//上报事件</span></span><br><span class="line">        input<span class="constructor">_report_key(<span class="params">button_dev</span>, BTN_1, <span class="params">inb</span>(BUTTON_PORT)</span> &amp; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//在上报后sync通知Core有事件要处理</span></span><br><span class="line">        input<span class="constructor">_sync(<span class="params">button_dev</span>)</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> static <span class="built_in">int</span> __init button<span class="constructor">_init(<span class="params">void</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">        <span class="built_in">int</span> error;</span><br><span class="line">        <span class="comment">//请求中断，并且在中断服务函数中进行事件上报</span></span><br><span class="line">        <span class="keyword">if</span> (request<span class="constructor">_irq(BUTTON_IRQ, <span class="params">button_interrupt</span>, 0, <span class="string">"button"</span>,NULL)</span>) &#123;</span><br><span class="line">                 printk(KERN_ERR<span class="string">"button.c: Can't allocate irq %d\n"</span>, button_irq);</span><br><span class="line">                 return -EBUSY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1.分配结构体</span></span><br><span class="line">        button_dev = input<span class="constructor">_allocate_device()</span>;</span><br><span class="line">        <span class="keyword">if</span> (!button_dev) &#123;</span><br><span class="line">                 printk(KERN_ERR<span class="string">"button.c: Not enough memory\n"</span>);</span><br><span class="line">                 error = -ENOMEM;</span><br><span class="line">                 goto err_free_irq;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//支持事件类型 按键</span></span><br><span class="line">        button_dev-&gt;evbit<span class="literal">[<span class="number">0</span>]</span> = <span class="constructor">BIT(EV_KEY)</span>;</span><br><span class="line">        <span class="comment">//支持按键 BTN_0</span></span><br><span class="line">        button_dev-&gt;keybit<span class="literal">[LONG(BTN<span class="identifier">_0</span>)]</span> = <span class="constructor">BIT(BTN_0)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向InputCore注册该设备驱动</span></span><br><span class="line">        error = input<span class="constructor">_register_device(<span class="params">button_dev</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                 printk(KERN_ERR<span class="string">"button.c: Failed to register device\n"</span>);</span><br><span class="line">                 goto err_free_dev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err_free_dev:</span><br><span class="line">        input<span class="constructor">_free_device(<span class="params">button_dev</span>)</span>;</span><br><span class="line"> err_free_irq:</span><br><span class="line">        free<span class="constructor">_irq(BUTTON_IRQ, <span class="params">button_interrupt</span>)</span>;</span><br><span class="line">        return error;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> static void __exit button<span class="constructor">_exit(<span class="params">void</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">       input<span class="constructor">_unregister_device(<span class="params">button_dev</span>)</span>;</span><br><span class="line">        free<span class="constructor">_irq(BUTTON_IRQ, <span class="params">button_interrupt</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span><span class="constructor">_init(<span class="params">button_init</span>)</span>;</span><br><span class="line"><span class="keyword">module</span><span class="constructor">_exit(<span class="params">button_exit</span>)</span>;</span><br></pre></td></tr></table></figure></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">由上面的源码可知，相对于自己完全实现字符设备类型驱动而言，我们所进行的编码量已经大为减少。而且层次更为清楚。</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
</li>
</ul>
<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>ARM&amp;Linux</category>
        <category>Linux驱动</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>我的见解</tag>
      </tags>
  </entry>
  <entry>
    <title>MMU理解要点</title>
    <url>/2017/02/27/ARM&amp;Linux/Linux%E9%A9%B1%E5%8A%A8/MMU%E7%90%86%E8%A7%A3%E8%A6%81%E7%82%B9/</url>
    <content><![CDATA[<p>&emsp;&emsp;MMU是我们必须要掌握的一个要点。<br><img src="https://img.blog.csdn.net/20171227124347593?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzk4OTI4NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="MMU"></p>
<a id="more"></a>
<h1 id="1-VA转MVA"><a href="#1-VA转MVA" class="headerlink" title="1.VA转MVA"></a>1.VA转MVA</h1><p>下面这个转换是使用硬件自动完成的<br>if(VA &lt; 32M) then<br>    MVA = VA | (PID &lt;&lt; 25);<br>else<br>    MVA = VA;</p>
<ul>
<li>利用PID将VA转换成不同VA,那么多个进程的MVA就能存在于同一个页表中，那么在进行进程转换时，只需要取不同的页表就可以了(在实际使用中，进程也确实是小于32M的居多)。而如果是大进程，那么可能需要重新构建页表，那么就需要重新构建页表，那么进程切换的开销会很大。</li>
</ul>
<h1 id="2-页表转换"><a href="#2-页表转换" class="headerlink" title="2.页表转换"></a>2.页表转换</h1><ul>
<li><p>页表基址(TTB)存在于CP15的C2, <code>TTB[31:14]:(MVA[31:20]&gt;&gt;18):00</code>构成页表基址。</p>
</li>
<li><p>一级描述符：每一个页表项可以可以是<code>段页描述符</code>、<code>粗页描述符</code>、<code>细页描述符</code></p>
<ul>
<li>段页描述符，直接指向1MB的内存空间</li>
<li>粗页描述符，有256个二级页表项，每个二级页表项指向4KB的内存空间</li>
<li>细叶描述符，有1024个二级页表项，每个二级页表项指向1KB的内存空间</li>
</ul>
</li>
<li><p>二级描述符：<code>粗页描述符</code>、<code>细页描述符</code>可以指向二级描述符，其中包括<code>大页描述符</code>、<code>小页描述符</code>、<code>极小页描述符</code>：</p>
<ul>
<li>大页描述符：0b01为大页描述符，[31:16]为大页基址。[15:0]可以表示。但是粗页表中的页表项每项只能表示4KB,所以连续16个条目表示的都是同一个大页描述符。同理，对于细页表中，连续64个条目表示的都是同一个大页描述符。</li>
<li>小页描述符：0x10为小页描述符。[31:12]表示的为小页基址。[11:0]可以表示4KB大小。所以如果放在粗页表中，那么正好一一对应。如果放在细页表中，那么细页表中，连续四个条目表示同一个小页描述符</li>
<li>极小页描述符：0x11表示为极小页描述符，[31:10]为极小页基址。[9:0]可以表示1KB空间。极小页描述符只能放在细页表中，一个条目对应一个极小页描述符。<h1 id="3-转换实例"><a href="#3-转换实例" class="headerlink" title="3.转换实例"></a>3.转换实例</h1></li>
</ul>
<ul>
<li>一级转换 段转换：<ul>
<li><code>页表基址寄存器[31:14]:MVA[31:20]</code>组成低两位为零的32位地址，MMU利用这个地址找到段描述符。</li>
<li><code>段描述法的[31:20]:MVA[19:20]</code>即为PA</li>
</ul>
</li>
<li>二级转换 小页描述符保存在粗页表中：<ul>
<li><code>页表基址寄存器[31:14]:MVA[31:20]</code>组成低两位为零的32位地址，MMU利用这个地址找到段描述符。</li>
<li><code>粗页表描述符的[31:10]:MVA[19:12]</code>,组成低两位为零的32位地址，可以找到小页描述符。</li>
<li>‘小页描述符[31；12]:MVA[11:0]’组成PA。<h1 id="4-转换总结"><a href="#4-转换总结" class="headerlink" title="4.转换总结"></a>4.转换总结</h1></li>
</ul>
</li>
<li>一级转换负责转换到1M大小，之后要么使用段转换转换到物理地址。要么使用粗页表或细页表进行二级转换</li>
<li>大页[31:16] 小页[31:12] 极小页[31:10]</li>
</ul>
<h1 id="5-权限控制"><a href="#5-权限控制" class="headerlink" title="5.权限控制"></a>5.权限控制</h1><ul>
<li>内存的访问权限检查可以概括为以下两点：</li>
</ul>
<ul>
<li>“域”决定是否对某块内存进行权限检查。</li>
<li>“AP”决定如何对某块内存进行权限检查。<h1 id="6-TLB的作用"><a href="#6-TLB的作用" class="headerlink" title="6. TLB的作用"></a>6. TLB的作用</h1>&emsp;&emsp;从虚拟地址到物理地址的转换过程可知：使用一级页表进行地址转换时，每次读/写数据需要访问两次内存，第一次访问一级页表获得物理地址，第二次才是真正的读写数据；使用两级页表时需要3次访存。利用程序执行时的局部性特性，通过使用一个高速、容量相对较小的存储器来存储近期用到的页表条目，这样可以大幅提高系统性能，这个存储器用来帮助快速地进行地址转换，称为”转译查找缓存”（TLB-Translation Lookaside Table）。</li>
</ul>
</li>
</ul>
<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>ARM&amp;Linux</category>
        <category>Linux驱动</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>MMU</tag>
      </tags>
  </entry>
  <entry>
    <title>Nand Flash使用要点</title>
    <url>/2017/03/01/ARM&amp;Linux/Linux%E9%A9%B1%E5%8A%A8/Nand-Flash%E4%BD%BF%E7%94%A8%E8%A6%81%E7%82%B9/</url>
    <content><![CDATA[<p>以<code>K9F1208U0M</code>介绍NandFlash的基础要点。</p>
<a id="more"></a>

<h1 id="1-主要引脚"><a href="#1-主要引脚" class="headerlink" title="1.主要引脚"></a>1.主要引脚</h1><ul>
<li>I/O[0:7] : 数据输入输出</li>
<li>CLE : 命令锁存使能</li>
<li>ALE : 地址锁存使能</li>
<li>nCE ：芯片使能</li>
<li>nRE : 读使能</li>
<li>nWE : 写使能</li>
<li>nWP : 写保护</li>
<li>R/nB : 就绪/忙信号</li>
<li>Vcc : 电源</li>
<li>Vss : 地</li>
</ul>
<h1 id="2-物理架构"><a href="#2-物理架构" class="headerlink" title="2.物理架构"></a>2.物理架构</h1><ul>
<li>页 : 512 + 16 字节(EDC/ECC校验使用)</li>
<li>块 ：528 * 32 页</li>
<li>器件： 4096 块</li>
<li>总大小： 4096 * 32 * 512 = 65536KB = 64MB</li>
</ul>
<h1 id="3-使用方式"><a href="#3-使用方式" class="headerlink" title="3.使用方式"></a>3.使用方式</h1><p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>ARM&amp;Linux</category>
        <category>Linux驱动</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>NandFlash</tag>
      </tags>
  </entry>
  <entry>
    <title>Sysfs之我见</title>
    <url>/2017/07/04/ARM&amp;Linux/Linux%E9%A9%B1%E5%8A%A8/Sysfs%E4%B9%8B%E6%88%91%E8%A7%81/</url>
    <content><![CDATA[<p>sysfs虚拟文件系统提供了一种比proc更理想的访问内核数据的途径。</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">_______           _______  _______  _______</span><br><span class="line">(  <span class="name">____</span> \|\     /|(  <span class="name">____</span> \(  <span class="name">____</span> \(  <span class="name">____</span> \</span><br><span class="line">| (    \/( \   / )| (    \/| (    \/| (    \/</span><br><span class="line">| (_____  \ (_) / | (<span class="name">_____</span> | (__    | (<span class="name">_____</span></span><br><span class="line">(<span class="name">_____</span>  )  \   /  (<span class="name">_____</span>  )|  __)   (<span class="name">_____</span>  )</span><br><span class="line">     ) |   ) (         ) || (            ) |</span><br><span class="line">/\____) |   | |   /\____) || )      /\____) |</span><br><span class="line">\_______)   \_/   \_______)|/       \_______)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="1-sysfs的目录结构"><a href="#1-sysfs的目录结构" class="headerlink" title="1.sysfs的目录结构"></a>1.sysfs的目录结构</h1><p>sysfs总是挂载在/sys文件夹上。<br>在/sys目录下一般有block、bus、class、dev、devices、firmware、fs、kernel、module、power等目录。</p>
<ul>
<li>/sys/devices: 这是内核对系统中所有设备的分层次表达模型，也是 /sys 文件系统管理设备的最重要的目录结构。</li>
<li>/sys/dev: 这个目录下维护一个按字符设备和块设备的主次号码(major:minor)链接到真实的设备(/sys/devices下)的符号链接文件。</li>
<li>/sys/bus: 这是内核设备按总线类型分层放置的目录结构， devices 中的所有设备都是连接于某种总线之下，在这里的每一种具体总线之下可以找到每一个具体设备的符号链接，它也是构成 Linux 统一设备模型的一部分。</li>
<li>/sys/class:这是按照设备功能分类的设备模型，如系统所有输入设备都会出现在 /sys/class/input 之下，而不论它们是以何种总线连接到系统。</li>
<li>/sys/block: 这里是系统中当前所有的块设备,具体链接到devices下的具体设备。</li>
<li>/sys/firmware:这里是系统加载固件机制的对用户空间的接口,如设备树的各个分层都位于这个文件夹下。</li>
<li>/sys/fs:这里按照设计是用于描述系统中所有文件系统，包括文件系统本身和按文件系统分类存放的已挂载点。如当前的Linux系统中存在ext4文件系统，该目录下就会存在ext4目录。</li>
<li>/sys/kernel:这里是内核所有可调整参数的位置，目前只有 uevent_helper, kexec_loaded, mm, 和新式的 slab 分配器等几项较新的设计在使用它，其它内核可调整参数仍然位于 sysctl (/proc/sys/kernel) 接口中。</li>
<li>/sys/module: 这里有系统中所有模块的信息，不论这些模块是以内联(inlined)方式编译到内核映像文件(vmlinuz)中还是编译为外部模块(ko文件)，都可能会出现在 /sys/module 中。</li>
<li>/sys/power: 这里是系统中电源选项，这个目录下有几个属性文件可以用于控制整个机器的电源状态，如可以向其中写入控制命令让机器关机、重启等。</li>
</ul>
<h1 id="2-udev使用"><a href="#2-udev使用" class="headerlink" title="2.udev使用"></a>2.udev使用</h1><h2 id="2-1-udev工作过程"><a href="#2-1-udev工作过程" class="headerlink" title="2.1 udev工作过程:"></a>2.1 udev工作过程:</h2><p>&emsp;&emsp;当内核检测到在系统中出现了新设备后（产生hotplug事件），内核会在sysfs文件系统中为该新设备生成一项新的记录，一般sysfs文件系统会被mount到/sys目录中。新记录是以一个或多个文件或目录的方式来表示。每个文件都包含有特定的信息。udev在系统中是以守护进程的方式udevd在运行。检测到新设备的出现，通过查找设备对应的sysfs中的记录得到设备的一些信息。udev会根据/etc/udev/udev.conf文件中的udev_rules指定的目录，逐个检查该目录下的文件，这个目录下的文件都是针对某类或某个设备应该施行什么措施的规则文件。udev读取文件是按照文件名的ASCII字母顺序来读取的，如果udev一旦找到了与新加入的设备匹配的规则，udev就会根据规则定义的措施对新设备进行配置。同时不再读后续的规则文件。</p>
<h2 id="2-2-udev规则"><a href="#2-2-udev规则" class="headerlink" title="2.2 udev规则"></a>2.2 udev规则</h2><h3 id="2-2-1-规则的所有操作符"><a href="#2-2-1-规则的所有操作符" class="headerlink" title="2.2.1 规则的所有操作符"></a>2.2.1 规则的所有操作符</h3><ul>
<li>“==”：　　比较键、值，若等于，则该条件满足；</li>
<li>“!=”： 　　比较键、值，若不等于，则该条件满足；</li>
<li>“=”： 　　 对一个键赋值；</li>
<li>“+=”：　　为一个表示多个条目的键赋值。</li>
<li>“:=”：　　对一个键赋值，并拒绝之后所有对该键的改动。目的是防止后面的规则文件对该键赋值。</li>
</ul>
<h3 id="2-2-2-规则的匹配键"><a href="#2-2-2-规则的匹配键" class="headerlink" title="2.2.2 规则的匹配键"></a>2.2.2 规则的匹配键</h3><ul>
<li>ACTION： 　　 　　　　　　事件 (uevent) 的行为，例如：add( 添加设备 )、remove( 删除设备 )。</li>
<li>DEVPATH：　　　　　　　   设备的 devpath 路径。</li>
<li>SUBSYSTEM： 　　　　　　 设备的子系统名称，例如：sda 的子系统为 block。</li>
<li>BUS： 　　　　　　　　　　 设备在 devpath 里的总线名称，例如：usb。</li>
<li>DRIVER： 　　　　 　　　　 设备在 devpath 里的设备驱动名称，例如：ide-cdrom。</li>
<li>ID： 　　　　　　　 　　　　设备在 devpath 里的识别号。</li>
<li>SYSFS{filename}： 　　　　设备的 devpath 路径下，设备的属性文件“filename”里的内容。例如：SYSFS{model}==“ST936701SS”表示：如果设备的型号为 ST936701SS，则该设备匹配该 匹配键。在一条规则中，可以设定最多五条 SYSFS 的 匹配键。</li>
<li>ENV{key}： 　　　　　　 　 环境变量。在一条规则中，可以设定最多五条环境变量的 匹配键。</li>
<li>PROGRAM：　　　　　　　　调用外部命令。</li>
<li>RESULT： 　　　　　　　　  外部命令 PROGRAM 的返回结果。</li>
</ul>
<h3 id="2-2-3-重要赋值键"><a href="#2-2-3-重要赋值键" class="headerlink" title="2.2.3 重要赋值键"></a>2.2.3 重要赋值键</h3><ul>
<li>NAME：　　　　　　　　　　　在 /dev下产生的设备文件名。只有第一次对某个设备的 NAME 的赋值行为生效，之后匹配的规则再对该设备的 NAME 赋值行为将被忽略。如果没有任何规则对设备的 NAME 赋值，udev 将使用内核设备名称来产生设备文件。</li>
<li>SYMLINK：　　　　　　　　　 为 /dev/下的设备文件产生符号链接。由于 udev 只能为某个设备产生一个设备文件，所以为了不覆盖系统默认的 udev 规则所产生的文件，推荐使用符号链接。</li>
<li>OWNER, GROUP, MODE：　　为设备设定权限。</li>
<li>ENV{key}：　　　　　　　　　导入一个环境变量。</li>
</ul>
<h3 id="2-2-4-值和可调用的替换操作符"><a href="#2-2-4-值和可调用的替换操作符" class="headerlink" title="2.2.4 值和可调用的替换操作符"></a>2.2.4 值和可调用的替换操作符</h3><ul>
<li>$kernel, %k：　　　　　　　　设备的内核设备名称，例如：sda、cdrom。</li>
<li>$number, %n：　　　　　　　  设备的内核号码，例如：sda3 的内核号码是 3。</li>
<li>$devpath, %p：　　　　　　　 设备的 devpath路径。</li>
<li>$id, %b：　　　　　　　　　　 设备在 devpath里的 ID 号。</li>
<li>$sysfs{file}, %s{file}：　 设备的 sysfs里 file 的内容。其实就是设备的属性值。</li>
<li>$env{key}, %E{key}：　 　　一个环境变量的值。</li>
<li>$major, %M：　　　　　　　　 设备的 major 号。</li>
<li>$minor %m：　　　　　　　　  设备的 minor 号。</li>
<li>$result, %c：　　　　　　　　PROGRAM 返回的结果。</li>
<li>$parent, %P：　　　　　　   父设备的设备文件名。</li>
<li>$root, %r：　　　　　　　　 udev_root的值，默认是 /dev/。</li>
<li>$tempnode, %N：　　　　　　 临时设备名。</li>
<li>%%：　　　　　　　　　　　　  符号 % 本身。</li>
<li>$$：　　　　　　　　　　　　　符号 $ 本身。</li>
</ul>
<h2 id="2-3-udev使用"><a href="#2-3-udev使用" class="headerlink" title="2.3 udev使用"></a>2.3 udev使用</h2><p>假设一个USB扫描仪每次插入Linux设备名称都会变，那么就可以使用：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">SYSFS&#123;idVendor&#125;==<span class="string">"0686"</span>, \</span><br><span class="line">SYSFS&#123;idProduct&#125;==<span class="string">"400e"</span>, \</span><br><span class="line">SYMLINK+=<span class="string">"scanner"</span>, MODE=<span class="string">"0664"</span>, \</span><br><span class="line"><span class="keyword">group</span>=<span class="string">"scanner"</span></span><br></pre></td></tr></table></figure>
<p>前两行，确定了扫描仪的生产商和产品号，那么在每次重新插入的时候，都会创建一个/dev/scanner的符号连接，访问权限设置为0664。</p>
<p>修改U盘名称：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">KERNEL</span>==<span class="string">"sdc4"</span>,SUBSYSTEMS==<span class="string">"block"</span>, NAME+=<span class="string">"kinstonusb"</span>,SYMLINK+=<span class="string">"kinstonusb_link"</span></span><br></pre></td></tr></table></figure>
<p>比如你的sdc的优盘为金士顿的，但系统会识别成sdc4不易于识别，那么就可以对sdc建立一个<code>kinstonusb_link</code>链接。</p>
<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>ARM&amp;Linux</category>
        <category>Linux驱动</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>SysFs</tag>
      </tags>
  </entry>
  <entry>
    <title>list_head之必知必会</title>
    <url>/2017/06/13/ARM&amp;Linux/Linux%E9%A9%B1%E5%8A%A8/list-head%E4%B9%8B%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
    <content><![CDATA[<p>本章介绍list_head的相关知识。</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line"> _       _________ _______ _________            _______  _______  ______</span><br><span class="line">( \      \__   __/(  ____ \\__   __/  |<span class="string">\     /</span>|<span class="string">(  ____ \(  ___  )(  __  \</span></span><br><span class="line">|<span class="string"> (         ) (   </span>|<span class="string"> (    \/   ) (     </span>|<span class="string"> )   ( </span>||<span class="string"> (    \/</span>|<span class="string"> (   ) </span>||<span class="string"> (  \  )</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">         </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> (_____    </span>|<span class="string"> </span>|<span class="string">     </span>|<span class="string"> (___) </span>||<span class="string"> (__    </span>|<span class="string"> (___) </span>||<span class="string"> </span>|<span class="string">   ) </span>|</span><br><span class="line">|<span class="string"> </span>|<span class="string">         </span>|<span class="string"> </span>|<span class="string">   (_____  )   </span>|<span class="string"> </span>|<span class="string">     </span>|<span class="string">  ___  </span>||<span class="string">  __)   </span>|<span class="string">  ___  </span>||<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>|</span><br><span class="line">|<span class="string"> </span>|<span class="string">         </span>|<span class="string"> </span>|<span class="string">         ) </span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string">     </span>|<span class="string"> (   ) </span>||<span class="string"> (      </span>|<span class="string"> (   ) </span>||<span class="string"> </span>|<span class="string">   ) </span>|</span><br><span class="line">|<span class="string"> (____/\___) (___/\____) </span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string">     </span>|<span class="string"> )   ( </span>||<span class="string"> (____/\</span>|<span class="string"> )   ( </span>||<span class="string"> (__/  )</span></span><br><span class="line"><span class="string">(_______/\_______/\_______)   )_(     </span>|<span class="string">/     \</span>|<span class="string">(_______/</span>|<span class="string">/     \</span>|<span class="string">(______/</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="1-list-entry的作用"><a href="#1-list-entry的作用" class="headerlink" title="1.list_entry的作用"></a>1.list_entry的作用</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>没有数据区怎么使用，更多的时候是嵌入到其他结构体中使用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_node</span>&#123;</span></span><br><span class="line">　　<span class="keyword">char</span> c;</span><br><span class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当我们知道 list_head的地址时，就可以通过宏 list_entry获取父结构的地址：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define list_entry(ptr,type,member)\</span></span><br><span class="line">　　container_of(ptr,type,member)</span><br><span class="line"></span><br><span class="line"><span class="comment">#define container_of(ptr,type,member) ( &#123;\</span></span><br><span class="line">　　<span class="keyword">const</span> <span class="keyword">typeof</span><span class="function"><span class="params">( ((type*)<span class="number">0</span>)-&gt;member )</span> *<span class="title">__mptr</span>=<span class="params">(ptr)</span>;\</span></span><br><span class="line"><span class="function">　　<span class="params">(type*)( (char*)__mptr - offsetof(type,member) )</span>;&#125; )</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">offsetof</span><span class="params">(TYPE,MEMBER)</span> <span class="params">((size_t)&amp;((TYPE *)<span class="number">0</span>)-&gt;MEMBER)</span></span></span><br></pre></td></tr></table></figure>
<p>首先解释<code>offsetof</code>:</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">将实参代入 offset( struct file_node, <span class="keyword">node</span> <span class="title">)</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">( (size_t</span>) &amp; ((struct file_node*)<span class="number">0</span>）-&gt; <span class="keyword">node</span> <span class="title">)</span></span><br></pre></td></tr></table></figure>
<p>这句的意思是将结构体file_node的指针转变为0，那么node的指针就是相对于0d地址的指针，即node在file_node中的偏移。</p>
<p>然后解释 <code>container_of</code> :<br>该句有两句组成：<br>首先第一句可以缩减为：<code>_mtr = (ptr)</code>即保存 ptr的指针。</p>
<p>第二句： _mptr - 该member相对于结构体的偏移，那么得到的不就是父结构体的指针了么。</p>
<p>所以 <code>list_entry</code>的作用就是<strong>得到父结构的起始地址</strong>。</p>
<h1 id="2-LIST-HEAD"><a href="#2-LIST-HEAD" class="headerlink" title="2.LIST_HEAD()"></a>2.LIST_HEAD()</h1><p>LIST_HEAD就是定义一个前向和后向都指向自己的list_head</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#define <span class="constructor">LIST_HEAD(<span class="params">name</span>)</span> \</span><br><span class="line"><span class="keyword">struct</span> list_head name = <span class="constructor">LIST_HEAD_INIT(<span class="params">name</span>)</span></span><br><span class="line"></span><br><span class="line">#define <span class="constructor">LIST_HEAD_INIT(<span class="params">name</span>)</span> &#123; &amp;(name), &amp;(name) &#125;</span><br></pre></td></tr></table></figure>
<p>INIT_LIST_HEAD就是指向初始化一个list_head指向实际的结构体</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">INIT_LIST_HEAD</span><span class="params">(struct list_head *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　<span class="built_in">list</span>-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">　　<span class="built_in">list</span>-&gt;prev = <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双向链表的插入操作 – list_add()</p>
<p>将new所代表的结构体插入head所管理的双向链表的头节点head之后: （即插入表头）</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static inline void <span class="built_in">list</span><span class="constructor">_add(<span class="params">struct</span> <span class="params">list_head</span> <span class="operator">*</span><span class="params">new</span>, <span class="params">struct</span> <span class="params">list_head</span> <span class="operator">*</span><span class="params">head</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">　　<span class="constructor">__list_add(<span class="params">new</span>, <span class="params">head</span>, <span class="params">head</span>-&gt;<span class="params">next</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">static inline void <span class="constructor">__list_add( <span class="params">struct</span> <span class="params">list_head</span> <span class="operator">*</span><span class="params">new</span>, <span class="params">struct</span> <span class="params">list_head</span> <span class="operator">*</span><span class="params">prev</span>, <span class="params">struct</span> <span class="params">list_head</span> <span class="operator">*</span><span class="params">next</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">　　next-&gt;prev = <span class="keyword">new</span>;   <span class="comment">//之前后边的前向指向新的</span></span><br><span class="line">　　<span class="keyword">new</span>-&gt;next = next;   <span class="comment">//新的后向指向之前的后边</span></span><br><span class="line">　　<span class="keyword">new</span>-&gt;prev = prev;   <span class="comment">//新的前向指向之前的前向</span></span><br><span class="line">　　prev-&gt;next = <span class="keyword">new</span>;   <span class="comment">//之前的前边的后向指向新的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从list中删除结点——list_del()</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static inline void <span class="built_in">list</span><span class="constructor">_del(<span class="params">struct</span> <span class="params">list_head</span> <span class="operator">*</span><span class="params">entry</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">　　<span class="constructor">__list_del(<span class="params">entry</span>-&gt;<span class="params">prev</span>, <span class="params">entry</span>-&gt;<span class="params">next</span>)</span>;</span><br><span class="line">　　entry-&gt;next = LIST_POISON1;</span><br><span class="line">　　entry-&gt;prev = LIST_POISON2;</span><br><span class="line">&#125;</span><br><span class="line">static inline void <span class="constructor">__list_del(<span class="params">struct</span> <span class="params">list_head</span> <span class="operator">*</span> <span class="params">prev</span>, <span class="params">struct</span> <span class="params">list_head</span> <span class="operator">*</span> <span class="params">next</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">　　next-&gt;prev = prev;</span><br><span class="line">　　prev-&gt;next = next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断链表是否为空（如果双向链表head为空则返回真，否则为假）——list_empty()</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static inline <span class="built_in">int</span> <span class="built_in">list</span><span class="constructor">_empty(<span class="params">const</span> <span class="params">struct</span> <span class="params">list_head</span> <span class="operator">*</span><span class="params">head</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">　　return head-&gt;next<span class="operator"> == </span>head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-list-for-each-entry"><a href="#3-list-for-each-entry" class="headerlink" title="3.list_for_each_entry"></a>3.list_for_each_entry</h1><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * list_for_each_entry  -   iterate over list of given type</span></span><br><span class="line"><span class="comment">     * @pos:    the type * to use as a loop cursor.</span></span><br><span class="line"><span class="comment">     * @head:   the head for your list.</span></span><br><span class="line"><span class="comment">     * @member: the name of the list_struct within the struct.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">#define <span class="built_in">list</span><span class="constructor">_for_each_entry(<span class="params">pos</span>, <span class="params">head</span>, <span class="params">member</span>)</span>  \</span><br><span class="line">    for (pos = <span class="built_in">list</span><span class="constructor">_entry((<span class="params">head</span>)</span>-&gt;next, typeof(*pos), member);  \</span><br><span class="line">        prefetch(pos-&gt;member.next), &amp;pos-&gt;member != (head);     \</span><br><span class="line">        pos = <span class="built_in">list</span><span class="constructor">_entry(<span class="params">pos</span>-&gt;<span class="params">member</span>.<span class="params">next</span>, <span class="params">typeof</span>(<span class="operator">*</span><span class="params">pos</span>)</span>, member))</span><br></pre></td></tr></table></figure>


<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>ARM&amp;Linux</category>
        <category>Linux驱动</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>list_head</tag>
      </tags>
  </entry>
  <entry>
    <title>uboot 配置分析</title>
    <url>/2017/04/27/ARM&amp;Linux/Linux%E9%A9%B1%E5%8A%A8/uboot%E5%B7%A5%E7%A8%8B%E9%85%8D%E7%BD%AE%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>简要介绍uboot的配置工程和文件作用。</p>
<a id="more"></a>
<h1 id="1-uboot文件夹配置"><a href="#1-uboot文件夹配置" class="headerlink" title="1.uboot文件夹配置"></a>1.uboot文件夹配置</h1><p>uboot源码的目录结构如下：</p>
<ul>
<li>api : 硬件无关的功能函数的API。uboot移植时基本不用管，这些函数是uboot本身使用的。</li>
<li>arch: 与体系结构相关的代码</li>
<li>board : 对应不同配置的开发板oard文件夹下每一个文件都代表一个开发板，这个文件夹下面放的文件就是用来描述这一个开发板的信息的。board目录下有多少个文件夹，就表示当前这个uboot已经被移植到多少个开发板上了（当前的uboot支持多少个开发板）。</li>
<li>common : 通用代码，涵盖各个方面，以命令行处理为主</li>
<li>disk : 磁盘分区相关代码</li>
<li>doc : 常见功能和问题的说明文档，一堆README开头的文件</li>
<li>drivers : 常用的设备驱动程序，每个类型的设备驱动占用一个子目录</li>
<li>examples : 示例程序</li>
<li>fs : 文件系统，支持嵌入式开发常见的fs(cramfs,ext2,ext3,jffs2,etc)</li>
<li>include : 全局需要的头文件定义在这儿</li>
<li>lib : 通用库文件</li>
<li>net : 网络相关的代码，小型的协议栈。</li>
<li>tools : 辅助程序， 用于编译和检查uboot目标文件</li>
</ul>
<h1 id="2-配置架构"><a href="#2-配置架构" class="headerlink" title="2.配置架构"></a>2.配置架构</h1><h2 id="2-1-配置树"><a href="#2-1-配置树" class="headerlink" title="2.1 配置树"></a>2.1 配置树</h2><p>整个uboot工程是由以下几个配置文件进行配置的</p>
<ul>
<li>.config</li>
<li>Makefile</li>
<li>include<ul>
<li>auto.conf</li>
<li>autoconf.h</li>
</ul>
</li>
<li>Kconfig</li>
</ul>
<h2 id="2-2-配置联系"><a href="#2-2-配置联系" class="headerlink" title="2.2 配置联系"></a>2.2 配置联系</h2><ul>
<li>顶层的Makefile是顶层入口。</li>
<li>在调用<code>make menuconfig</code>的时候，会使用到各个子目录的Kconfig进行显示，最后将结果汇总到 .config – XXX_CONFIG = y 或者 XXX_CONFIG = m</li>
<li>auto.conf，其内容来自 .config 用于子目录的Makefile编译，其形式为 obj-$(XXX_CONFIG) += xxx.o,当 XXX_CONFIG = y时就会编译近启动文件，m则为驱动方式，uboot没有驱动，所以全部都是在二进制文件中。</li>
<li>aotoconf.h其内容也来自.config ，由源码进行调用，其中的定义则都是 XXX_CONFIG = 1</li>
</ul>
<h1 id="3-Kconfig内容解析"><a href="#3-Kconfig内容解析" class="headerlink" title="3.Kconfig内容解析"></a>3.Kconfig内容解析</h1><p>以常见的DM9000网卡驱动的Kconfig为例：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"># Network device <span class="keyword">configuration</span></span><br><span class="line">menuconfig NETDEVICES</span><br><span class="line">        <span class="keyword">default</span> y <span class="keyword">if</span> UML</span><br><span class="line">        depends <span class="keyword">on</span> NET</span><br><span class="line">        bool <span class="string">"Network device support"</span></span><br><span class="line">        <span class="comment">---help---</span></span><br><span class="line">          You can say N here <span class="keyword">if</span> you don<span class="symbol">'t</span> intend <span class="keyword">to</span> connect your Linux box <span class="keyword">to</span> any other computer at <span class="keyword">all</span>.</span><br><span class="line">……</span><br><span class="line">config DM9000</span><br><span class="line">        tristate <span class="string">"DM9000 support"</span></span><br><span class="line">        depends <span class="keyword">on</span> ARM || BLACKFIN || MIPS</span><br><span class="line">        <span class="keyword">select</span> CRC32</span><br><span class="line">        <span class="keyword">select</span> MII</span><br><span class="line">        <span class="comment">---help---</span></span><br><span class="line">          Support <span class="keyword">for</span> DM9000 chipset.</span><br><span class="line"></span><br><span class="line">          <span class="keyword">To</span> compile this driver as a module, choose M here.  The module will be called dm9000.</span><br><span class="line">……</span><br><span class="line">source <span class="string">"drivers/net/arcnet/Kconfig"</span></span><br><span class="line">source <span class="string">"drivers/net/phy/Kconfig"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>menuconfig : 表示菜单，本身属于一个菜单中的项目，但是他又有子菜单项目。</li>
<li>config表示菜单中的一个配置项（本身并没有子菜单下的项目）。一个menuconfig后面跟着的所有config项就是这个menuconfig的子菜单。这就是Kconfig中表示的目录关系。</li>
<li>NETDEVICES : menuconfig或者config后面空格隔开的大写字母表示的类似于 NETDEVICES 的就是这个配置项的配置项名字，这个字符串前面添加CONFIG_后就构成了“.config”文件中的配置项名字。</li>
<li>source：内核源码目录树中每一个Kconfig都会用source引入其所有子目录下的Kconfig，从而保证了所有的Kconfig项目都被包含进menuconfig中。这个也说明了：如果你自己在linux内核中添加了一个文件夹，一定要在这个文件夹下创建一个Kconfig文件，然后在这个文件夹的上一层目录的Kconfig中source引入这个文件夹下的Kconfig文件。</li>
<li>tristate：意思是三态（3种状态，对应Y、N、M三种选择方式），意思就是这个配置项可以被三种选择。</li>
<li>bool：是要么真要么假（对应Y和N）。意思是这个配置项只能被2种选择。</li>
<li>depends：意思是本配置项依赖于另一个配置项。如果那个依赖的配置项为Y或者M，则本配置项才有意义；如果依赖的哪个配置项本身被设置为N，则本配置项根本没有意义。depends项会导致make menuconfig的时候找不到一些配置项。所以在menuconfig中如果找不到一个选项，但是这个选项在Kconfig中却是有的，则可能的原因就是这个配置项依赖的一个配置项是不成立的。depends依赖的配置项可以是多个，还可以有逻辑运算。这种时候只要依赖项目运算式子的结果为真则依赖就成立。</li>
<li>select：表示depends on的值有效时，下面的select也会成立，将相应的内容选上。</li>
<li>default：表示depends on的值有效时，下面的default也会成立，将相应的选项选上，有三种选项，分别对应y，n，m。</li>
<li>help：帮助信息，解释这个配置项的含义，以及如何去配置他。</li>
</ul>
<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>ARM&amp;Linux</category>
        <category>Linux驱动</category>
      </categories>
      <tags>
        <tag>uboot</tag>
        <tag>uboot配置</tag>
      </tags>
  </entry>
  <entry>
    <title>交叉编译之必知必会</title>
    <url>/2016/10/25/ARM&amp;Linux/Linux%E9%A9%B1%E5%8A%A8/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E4%B9%8B%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
    <content><![CDATA[<p>&emsp;&emsp;做嵌入式开发，最熟悉的莫过于交叉编译了。在这篇文章中，记录自己经常使用到的相关知识，以共查阅。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7774609-26be5dd9405e9eee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<a id="more"></a>
<h1 id="1-编译器"><a href="#1-编译器" class="headerlink" title="1. 编译器"></a>1. 编译器</h1><p>&emsp;&emsp;嵌入式开发和桌面应用的一个很大不同就是：我们必须自己准备配置所需的工具环境。并不像Windows开发那样装一个VS就一切OK了，这其中最重要的就是编译器的准备。</p>
<ul>
<li>在Ubuntu上我一般是使用<code>sudo apt-get install arm-linux-gnu</code>命令进行交叉编译工具的安装。但大多数时候这是行不通的。因为arm架构或者特定ARM芯片的特性（如是否支持浮点运算），导致后期使用时故障频出。</li>
<li>使用开发板提供商或芯片提供商提供的开发套件，这些往往对某些特性做了优化，是最能契合我们的芯片开发的一种方式。</li>
<li>去<a href="https://www.linaro.org/" target="_blank" rel="noopener">Linaro</a>下载对应架构的编译程序，这些开发环境适用性很好，在没能找到官方提供的套件的时候，这是一个很好的选择。</li>
</ul>
<p>&emsp;&emsp;<strong>当然，下载安装完成后需要将可执行文件的路径加到系统的 <code>PATH</code>路径中</strong></p>
<h1 id="2-交叉编译器选项"><a href="#2-交叉编译器选项" class="headerlink" title="2.交叉编译器选项"></a>2.交叉编译器选项</h1><h2 id="2-1-编译步骤"><a href="#2-1-编译步骤" class="headerlink" title="2.1 编译步骤"></a>2.1 编译步骤</h2><p>&emsp;&emsp;编译程序分为4个步骤：</p>
<ul>
<li><p>1.预处理，生成预编译文件（.文件）：</p>
<pre><code>Gcc –E hello.c –o hello.i</code></pre></li>
<li><p>2.编译，生成汇编代码（.s文件）：</p>
<pre><code>Gcc –S hello.i –o hello.s</code></pre></li>
<li><p>3.汇编，生成目标文件（.o文件）：</p>
<pre><code>Gcc –c hello.s –o hello.o</code></pre></li>
<li><p>4.链接，生成可执行文件：</p>
<pre><code>Gcc hello.o –o hello</code></pre></li>
<li><p><em>记住这三个选项只要记住键盘左上角的按键 <code>ESC</code>即可，是不是很简单*</em></p>
</li>
</ul>
<h2 id="2-2-警告选项"><a href="#2-2-警告选项" class="headerlink" title="2.2 警告选项"></a>2.2 警告选项</h2><p>&emsp;&emsp;在默认情况下，警告选项是默认不打开的，后来Dock在开发的实践过程中，返现使用<code>-Wall</code>选项可以事先发现很多简单错误，为后期免去很多麻烦：</p>
<ul>
<li>判断语句 <code>if(a = b)</code></li>
<li>缺少 <code>default</code>分支</li>
<li>类型不匹配对比<code>int a = 0; long b = 2; if(a == b)</code></li>
<li>其他Dock还未遇到的</li>
</ul>
<p>&emsp;&emsp;就是这三个简单的错误，曾经让Dock花费很多时间去调试。错误应该消灭在萌芽。</p>
<h2 id="2-3-包含链接选项"><a href="#2-3-包含链接选项" class="headerlink" title="2.3 包含链接选项"></a>2.3 包含链接选项</h2><p>&emsp;&emsp;Gcc编译器默认是会自动寻找包含编译环境中的头文件和链接库，但是在使用自己的头文件和链接库时，需要自己手动指定。</p>
<ul>
<li>-I[path-to-include_file] 使用 -I 指定头文件的路径</li>
<li>-L[path-to-lib] 使用-L 指定库文件的路径</li>
<li>-lxx.so 使用-l 选项指定要链接的库文件，默认 l代替lib文件，如链接libmath.so要使用 <code>-lmath</code></li>
<li>-nostartfiles 不链接启动文件，即暂时不链接<code>main</code>函数</li>
<li>-nostdlib 不链接标准库文件，在裸机程序中比较常用，如uboot中就会使用到这个选项，因为链接标准库的话，程序就会变得很大。</li>
<li>-static 静态链接，这样就不会使用动态库，但后边有时需要制定 libxx.a静态库文件，同时文件体积会变得很大</li>
</ul>
<h2 id="2-4-objcpy-objdump"><a href="#2-4-objcpy-objdump" class="headerlink" title="2.4 objcpy objdump"></a>2.4 objcpy objdump</h2><p>&emsp;&emsp;虽然说能够编译出程序并且能够运行就已经够了，但是这两个程序使我们做嵌入式程序所不能忽视的。</p>
<h3 id="2-4-1-ELF格式"><a href="#2-4-1-ELF格式" class="headerlink" title="2.4.1 ELF格式"></a>2.4.1 ELF格式</h3><p> ELF(Executable and Linking Format)是unix-like系统下的一种文件格式，它是一种对象文件的格式，用于定义不同类型的对象文件(Object files)中都放了什么东西、以及都以什么样的格式去放这些东西。即是在程序的头部加上了一段信息：<br> <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2's complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              EXEC (Executable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x42dfe0</span><br><span class="line">  <span class="keyword">Start</span> <span class="keyword">of</span> program headers:          <span class="number">64</span> (<span class="keyword">bytes</span> <span class="keyword">into</span> <span class="keyword">file</span>)</span><br><span class="line">  <span class="keyword">Start</span> <span class="keyword">of</span> <span class="keyword">section</span> headers:          <span class="number">67460488</span> (<span class="keyword">bytes</span> <span class="keyword">into</span> <span class="keyword">file</span>)</span><br><span class="line">  Flags:                             <span class="number">0x0</span></span><br><span class="line">  <span class="keyword">Size</span> <span class="keyword">of</span> this header:               <span class="number">64</span> (<span class="keyword">bytes</span>)</span><br><span class="line">  <span class="keyword">Size</span> <span class="keyword">of</span> program headers:           <span class="number">56</span> (<span class="keyword">bytes</span>)</span><br><span class="line">  <span class="built_in">Number</span> <span class="keyword">of</span> program headers:         <span class="number">8</span></span><br><span class="line">  <span class="keyword">Size</span> <span class="keyword">of</span> <span class="keyword">section</span> headers:           <span class="number">64</span> (<span class="keyword">bytes</span>)</span><br><span class="line">  <span class="built_in">Number</span> <span class="keyword">of</span> <span class="keyword">section</span> headers:         <span class="number">40</span></span><br><span class="line">  <span class="keyword">Section</span> header <span class="keyword">string</span> <span class="keyword">table</span> <span class="keyword">index</span>: <span class="number">37</span></span><br></pre></td></tr></table></figure><br>对应的结构体为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> e_ident[EI_NIDENT];     <span class="comment">/* 魔数和相关信息 */</span></span><br><span class="line">        Elf32_Half    e_type;                 <span class="comment">/* 目标文件类型 */</span></span><br><span class="line">        Elf32_Half    e_machine;              <span class="comment">/* 硬件体系 */</span></span><br><span class="line">        Elf32_Word    e_version;              <span class="comment">/* 目标文件版本 */</span></span><br><span class="line">        Elf32_Addr    e_entry;                <span class="comment">/* 程序进入点 */</span></span><br><span class="line">        Elf32_Off     e_phoff;                <span class="comment">/* 程序头部偏移量 */</span></span><br><span class="line">        Elf32_Off     e_shoff;                <span class="comment">/* 节头部偏移量 */</span></span><br><span class="line">        Elf32_Word    e_flags;                <span class="comment">/* 处理器特定标志 */</span></span><br><span class="line">        Elf32_Half    e_ehsize;               <span class="comment">/* ELF头部长度 */</span></span><br><span class="line">        Elf32_Half    e_phentsize;            <span class="comment">/* 程序头部中一个条目的长度 */</span></span><br><span class="line">        Elf32_Half    e_phnum;                <span class="comment">/* 程序头部条目个数  */</span></span><br><span class="line">        Elf32_Half    e_shentsize;            <span class="comment">/* 节头部中一个条目的长度 */</span></span><br><span class="line">        Elf32_Half    e_shnum;                <span class="comment">/* 节头部条目个数 */</span></span><br><span class="line">        Elf32_Half    e_shstrndx;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;但是在uboot等环境中，是无法识别这些信息的。裸机程序总是从头一条一条指令的进行执行。所以在有些情况下我们需要去掉这些信息。那就用到了objcopy命令：</p>
<p><strong>objcopy用于将object的部分获全部内容拷贝到另一个object，从而可以实现格式的变换。</strong></p>
<p>如 <code>arm-linux-gnu-objcopy -O binary boot.elf boot.bin</code>就常用来将elf转换为<code>RAW</code>格式，从而在裸机上运行。</p>
<h3 id="2-4-2-objdump"><a href="#2-4-2-objdump" class="headerlink" title="2.4.2 objdump"></a>2.4.2 objdump</h3><p>&emsp;&emsp;objdumpb即是常用的反汇编程序，Dock常用的两条命令为：</p>
<ul>
<li><code>arm--linux-objdump -d boot.elf</code>将 elf反汇编</li>
<li><code>arm--linux-objdump -d -b binary -m arm boot.bin</code> 将 bin反汇编</li>
</ul>
<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>ARM&amp;Linux</category>
        <category>Linux驱动</category>
      </categories>
      <tags>
        <tag>交叉编译</tag>
        <tag>arm-linux</tag>
      </tags>
  </entry>
  <entry>
    <title>平台设备驱动之我见一</title>
    <url>/2017/02/03/ARM&amp;Linux/Linux%E9%A9%B1%E5%8A%A8/%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E4%B9%8B%E6%88%91%E8%A7%81%E4%B8%80/</url>
    <content><![CDATA[<p>本章介绍Linux平台设备的基础知识。</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">_______  _        _______ _________ _______  _______  _______  _______</span><br><span class="line">(  ____ )( \      (  ___  )\__   __/(  ____ \(  ___  )(  ____ )(       )</span><br><span class="line">|<span class="string"> (    )</span>||<span class="string"> (      </span>|<span class="string"> (   ) </span>|<span class="string">   ) (   </span>|<span class="string"> (    \/</span>|<span class="string"> (   ) </span>||<span class="string"> (    )</span>||<span class="string"> () () </span>|</span><br><span class="line">|<span class="string"> (____)</span>||<span class="string"> </span>|<span class="string">      </span>|<span class="string"> (___) </span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> (__    </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>||<span class="string"> (____)</span>||<span class="string"> </span>||<span class="string"> </span>||<span class="string"> </span>|</span><br><span class="line">|<span class="string">  _____)</span>|<span class="string"> </span>|<span class="string">      </span>|<span class="string">  ___  </span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string">  __)   </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>||<span class="string">     __)</span>|<span class="string"> </span>|<span class="string">(_)</span>|<span class="string"> </span>|</span><br><span class="line">|<span class="string"> (      </span>|<span class="string"> </span>|<span class="string">      </span>|<span class="string"> (   ) </span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> (      </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>||<span class="string"> (\ (   </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>|</span><br><span class="line">|<span class="string"> )      </span>|<span class="string"> (____/\</span>|<span class="string"> )   ( </span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> )      </span>|<span class="string"> (___) </span>||<span class="string"> ) \ \__</span>|<span class="string"> )   ( </span>|</span><br><span class="line">|<span class="string">/       (_______/</span>|<span class="string">/     \</span>|<span class="string">   )_(   </span>|<span class="string">/       (_______)</span>|<span class="string">/   \__/</span>|<span class="string">/     \</span>|</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="1-platform-bus-type"><a href="#1-platform-bus-type" class="headerlink" title="1.platform_bus_type"></a>1.platform_bus_type</h1><p>在<code>总线</code>、<code>驱动</code>、<code>设备</code>三个基本要素中，总线居于中心位置，通过其中的<code>match</code>函数，将驱动和设备建立联系。</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">struct bus_type <span class="attr">platform_bus_type</span> = &#123;</span><br><span class="line">    .<span class="attr">name</span>       = <span class="string">"platform"</span>,</span><br><span class="line">    .<span class="attr">dev_attrs</span>  = platform_dev_attrs,</span><br><span class="line">    .<span class="attr">match</span>      = platform_match,</span><br><span class="line">    .<span class="attr">uevent</span>     = platform_uevent,</span><br><span class="line">    .<span class="attr">pm</span>     = &amp;platform_dev_pm_ops,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由<code>platform_match</code>源码可知，如果存在<code>id</code>则使用id进行匹配，否则使用name进行字符串匹配。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static <span class="built_in">int</span> platform<span class="constructor">_match(<span class="params">struct</span> <span class="params">device</span> <span class="operator">*</span><span class="params">dev</span>, <span class="params">struct</span> <span class="params">device_driver</span> <span class="operator">*</span><span class="params">drv</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> platform_device *pdev = <span class="keyword">to</span><span class="constructor">_platform_device(<span class="params">dev</span>)</span>;</span><br><span class="line">    <span class="keyword">struct</span> platform_driver *pdrv = <span class="keyword">to</span><span class="constructor">_platform_driver(<span class="params">drv</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* match against the id table first */</span></span><br><span class="line">    <span class="keyword">if</span> (pdrv-&gt;id_table)</span><br><span class="line">        return platform<span class="constructor">_match_id(<span class="params">pdrv</span>-&gt;<span class="params">id_table</span>, <span class="params">pdev</span>)</span> != NULL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fall-back to driver name match */</span></span><br><span class="line">    return (strcmp(pdev-&gt;name, drv-&gt;name)<span class="operator"> == </span><span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以就能够理解驱动源码中的<code>id_tables</code>的含义了</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">static struct platform_device_id s3c24xx_driver_ids[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">.name</span>       = <span class="string">"s3c2410-i2c"</span>,</span><br><span class="line">        <span class="string">.driver_data</span>    = TYPE_S3C2410,</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="string">.name</span>       = <span class="string">"s3c2440-i2c"</span>,</span><br><span class="line">        <span class="string">.driver_data</span>    = TYPE_S3C2440,</span><br><span class="line">    &#125;, &#123; &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每一项表征能够支持一款设备。</p>
<h1 id="2-platform-device"><a href="#2-platform-device" class="headerlink" title="2.platform_device"></a>2.platform_device</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>  * name;</span><br><span class="line">    <span class="keyword">int</span>     id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>   <span class="title">dev</span>;</span></span><br><span class="line">    u32     num_resources;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> * <span class="title">resource</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span>   *<span class="title">id_entry</span>;</span></span><br><span class="line">    <span class="comment">/* arch specific additions */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pdev_archdata</span>    <span class="title">archdata</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在该结构体中定义了ID以及name,在想平台总线注册设备的时候就会依据name或ID进行匹配。<br> dev，真正的设备，通过 <code>container_of</code> ,就能找到整个platform_device。</p>
<h1 id="3-platform-device-dirver"><a href="#3-platform-device-dirver" class="headerlink" title="3.platform_device_dirver"></a>3.platform_device_dirver</h1><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> &#123;</span></span><br><span class="line">    int (*probe)(<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *);</span></span><br><span class="line">    int (*remove)(<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *);</span></span><br><span class="line">    void (*shutdown)(<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *);</span></span><br><span class="line">    int (*suspend)(<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *, <span class="title">pm_message_t</span> <span class="title">state</span>);</span></span><br><span class="line">    int (*resume)(<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span> *<span class="title">id_table</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在driver中主要要实现probe函数，这是平台匹配到设备时第一个要调用的函数，同时设置好<code>id_tables</code>这样平台驱动才能够进行匹配。</p>
<h1 id="4-接口"><a href="#4-接口" class="headerlink" title="4.接口"></a>4.接口</h1><h2 id="4-1设备接口"><a href="#4-1设备接口" class="headerlink" title="4.1设备接口"></a>4.1设备接口</h2><p>对于设备平台提供了如下接口，这也就是说我们在编写设备文件时能够调用这些接口：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* include/linux/platform_device.h */</span></span><br><span class="line"><span class="comment">//Platform设备的注册/注销接口</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> platform_device_register(<span class="keyword">struct</span> platform_device *);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> platform_device_unregister(<span class="keyword">struct</span> platform_device *);</span><br><span class="line"></span><br><span class="line"><span class="comment">//arch_setup_pdev_archdata，设置platform_device变量中的archdata指针。</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> arch_setup_pdev_archdata(<span class="keyword">struct</span> platform_device *);</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下这些接口，可以获取platform_device变量中的resource信息，以及直接获取IRQ的number等等。</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> resource *platform_get_resource(<span class="keyword">struct</span> platform_device *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> platform_get_irq(<span class="keyword">struct</span> platform_device *, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> resource *platform_get_resource_byname(<span class="keyword">struct</span> platform_device *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> platform_get_irq_byname(<span class="keyword">struct</span> platform_device *, <span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> platform_add_devices(<span class="keyword">struct</span> platform_device **, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> platform_device *platform_device_register_full(<span class="keyword">const</span> <span class="keyword">struct</span> platform_device_info *pdevinfo);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> platform_device *platform_device_register_resndata(</span><br><span class="line">                <span class="keyword">struct</span> device *parent, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> <span class="keyword">id</span>,</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">struct</span> resource *res, <span class="keyword">unsigned</span> <span class="keyword">int</span> num,</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">void</span> *data, size_t size)</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> platform_device *platform_device_register_simple(</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> <span class="keyword">id</span>,</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">struct</span> resource *res, <span class="keyword">unsigned</span> <span class="keyword">int</span> num)</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> platform_device *platform_device_register_data(</span><br><span class="line">                <span class="keyword">struct</span> device *parent, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> <span class="keyword">id</span>,</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">void</span> *data, size_t size)</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> platform_device *platform_device_alloc(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> <span class="keyword">id</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> platform_device_add_resources(<span class="keyword">struct</span> platform_device *pdev,</span><br><span class="line">                                         <span class="keyword">const</span> <span class="keyword">struct</span> resource *res,</span><br><span class="line">                                         <span class="keyword">unsigned</span> <span class="keyword">int</span> num);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> platform_device_add_data(<span class="keyword">struct</span> platform_device *pdev,</span><br><span class="line">                                    <span class="keyword">const</span> <span class="keyword">void</span> *data, size_t size);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> platform_device_add(<span class="keyword">struct</span> platform_device *pdev);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> platform_device_del(<span class="keyword">struct</span> platform_device *pdev);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> platform_device_put(<span class="keyword">struct</span> platform_device *pdev);</span><br></pre></td></tr></table></figure>

<h2 id="4-2驱动接口"><a href="#4-2驱动接口" class="headerlink" title="4.2驱动接口"></a>4.2驱动接口</h2><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">platform_driver_registe、platform_driver_unregister，platform <span class="built_in">driver</span>的注册、注销接口。</span><br><span class="line">platform_driver_probe，主动执行probe动作。</span><br><span class="line">platform_set_drvdata、platform_get_drvdata，设置或者获取<span class="built_in">driver</span>保存在device变量中的私有数据。</span><br></pre></td></tr></table></figure>

<h1 id="5-简单示例"><a href="#5-简单示例" class="headerlink" title="5.简单示例"></a>5.简单示例</h1><p>设备文件</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="comment">// 设备资源</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> <span class="title">led_resource</span>[] = &#123;</span>   <span class="comment">//jz2440的参数，驱动未测试</span></span><br><span class="line">    [<span class="number">0</span>] = &#123;</span><br><span class="line">        .start = <span class="number">0x56000010</span>,</span><br><span class="line">        .<span class="built_in">end</span>   = <span class="number">0x56000010</span> + <span class="number">8</span> - <span class="number">1</span>,</span><br><span class="line">        .flags = IORESOURCE_MEM,</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="number">1</span>] = &#123;</span><br><span class="line">        .start = <span class="number">5</span>,</span><br><span class="line">        .<span class="built_in">end</span>   = <span class="number">5</span>,</span><br><span class="line">        .flags = IORESOURCE_IRQ,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">led_release</span><span class="params">(struct device *dev)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个设备</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> <span class="title">led_dev</span> = &#123;</span></span><br><span class="line">    .name = <span class="string">"myled"</span>,    <span class="comment">//设备名字 与 驱动相匹配</span></span><br><span class="line">    .id   = <span class="number">-1</span>,</span><br><span class="line">    .num_resources = ARRAY_SIZE(led_resource),</span><br><span class="line">    .resource = led_resource,</span><br><span class="line"></span><br><span class="line">    .dev = &#123;</span><br><span class="line">        .<span class="built_in">release</span> = led_release,</span><br><span class="line">        <span class="comment">//.devt = MKDEV(252, 1),</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">led_dev_init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向bus注册led_dev match drv链表进行配对</span></span><br><span class="line">    platform_device_register(&amp;led_dev);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">led_dev_exit</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    platform_device_unregister(&amp;led_dev);</span><br><span class="line">&#125;</span><br><span class="line">module_init(led_dev_init);</span><br><span class="line">module_exit(led_dev_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure>
<p>驱动文件</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> major;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">class</span> *<span class="title">cls</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *gpio_con;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *gpio_dat;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> pin;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">led_open</span><span class="params">(struct inode *inode, struct file *file)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    *gpio_con &amp;= ~(<span class="number">0x03</span> &lt;&lt; (pin*<span class="number">2</span>));</span><br><span class="line">    *gpio_con |=  (<span class="number">0x01</span> &lt;&lt; (pin*<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">led_write</span><span class="params">(struct file *file, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    copy_from_user(&amp;val, buf, count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(val == <span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        *gpio_dat &amp;= ~(<span class="number">1</span>&lt;&lt;pin);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">        *gpio_dat &amp;=  (<span class="number">1</span>&lt;&lt;pin);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">led_fops</span> = &#123;</span></span><br><span class="line"></span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .<span class="built_in">open</span>  = led_open,</span><br><span class="line">    .<span class="built_in">write</span> = led_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">led_probe</span><span class="params">(struct platform_device *pdev)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res</span>;</span></span><br><span class="line">    <span class="comment">// 最后一个参数 0 表示第1个该类型的资源</span></span><br><span class="line">    res = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line">    gpio_con = ioremap(res-&gt;start, res-&gt;<span class="built_in">end</span> - res-&gt;start + <span class="number">1</span>);</span><br><span class="line">    gpio_dat = gpio_con + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    res = platform_get_resource(pdev, IORESOURCE_IRQ, <span class="number">0</span>);</span><br><span class="line">    pin = res-&gt;start;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">"led_probe, found led\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册设备驱动 创建设备节点</span></span><br><span class="line">    major = register_chrdev(<span class="number">0</span>, <span class="string">"myled"</span>, &amp;led_fops);</span><br><span class="line">    <span class="comment">// 创建类</span></span><br><span class="line">    cls = class_create(THIS_MODULE, <span class="string">"myled"</span>);</span><br><span class="line">    <span class="comment">// 创建设备节点</span></span><br><span class="line">    dev = device_create(cls, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">"led"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">led_remove</span><span class="params">(struct platform_device *pdev)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">"led_remove, remove led\n"</span>);</span><br><span class="line">    <span class="comment">// 删除设备节点</span></span><br><span class="line">    device_unregister(dev);</span><br><span class="line">    <span class="comment">// 销毁类</span></span><br><span class="line">    class_destroy(cls);</span><br><span class="line">    <span class="comment">// 取消注册设备驱动</span></span><br><span class="line">    unregister_chrdev(major, <span class="string">"myled"</span>);</span><br><span class="line">    <span class="comment">// 取消内存映射</span></span><br><span class="line">    iounmap(gpio_con);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">led_drv</span> = &#123;</span></span><br><span class="line"></span><br><span class="line">    .probe  = led_probe,    <span class="comment">//匹配到dev之后调用probe</span></span><br><span class="line">    .<span class="built_in">remove</span> = led_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">"myled"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">led_drv_init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    platform_driver_register(&amp;led_drv);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">led_drv_exit</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    platform_driver_unregister(&amp;led_drv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(led_drv_init);</span><br><span class="line">module_exit(led_drv_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure>


<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>ARM&amp;Linux</category>
        <category>Linux驱动</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>平台设备</tag>
      </tags>
  </entry>
  <entry>
    <title>通信协议-IIC Verilog HDL实现</title>
    <url>/2017/06/08/FPGA/%E5%8D%8F%E8%AE%AE/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE-IIC-Verilog-HDL%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>&emsp;&emsp;该程序使用Verilog通过状态机实现IIC读写AT24C02。</p>
<a id="more"></a>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> iic_com(</span><br><span class="line">    clk, rst_n,</span><br><span class="line">    sw1, sw2,		<span class="comment">// SW1写入AT240C2</span></span><br><span class="line">    scl, sda,       <span class="comment">//时钟 数据</span></span><br><span class="line">    dis_data        <span class="comment">//输出变量用数码管显示</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> clk;</span><br><span class="line"><span class="keyword">input</span> rst_n;</span><br><span class="line"><span class="keyword">input</span> sw1,sw2;</span><br><span class="line"><span class="keyword">output</span> scl;</span><br><span class="line"><span class="keyword">inout</span> sda;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] dis_data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> sw1_r, sw2_r;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">19</span>:<span class="number">0</span>] cnt_20ms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span>(!rst_n)</span><br><span class="line">        cnt_20ms &lt;= <span class="number">20'd0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cnt_20ms &lt;= cnt_20ms + <span class="number">1'b1</span>;        <span class="comment">//不断计数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span>(!rst_n)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            sw1_r &lt;= <span class="number">1'b1</span>;</span><br><span class="line">            sw2_r &lt;= <span class="number">1'b1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cnt_20ms == <span class="number">20'hfffff</span>)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            sw1_r &lt;= sw1;       <span class="comment">//20ms进行一次锁存</span></span><br><span class="line">            sw2_r &lt;= sw2;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下的程序将输入时钟进行分频，并且应用于SCL输出上</span></span><br><span class="line"><span class="keyword">reg</span>[<span class="number">2</span>:<span class="number">0</span>] cnt;	<span class="comment">// cnt=0:scl上升沿，cnt=1:scl高电平中间，cnt=2:scl下降沿，cnt=3:scl低电平中间</span></span><br><span class="line"><span class="keyword">reg</span>[<span class="number">8</span>:<span class="number">0</span>] cnt_delay;	<span class="comment">//500循环计数，产生iic所需要的时钟</span></span><br><span class="line"><span class="keyword">reg</span> scl_r;		<span class="comment">//时钟脉冲寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">	<span class="keyword">if</span>(!rst_n) cnt_delay &lt;= <span class="number">9'd0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(cnt_delay == <span class="number">9'd499</span>) cnt_delay &lt;= <span class="number">9'd0</span>;	<span class="comment">//计数到10us为scl的周期，即100KHz</span></span><br><span class="line">	<span class="keyword">else</span> cnt_delay &lt;= cnt_delay+<span class="number">1'b1</span>;	<span class="comment">//时钟计数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span>(!rst_n) cnt &lt;= <span class="number">3'd5</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">case</span> (cnt_delay)</span><br><span class="line">			<span class="number">9'd124</span>:	cnt &lt;= <span class="number">3'd1</span>;	<span class="comment">//cnt=1:scl高电平中间,用于数据采样</span></span><br><span class="line">			<span class="number">9'd249</span>:	cnt &lt;= <span class="number">3'd2</span>;	<span class="comment">//cnt=2:scl下降沿</span></span><br><span class="line">			<span class="number">9'd374</span>:	cnt &lt;= <span class="number">3'd3</span>;	<span class="comment">//cnt=3:scl低电平中间,用于数据变化</span></span><br><span class="line">			<span class="number">9'd499</span>:	cnt &lt;= <span class="number">3'd0</span>;	<span class="comment">//cnt=0:scl上升沿</span></span><br><span class="line">			<span class="keyword">default</span>: cnt &lt;= <span class="number">3'd5</span>;</span><br><span class="line">			<span class="keyword">endcase</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="meta-keyword">define</span> SCL_POS     (cnt == 3'd0)</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">define</span> SCL_HIG     (cnt == 3'd1)</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">define</span> SCL_NEG     (cnt == 3'd2)</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">define</span> SCL_LOW     (cnt == 3'd3)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span>(!rst_n)</span><br><span class="line">        scl_r &lt;= <span class="number">1'b0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">3'd0</span>)</span><br><span class="line">        scl_r &lt;= <span class="number">1'b1</span>;      <span class="comment">//scl信号设置为高</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">3'd2</span>)</span><br><span class="line">        scl_r &lt;= <span class="number">1'b0</span>;      <span class="comment">//scl信号设置为低</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> scl = scl_r;     <span class="comment">//模块对外输出SCL信号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体对24C02的具体操作</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">define</span> DEVICE_READ     8'b1010_0001</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">define</span> DEVICE_WRITE    8'b1010_0000</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">define</span> WRITE_DATA      8'b0001_0001</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">define</span> BYTE_ADDR       8'b0000_0011</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] db_r;          <span class="comment">//在IIC上传送的数据寄存器</span></span><br><span class="line"><span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] read_data;     <span class="comment">//读出的EEPROM的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读写时序</span></span><br><span class="line"><span class="keyword">parameter</span> IDLE      = <span class="number">4'd0</span>;</span><br><span class="line"><span class="keyword">parameter</span> START1    = <span class="number">4'd1</span>;</span><br><span class="line"><span class="keyword">parameter</span> ADD1      = <span class="number">4'd2</span>;</span><br><span class="line"><span class="keyword">parameter</span> ACK1      = <span class="number">4'd3</span>;</span><br><span class="line"><span class="keyword">parameter</span> ADD2      = <span class="number">4'd4</span>;</span><br><span class="line"><span class="keyword">parameter</span> ACK2      = <span class="number">4'd5</span>;</span><br><span class="line"><span class="keyword">parameter</span> START2    = <span class="number">4'd6</span>;</span><br><span class="line"><span class="keyword">parameter</span> ADD3      = <span class="number">4'd7</span>;</span><br><span class="line"><span class="keyword">parameter</span> ACK3      = <span class="number">4'd8</span>;</span><br><span class="line"><span class="keyword">parameter</span> DATA      = <span class="number">4'd9</span>;</span><br><span class="line"><span class="keyword">parameter</span> ACK4      = <span class="number">4'd10</span>;</span><br><span class="line"><span class="keyword">parameter</span> STOP1     = <span class="number">4'd11</span>;</span><br><span class="line"><span class="keyword">parameter</span> STOP2     = <span class="number">4'd12</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] cstate;        <span class="comment">//状态寄存器</span></span><br><span class="line"><span class="keyword">reg</span> sda_r;              <span class="comment">//输出数据寄存器</span></span><br><span class="line"><span class="keyword">reg</span> sda_link;           <span class="comment">//输出数据sda信号inout方向控制位 1 输入 0 输出</span></span><br><span class="line"><span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(!rst_n)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        cstate &lt;= IDLE;</span><br><span class="line">        sda_r &lt;= <span class="number">1'b1</span>;</span><br><span class="line">        sda_link &lt;= <span class="number">1'b0</span>;</span><br><span class="line">        num &lt;= <span class="number">4'd0</span>;</span><br><span class="line">        read_data &lt;= <span class="number">8'b0000_0000</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">case</span>(cstate)</span><br><span class="line">        IDLE:</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">          sda_link &lt;= <span class="number">1'b1</span>;</span><br><span class="line">          sda_r &lt;= <span class="number">1'b1</span>;</span><br><span class="line">          <span class="keyword">if</span>(!sw1_r || sw2_r)</span><br><span class="line">          <span class="keyword">begin</span></span><br><span class="line">            db_r &lt;= <span class="meta">`DEVICE_WRITE;</span></span><br><span class="line">            cstate &lt;= START1;</span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          cstate &lt;= IDLE;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        START1:                         <span class="comment">//先给出开始信号</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="meta">`SCL_HIG)</span></span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                sda_link &lt;= <span class="number">1'b1</span>;       <span class="comment">//设置sda为output</span></span><br><span class="line">                sda_r &lt;= <span class="number">1'b0</span>;          <span class="comment">//拉低sda,产生起始信号</span></span><br><span class="line">                cstate &lt;= ADD1;         <span class="comment">//进入下一阶段</span></span><br><span class="line">                num &lt;= <span class="number">4'd0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cstate &lt;= START1;     <span class="comment">//等待达到 SCL高电平中间</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        ADD1:</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="meta">`SCL_LOW)                    //低电平变换数据</span></span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(num == <span class="number">4'd8</span>)</span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    num &lt;= <span class="number">4'd0</span>;</span><br><span class="line">                    sda_r &lt;= <span class="number">1'b1</span>;</span><br><span class="line">                    sda_link &lt;= <span class="number">1'b0</span>;        <span class="comment">//sda设置为高阻态（input）</span></span><br><span class="line">                    cstate &lt;= ACK1;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    cstate &lt;= ADD1;</span><br><span class="line">                    num &lt;= num + <span class="number">1'b1</span>;</span><br><span class="line">                    <span class="keyword">case</span>(num)</span><br><span class="line">                        <span class="number">4'd0</span>: sda_r &lt;= db_r[<span class="number">7</span>];</span><br><span class="line">                        <span class="number">4'd1</span>: sda_r &lt;= db_r[<span class="number">6</span>];</span><br><span class="line">                        <span class="number">4'd2</span>: sda_r &lt;= db_r[<span class="number">5</span>];</span><br><span class="line">                        <span class="number">4'd3</span>: sda_r &lt;= db_r[<span class="number">4</span>];</span><br><span class="line">                        <span class="number">4'd4</span>: sda_r &lt;= db_r[<span class="number">3</span>];</span><br><span class="line">                        <span class="number">4'd5</span>: sda_r &lt;= db_r[<span class="number">2</span>];</span><br><span class="line">                        <span class="number">4'd6</span>: sda_r &lt;= db_r[<span class="number">1</span>];</span><br><span class="line">                        <span class="number">4'd7</span>: sda_r &lt;= db_r[<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">default</span>: ;</span><br><span class="line">                    <span class="keyword">endcase</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cstate &lt;= ADD1;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        ACK1:</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="meta">`SCL_NEG)            //该器件不考虑应答，直接认为已经响应，接下来传输写入的地址</span></span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                cstate &lt;= ADD2;</span><br><span class="line">                db_r &lt;= <span class="meta">`BYTE_ADDR;</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cstate &lt;= ACK1;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        ADD2:               <span class="comment">//写入数据的地址</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="meta">`SCL_LOW)</span></span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(num == <span class="number">4'd8</span>)</span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    num &lt;= <span class="number">4'd0</span>;</span><br><span class="line">                    sda_r &lt;= <span class="number">1'b1</span>;</span><br><span class="line">                    sda_link &lt;= <span class="number">1'b0</span>;       <span class="comment">//设置为高阻态，为解说应答做准备</span></span><br><span class="line">                    cstate &lt;= ACK2;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    sda_link &lt;= <span class="number">1'b1</span>;</span><br><span class="line">                    num &lt;= num + <span class="number">1'b1</span>;</span><br><span class="line">                    <span class="keyword">case</span>(num)</span><br><span class="line">                        <span class="number">4'd0</span>: sda_r &lt;= db_r[<span class="number">7</span>];</span><br><span class="line">                        <span class="number">4'd1</span>: sda_r &lt;= db_r[<span class="number">6</span>];</span><br><span class="line">                        <span class="number">4'd2</span>: sda_r &lt;= db_r[<span class="number">5</span>];</span><br><span class="line">                        <span class="number">4'd3</span>: sda_r &lt;= db_r[<span class="number">4</span>];</span><br><span class="line">                        <span class="number">4'd4</span>: sda_r &lt;= db_r[<span class="number">3</span>];</span><br><span class="line">                        <span class="number">4'd5</span>: sda_r &lt;= db_r[<span class="number">2</span>];</span><br><span class="line">                        <span class="number">4'd6</span>: sda_r &lt;= db_r[<span class="number">1</span>];</span><br><span class="line">                        <span class="number">4'd7</span>: sda_r &lt;= db_r[<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">default</span>: ;</span><br><span class="line">                    <span class="keyword">endcase</span></span><br><span class="line">                    cstate &lt;= ADD2;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cstate &lt;= ADD2;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        ACK2:</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="meta">`SCL_NEG)</span></span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(!sw1_r)          <span class="comment">//根据按键判断是读还是写</span></span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    cstate &lt;= DATA;</span><br><span class="line">                    db_r &lt;= <span class="meta">`WRITE_DATA;</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(!sw2_r)</span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    db_r &lt;= <span class="meta">`DEVICE_READ;</span></span><br><span class="line">                    cstate &lt;= START2;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cstate &lt;= START2;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        START2:</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="meta">`SCL_LOW)</span></span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                sda_link &lt;= <span class="number">1'b1</span>;</span><br><span class="line">                sda_r &lt;= <span class="number">1'b1</span>;</span><br><span class="line">                cstate &lt;= START2;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="meta">`SCL_HIG)</span></span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                sda_r &lt;= <span class="number">1'b0</span>;</span><br><span class="line">                cstate &lt;= ADD3;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cstate &lt;= START2;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        ADD3:           <span class="comment">//写入要读的地址</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="meta">`SCL_LOW)</span></span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(num == <span class="number">4'd8</span>)</span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    num &lt;= <span class="number">4'd0</span>;</span><br><span class="line">                    sda_r &lt;= <span class="number">1'b1</span>;</span><br><span class="line">                    sda_link &lt;= <span class="number">1'b0</span>;</span><br><span class="line">                    cstate &lt;= ACK3;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">case</span>(num)</span><br><span class="line">                        <span class="number">4'd0</span>: sda_r &lt;= db_r[<span class="number">7</span>];</span><br><span class="line">                        <span class="number">4'd1</span>: sda_r &lt;= db_r[<span class="number">6</span>];</span><br><span class="line">                        <span class="number">4'd2</span>: sda_r &lt;= db_r[<span class="number">5</span>];</span><br><span class="line">                        <span class="number">4'd3</span>: sda_r &lt;= db_r[<span class="number">4</span>];</span><br><span class="line">                        <span class="number">4'd4</span>: sda_r &lt;= db_r[<span class="number">3</span>];</span><br><span class="line">                        <span class="number">4'd5</span>: sda_r &lt;= db_r[<span class="number">2</span>];</span><br><span class="line">                        <span class="number">4'd6</span>: sda_r &lt;= db_r[<span class="number">1</span>];</span><br><span class="line">                        <span class="number">4'd7</span>: sda_r &lt;= db_r[<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">default</span>: ;</span><br><span class="line">                    <span class="keyword">endcase</span></span><br><span class="line">                    cstate &lt;= ADD3;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cstate &lt;= ADD3;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        ACK3:</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="meta">`SCL_NEG)</span></span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                cstate &lt;= DATA;</span><br><span class="line">                sda_link &lt;= <span class="number">1'b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cstate &lt;= ACK3;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        DATA:</span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(!sw2_r)      <span class="comment">//读操作</span></span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span>(num &lt;= <span class="number">4'd7</span>)</span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        cstate &lt;= DATA;</span><br><span class="line">                        <span class="keyword">if</span>(<span class="meta">`SCL_HIG)</span></span><br><span class="line">                        <span class="keyword">begin</span></span><br><span class="line">                            num &lt;= num + <span class="number">1'b1</span>;</span><br><span class="line">                            <span class="keyword">case</span>(num)</span><br><span class="line">                            <span class="number">4'd0</span>: read_data[<span class="number">7</span>] &lt;= sda;  <span class="comment">//依次在高电平保存数据</span></span><br><span class="line">                            <span class="number">4'd1</span>: read_data[<span class="number">6</span>] &lt;= sda;</span><br><span class="line">                            <span class="number">4'd2</span>: read_data[<span class="number">5</span>] &lt;= sda;</span><br><span class="line">                            <span class="number">4'd3</span>: read_data[<span class="number">4</span>] &lt;= sda;</span><br><span class="line">                            <span class="number">4'd4</span>: read_data[<span class="number">3</span>] &lt;= sda;</span><br><span class="line">                            <span class="number">4'd5</span>: read_data[<span class="number">2</span>] &lt;= sda;</span><br><span class="line">                            <span class="number">4'd6</span>: read_data[<span class="number">1</span>] &lt;= sda;</span><br><span class="line">                            <span class="number">4'd7</span>: read_data[<span class="number">0</span>] &lt;= sda;</span><br><span class="line">                            <span class="keyword">default</span>: ;</span><br><span class="line">                            <span class="keyword">endcase</span></span><br><span class="line">                        <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>((<span class="meta">`SCL_LOW) &amp;&amp; (num == 4'd8))</span></span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        num &lt;= <span class="number">4'd0</span>;</span><br><span class="line">                        cstate &lt;= ACK4;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        cstate &lt;= DATA;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(!sw1_r)     <span class="comment">//写操作</span></span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    sda_link &lt;= <span class="number">1'b1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(num &lt;= <span class="number">4'd7</span>)</span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        cstate &lt;= DATA;</span><br><span class="line">                        <span class="keyword">if</span>(<span class="meta">`SCL_LOW)</span></span><br><span class="line">                        <span class="keyword">begin</span></span><br><span class="line">                            sda_link &lt;= <span class="number">1'b1</span>;</span><br><span class="line">                            num &lt;= num + <span class="number">1'b1</span>;</span><br><span class="line">                            <span class="keyword">case</span>(num)</span><br><span class="line">                            <span class="number">4'd0</span>: sda_r &lt;= db_r[<span class="number">7</span>];</span><br><span class="line">                            <span class="number">4'd1</span>: sda_r &lt;= db_r[<span class="number">6</span>];</span><br><span class="line">                            <span class="number">4'd2</span>: sda_r &lt;= db_r[<span class="number">5</span>];</span><br><span class="line">                            <span class="number">4'd3</span>: sda_r &lt;= db_r[<span class="number">4</span>];</span><br><span class="line">                            <span class="number">4'd4</span>: sda_r &lt;= db_r[<span class="number">3</span>];</span><br><span class="line">                            <span class="number">4'd5</span>: sda_r &lt;= db_r[<span class="number">2</span>];</span><br><span class="line">                            <span class="number">4'd6</span>: sda_r &lt;= db_r[<span class="number">1</span>];</span><br><span class="line">                            <span class="number">4'd7</span>: sda_r &lt;= db_r[<span class="number">0</span>];</span><br><span class="line">                            <span class="keyword">default</span>: ;</span><br><span class="line">                            <span class="keyword">endcase</span></span><br><span class="line">                        <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>((<span class="meta">`SCL_LOW) &amp;&amp; (num == 4'd8))</span></span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        num &lt;= <span class="number">4'd0</span>;</span><br><span class="line">                        sda_r &lt;= <span class="number">1'b1</span>;</span><br><span class="line">                        sda_link &lt;= <span class="number">1'b0</span>;</span><br><span class="line">                        cstate &lt;= ACK4;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        cstate &lt;= ACK4;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            ACK4:</span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="meta">`SCL_NEG)</span></span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    cstate &lt;= STOP1;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    cstate &lt;= ACK4;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            STOP1:</span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="meta">`SCL_LOW)</span></span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    sda_link &lt;= <span class="number">1'b1</span>;</span><br><span class="line">                    sda_r &lt;= <span class="number">1'b0</span>;</span><br><span class="line">                    cstate &lt;= STOP1;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(<span class="meta">`SCL_HIG)</span></span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    sda_r &lt;= <span class="number">1'b1</span>;</span><br><span class="line">                    cstate &lt;= STOP2;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                cstate &lt;= STOP1;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            STOP2:</span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span>(<span class="meta">`SCL_LOW)</span></span><br><span class="line">                        sda_r &lt;= <span class="number">1'b1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(cnt_20ms == <span class="number">20'hffff0</span>)</span><br><span class="line">                        cstate &lt;= IDLE;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        cstate &lt;= STOP2;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">default</span>: cstate &lt;= IDLE;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> sda = sda_link ? sda_r:<span class="number">1'bz</span>;</span><br><span class="line"><span class="keyword">assign</span> dis_data = read_data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>


<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>FPGA</category>
        <category>通信协议</category>
      </categories>
      <tags>
        <tag>IIC</tag>
        <tag>Verilog HDL</tag>
        <tag>IIC实现</tag>
      </tags>
  </entry>
  <entry>
    <title>通信协议-IIC</title>
    <url>/2017/05/24/FPGA/%E5%8D%8F%E8%AE%AE/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE-IIC/</url>
    <content><![CDATA[<p>&emsp;&emsp;IIC协议在Dock看来是最简单易懂的协议之一。本文介绍IIC协议的基础要点。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7774609-ae4c15be153e6ff7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<a id="more"></a>
<h2 id="1-IIC基础要点"><a href="#1-IIC基础要点" class="headerlink" title="1.IIC基础要点"></a>1.IIC基础要点</h2><ul>
<li>在时钟的高电平周期内，SDA线上的数据必须保持稳定，数据线仅可以在时钟SCL为低电平时改变。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/7774609-f3d3629cfadc6e03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>起始条件：当SCL为高电平的时候，SDA线上由高到低的跳变被定义为起始条件</li>
<li>结束条件：当SCL为高电平的时候，SDA线上由低到高的跳变被定义为停止条件</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/7774609-3fc256a36fb3a6cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>每当主机向从机发送完一个字节的数据，主机总是需要等待从机给出一个应答信号，以确认从机是否成功接收到了数据，从机应答主机所需要的时钟仍是主机提供的，应答出现在每一次主机完成8个数据位传输后紧跟着的时钟周期，低电平0表示应答，1表示非应答。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/7774609-a950c9e5c99dbd82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="2-IIC的C实现"><a href="#2-IIC的C实现" class="headerlink" title="2 IIC的C实现"></a>2 IIC的C实现</h2><ul>
<li>初始时SDA、SCL都处于高电平<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">void Init()</span><br><span class="line">&#123;</span><br><span class="line">    SCL = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">    delay()<span class="comment">;</span></span><br><span class="line">    SDA = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">    delay()<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>起始信号 SDA在SCL为高电平时产生下降沿：<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">void StartUp</span><br><span class="line">&#123;</span><br><span class="line">    SCL = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">    SDA = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">    delay()<span class="comment">;</span></span><br><span class="line">    SDA = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">    delay()<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>结束信号 SDA在SCL为高电平时产生上升沿：<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">void End()</span><br><span class="line">&#123;</span><br><span class="line">    SCL = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">    SDA = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">    delay()<span class="comment">;</span></span><br><span class="line">    SDA = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">    delay()<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>字节发送函数 SCL为低时SDA变为有效数据，SCL为高时，采集数据<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> Transfer(<span class="built_in">int</span>8_t i8Send)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>32_t nIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(nIndex = <span class="number">7</span>; nIndex &gt;= <span class="number">0</span>; nIndex++)</span><br><span class="line">    &#123;</span><br><span class="line">        SCL = <span class="number">0</span>;</span><br><span class="line">        SDA = (i8Send &gt;&gt; nIndex) &amp; <span class="number">0x01</span>; <span class="comment">//MSB方式进行发送</span></span><br><span class="line">        delay();</span><br><span class="line">        SCL = <span class="number">1</span>;                        <span class="comment">//变为高电平，SLAVE短进行数据锁存</span></span><br><span class="line">        delay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>判断回复报文 Slave端主动拉低SDA<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>8_t CheckAck()</span><br><span class="line">&#123;</span><br><span class="line">    delay();</span><br><span class="line">    <span class="keyword">if</span>(SDA == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>FPGA</category>
        <category>通信协议</category>
      </categories>
  </entry>
  <entry>
    <title>通信协议-SPI</title>
    <url>/2017/02/24/FPGA/%E5%8D%8F%E8%AE%AE/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE-SPI/</url>
    <content><![CDATA[<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>FPGA</category>
        <category>通信协议</category>
      </categories>
  </entry>
  <entry>
    <title>通信协议-UART-Verilog实现</title>
    <url>/2017/02/26/FPGA/%E5%8D%8F%E8%AE%AE/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE-UART-Verilog%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>&emsp;&emsp;本篇通过使用Verilog实现UART的读写。</p>
<a id="more"></a>
<ul>
<li><p>RX模块</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> my_uart_rx(</span><br><span class="line">				clk,rst_n,</span><br><span class="line">				rs232_rx,rx_data,rx_int,</span><br><span class="line">				clk_bps,bps_start</span><br><span class="line">			);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> clk;		<span class="comment">// 50MHz主时钟</span></span><br><span class="line"><span class="keyword">input</span> rst_n;	<span class="comment">//低电平复位信号</span></span><br><span class="line"><span class="keyword">input</span> rs232_rx;	<span class="comment">// RS232接收数据信号</span></span><br><span class="line"><span class="keyword">input</span> clk_bps;	<span class="comment">// clk_bps的高电平为接收或者发送数据位的中间采样点</span></span><br><span class="line"><span class="keyword">output</span> bps_start;		<span class="comment">//接收到数据后，波特率时钟启动信号置位</span></span><br><span class="line"><span class="keyword">output</span>[<span class="number">7</span>:<span class="number">0</span>] rx_data;	<span class="comment">//接收数据寄存器，保存直至下一个数据来到</span></span><br><span class="line"><span class="keyword">output</span> rx_int;	<span class="comment">//接收数据中断信号,接收到数据期间始终为高电平</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">reg</span> rs232_rx0,rs232_rx1,rs232_rx2,rs232_rx3;	<span class="comment">//接收数据寄存器，滤波用</span></span><br><span class="line"><span class="keyword">wire</span> neg_rs232_rx;	<span class="comment">//表示数据线接收到下降沿</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span>(!rst_n) <span class="keyword">begin</span></span><br><span class="line">			rs232_rx0 &lt;= <span class="number">1'b0</span>;</span><br><span class="line">			rs232_rx1 &lt;= <span class="number">1'b0</span>;</span><br><span class="line">			rs232_rx2 &lt;= <span class="number">1'b0</span>;</span><br><span class="line">			rs232_rx3 &lt;= <span class="number">1'b0</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">			rs232_rx0 &lt;= rs232_rx;</span><br><span class="line">			rs232_rx1 &lt;= rs232_rx0;</span><br><span class="line">			rs232_rx2 &lt;= rs232_rx1;</span><br><span class="line">			rs232_rx3 &lt;= rs232_rx2;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">	<span class="comment">//下面的下降沿检测可以滤掉&lt;20ns-40ns的毛刺(包括高脉冲和低脉冲毛刺)，</span></span><br><span class="line">	<span class="comment">//这里就是用资源换稳定（前提是我们对时间要求不是那么苛刻，因为输入信号打了好几拍）</span></span><br><span class="line">	<span class="comment">//（当然我们的有效低脉冲信号肯定是远远大于40ns的）</span></span><br><span class="line"><span class="keyword">assign</span> neg_rs232_rx = rs232_rx3 &amp; rs232_rx2 &amp; ~rs232_rx1 &amp; ~rs232_rx0;	<span class="comment">//接收到下降沿后neg_rs232_rx置高一个时钟周期</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">reg</span> bps_start_r;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] num;	<span class="comment">//移位次数</span></span><br><span class="line"><span class="keyword">reg</span> rx_int;		<span class="comment">//接收数据中断信号,接收到数据期间始终为高电平</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">	<span class="keyword">if</span>(!rst_n) <span class="keyword">begin</span></span><br><span class="line">			bps_start_r &lt;= <span class="number">1'bz</span>;</span><br><span class="line">			rx_int &lt;= <span class="number">1'b0</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(neg_rs232_rx) <span class="keyword">begin</span>		<span class="comment">//接收到串口接收线rs232_rx的下降沿标志信号</span></span><br><span class="line">			bps_start_r &lt;= <span class="number">1'b1</span>;	<span class="comment">//启动串口准备数据接收</span></span><br><span class="line">			rx_int &lt;= <span class="number">1'b1</span>;			<span class="comment">//接收数据中断信号使能</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(num==<span class="number">4'd12</span>) <span class="keyword">begin</span>		<span class="comment">//接收完有用数据信息</span></span><br><span class="line">			bps_start_r &lt;= <span class="number">1'b0</span>;	<span class="comment">//数据接收完毕，释放波特率启动信号</span></span><br><span class="line">			rx_int &lt;= <span class="number">1'b0</span>;			<span class="comment">//接收数据中断信号关闭</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> bps_start = bps_start_r;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] rx_data_r;		<span class="comment">//串口接收数据寄存器，保存直至下一个数据来到</span></span><br><span class="line"><span class="comment">//----------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] rx_temp_data;	<span class="comment">//当前接收数据寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">	<span class="keyword">if</span>(!rst_n) <span class="keyword">begin</span></span><br><span class="line">			rx_temp_data &lt;= <span class="number">8'd0</span>;</span><br><span class="line">			num &lt;= <span class="number">4'd0</span>;</span><br><span class="line">			rx_data_r &lt;= <span class="number">8'd0</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(rx_int) <span class="keyword">begin</span>	<span class="comment">//接收数据处理</span></span><br><span class="line">		<span class="keyword">if</span>(clk_bps) <span class="keyword">begin</span>	<span class="comment">//读取并保存数据,接收数据为一个起始位，8bit数据，1或2个结束位</span></span><br><span class="line">				num &lt;= num+<span class="number">1'b1</span>;</span><br><span class="line">				<span class="keyword">case</span> (num)</span><br><span class="line">						<span class="number">4'd1</span>: rx_temp_data[<span class="number">0</span>] &lt;= rs232_rx;	<span class="comment">//锁存第0bit</span></span><br><span class="line">						<span class="number">4'd2</span>: rx_temp_data[<span class="number">1</span>] &lt;= rs232_rx;	<span class="comment">//锁存第1bit</span></span><br><span class="line">						<span class="number">4'd3</span>: rx_temp_data[<span class="number">2</span>] &lt;= rs232_rx;	<span class="comment">//锁存第2bit</span></span><br><span class="line">						<span class="number">4'd4</span>: rx_temp_data[<span class="number">3</span>] &lt;= rs232_rx;	<span class="comment">//锁存第3bit</span></span><br><span class="line">						<span class="number">4'd5</span>: rx_temp_data[<span class="number">4</span>] &lt;= rs232_rx;	<span class="comment">//锁存第4bit</span></span><br><span class="line">						<span class="number">4'd6</span>: rx_temp_data[<span class="number">5</span>] &lt;= rs232_rx;	<span class="comment">//锁存第5bit</span></span><br><span class="line">						<span class="number">4'd7</span>: rx_temp_data[<span class="number">6</span>] &lt;= rs232_rx;	<span class="comment">//锁存第6bit</span></span><br><span class="line">						<span class="number">4'd8</span>: rx_temp_data[<span class="number">7</span>] &lt;= rs232_rx;	<span class="comment">//锁存第7bit</span></span><br><span class="line">						<span class="keyword">default</span>: ;</span><br><span class="line">					<span class="keyword">endcase</span></span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">4'd12</span>) <span class="keyword">begin</span>		<span class="comment">//我们的标准接收模式下只有1+8+1(2)=11bit的有效数据</span></span><br><span class="line">				num &lt;= <span class="number">4'd0</span>;			<span class="comment">//接收到STOP位后结束,num清零</span></span><br><span class="line">				rx_data_r &lt;= rx_temp_data;	<span class="comment">//把数据锁存到数据寄存器rx_data中</span></span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> rx_data = rx_data_r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>TX模块</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> my_uart_tx(</span><br><span class="line">				clk,rst_n,</span><br><span class="line">				rx_data,rx_int,rs232_tx,</span><br><span class="line">				clk_bps,bps_start</span><br><span class="line">			);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> clk;			<span class="comment">// 50MHz主时钟</span></span><br><span class="line"><span class="keyword">input</span> rst_n;		<span class="comment">//低电平复位信号</span></span><br><span class="line"><span class="keyword">input</span> clk_bps;		<span class="comment">// clk_bps_r高电平为接收数据位的中间采样点,同时也作为发送数据的数据改变点</span></span><br><span class="line"><span class="keyword">input</span>[<span class="number">7</span>:<span class="number">0</span>] rx_data;	<span class="comment">//接收数据寄存器</span></span><br><span class="line"><span class="keyword">input</span> rx_int;		<span class="comment">//接收数据中断信号,接收到数据期间始终为高电平,在该模块中利用它的下降沿来启动串口发送数据</span></span><br><span class="line"><span class="keyword">output</span> rs232_tx;	<span class="comment">// RS232发送数据信号</span></span><br><span class="line"><span class="keyword">output</span> bps_start;	<span class="comment">//接收或者要发送数据，波特率时钟启动信号置位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------------------------</span></span><br><span class="line"><span class="keyword">reg</span> rx_int0,rx_int1,rx_int2;	<span class="comment">//rx_int信号寄存器，捕捉下降沿滤波用</span></span><br><span class="line"><span class="keyword">wire</span> neg_rx_int;	<span class="comment">// rx_int下降沿标志位</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span>(!rst_n) <span class="keyword">begin</span></span><br><span class="line">			rx_int0 &lt;= <span class="number">1'b0</span>;</span><br><span class="line">			rx_int1 &lt;= <span class="number">1'b0</span>;</span><br><span class="line">			rx_int2 &lt;= <span class="number">1'b0</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">			rx_int0 &lt;= rx_int;</span><br><span class="line">			rx_int1 &lt;= rx_int0;</span><br><span class="line">			rx_int2 &lt;= rx_int1;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> neg_rx_int =  ~rx_int1 &amp; rx_int2;	<span class="comment">//捕捉到下降沿后，neg_rx_int拉高保持一个主时钟周期</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------------------------</span></span><br><span class="line"><span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] tx_data;	<span class="comment">//待发送数据的寄存器</span></span><br><span class="line"><span class="comment">//---------------------------------------------------------</span></span><br><span class="line"><span class="keyword">reg</span> bps_start_r;</span><br><span class="line"><span class="keyword">reg</span> tx_en;	<span class="comment">//发送数据使能信号，高有效</span></span><br><span class="line"><span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span>(!rst_n) <span class="keyword">begin</span></span><br><span class="line">			bps_start_r &lt;= <span class="number">1'bz</span>;</span><br><span class="line">			tx_en &lt;= <span class="number">1'b0</span>;</span><br><span class="line">			tx_data &lt;= <span class="number">8'd0</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(neg_rx_int) <span class="keyword">begin</span>	<span class="comment">//接收数据完毕，准备把接收到的数据发回去</span></span><br><span class="line">			bps_start_r &lt;= <span class="number">1'b1</span>;</span><br><span class="line">			tx_data &lt;= rx_data;	<span class="comment">//把接收到的数据存入发送数据寄存器</span></span><br><span class="line">			tx_en &lt;= <span class="number">1'b1</span>;		<span class="comment">//进入发送数据状态中</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(num==<span class="number">4'd11</span>) <span class="keyword">begin</span>	<span class="comment">//数据发送完成，复位</span></span><br><span class="line">			bps_start_r &lt;= <span class="number">1'b0</span>;</span><br><span class="line">			tx_en &lt;= <span class="number">1'b0</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> bps_start = bps_start_r;</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------------------------</span></span><br><span class="line"><span class="keyword">reg</span> rs232_tx_r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span>(!rst_n) <span class="keyword">begin</span></span><br><span class="line">			num &lt;= <span class="number">4'd0</span>;</span><br><span class="line">			rs232_tx_r &lt;= <span class="number">1'b1</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(tx_en) <span class="keyword">begin</span></span><br><span class="line">			<span class="keyword">if</span>(clk_bps)	<span class="keyword">begin</span></span><br><span class="line">					num &lt;= num+<span class="number">1'b1</span>;</span><br><span class="line">					<span class="keyword">case</span> (num)</span><br><span class="line">						<span class="number">4'd0</span>: rs232_tx_r &lt;= <span class="number">1'b0</span>; 	<span class="comment">//发送起始位</span></span><br><span class="line">						<span class="number">4'd1</span>: rs232_tx_r &lt;= tx_data[<span class="number">0</span>];	<span class="comment">//发送bit0</span></span><br><span class="line">						<span class="number">4'd2</span>: rs232_tx_r &lt;= tx_data[<span class="number">1</span>];	<span class="comment">//发送bit1</span></span><br><span class="line">						<span class="number">4'd3</span>: rs232_tx_r &lt;= tx_data[<span class="number">2</span>];	<span class="comment">//发送bit2</span></span><br><span class="line">						<span class="number">4'd4</span>: rs232_tx_r &lt;= tx_data[<span class="number">3</span>];	<span class="comment">//发送bit3</span></span><br><span class="line">						<span class="number">4'd5</span>: rs232_tx_r &lt;= tx_data[<span class="number">4</span>];	<span class="comment">//发送bit4</span></span><br><span class="line">						<span class="number">4'd6</span>: rs232_tx_r &lt;= tx_data[<span class="number">5</span>];	<span class="comment">//发送bit5</span></span><br><span class="line">						<span class="number">4'd7</span>: rs232_tx_r &lt;= tx_data[<span class="number">6</span>];	<span class="comment">//发送bit6</span></span><br><span class="line">						<span class="number">4'd8</span>: rs232_tx_r &lt;= tx_data[<span class="number">7</span>];	<span class="comment">//发送bit7</span></span><br><span class="line">						<span class="number">4'd9</span>: rs232_tx_r &lt;= <span class="number">1'b1</span>;	<span class="comment">//发送结束位</span></span><br><span class="line">					 	<span class="keyword">default</span>: rs232_tx_r &lt;= <span class="number">1'b1</span>;</span><br><span class="line">						<span class="keyword">endcase</span></span><br><span class="line">				<span class="keyword">end</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(num==<span class="number">4'd11</span>) num &lt;= <span class="number">4'd0</span>;	<span class="comment">//复位</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> rs232_tx = rs232_tx_r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>FPGA</category>
        <category>通信协议</category>
      </categories>
      <tags>
        <tag>UART</tag>
        <tag>Verilog实现</tag>
      </tags>
  </entry>
  <entry>
    <title>通信协议-UART</title>
    <url>/2017/02/27/FPGA/%E5%8D%8F%E8%AE%AE/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE-UART/</url>
    <content><![CDATA[<p>&emsp;&emsp;UART协议也是一种很简单易懂的通信协议。</p>
<p>&emsp;&emsp;通用异步收发传输器(Universal Asynchronous Receiver/Transmitter)，通常称作 UART，是一种异步收发传输器。将数据由串行通信与并行通信间作传输转换，作为并行输入成为串行输出的芯片 UART 是一种通用串行数据总线，用于异步通信。该总线双向通信，可以实现全双工传输和接收。<br><img src="https://upload-images.jianshu.io/upload_images/7774609-9603c7222a5ac78b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="uart.jpg"></p>
<a id="more"></a>

<h1 id="1-协议要点"><a href="#1-协议要点" class="headerlink" title="1.协议要点"></a>1.协议要点</h1><ul>
<li>起始位：先发出一个逻辑”0”的信号，表示传输字符的开始。</li>
<li>数据位：紧接着起始位之后。数据位的个数可以是4、5、6、7、8等，构成一个字符。通常采用 ASCII 码。从最低位开始传送，靠时钟定位。</li>
<li>奇偶校验位：数据位加上这一位后，使得“1”的位数应为偶数(偶校验)或奇数(奇校验)，以此来校验数据传送的正确性。</li>
<li>停止位：它是一个字符数据的结束标志。可以是1位、1.5位、2位的高电平。由于数据是在传输线上定时的，并且每一个设备有其自己的时钟，很可能在通信中两台设备间出现了小小的不同步。因此停止位不仅仅是表示传输的结束，并且提供计算机校正时钟同步的机会。适用于停止位的位数越多，不同时钟同步的容忍程度越大。但是数据传输率同时也越慢。</li>
<li>空闲位：处于逻辑“1”状态，表示当前线路上没有数据传送</li>
</ul>
<h1 id="2-波特率"><a href="#2-波特率" class="headerlink" title="2.波特率"></a>2.波特率</h1><p>&emsp;&emsp;波特率及1秒钟能传输的Bit数。如9600波特率及指一个脉冲的时间为 1/9600 S。</p>
<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>FPGA</category>
        <category>通信协议</category>
      </categories>
      <tags>
        <tag>UART</tag>
        <tag>通信协议</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS内使用Cuda加速的配置</title>
    <url>/2018/01/24/GPU/Cuda/ROS%E5%86%85%E4%BD%BF%E7%94%A8Cuda%E5%8A%A0%E9%80%9F%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>介绍ROS中使用Cuda加速的包配置。</p>
<a id="more"></a>
<h1 id="1-ROS"><a href="#1-ROS" class="headerlink" title="1.ROS"></a>1.ROS</h1><p>ROS(机器人操作系统)是一个机器人软件平台，能够进行灵活的编程，为异构平台集群提供良好的通信控制机制。并且拥有极好的软件模拟能力，不需要硬件，也能够进行机器人算法的学习。</p>
<h1 id="2-Cuda"><a href="#2-Cuda" class="headerlink" title="2.Cuda"></a><a href="#2cuda"></a>2.Cuda</h1><p>Cuda是Nvidia开发的并行运算平台，使用其强大的并行运算能力，我们能够将逻辑控制交付给CPU,将并行计算交给GPU去运算，这就是所谓的”硬件加速”。笔者在使用ROS进行硬件加速的时候，如何添加Cuda的的编程支持，在这里尽心记录。</p>
<h1 id="3-环境配置"><a href="#3-环境配置" class="headerlink" title="3.环境配置"></a><a href="#3环境配置"></a>3.环境配置</h1><h2 id="3-1环境说明"><a href="#3-1环境说明" class="headerlink" title="3.1环境说明"></a><a href="#31环境说明"></a>3.1环境说明</h2><p>我们知道，如果需要使用Cuda C语言进行编码的话，就必须使用NVCC编译器进行编译，但是通常情况下，ROS都是通过GCC进行编译的，所以这里的设想是将硬件加速的函数以动态库的方式进行提供，其他包需要使用这个包里的硬件加速函数，就动态调用这个动态库，这样可以最大程度的减少修改原有的包的CMakelists.txt文件。</p>
<h2 id="3-2过程说明"><a href="#3-2过程说明" class="headerlink" title="3.2过程说明"></a><a href="#32过程说明"></a>3.2过程说明</h2><ul>
<li><code>catkin_create_pkg cuda_lib roscpp rospy std_msgs</code>创建一个新的包。</li>
<li>修改新建的包的CMakelists.txt文件如下：</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>.<span class="number">3</span>)</span><br><span class="line"><span class="keyword">PROJECT</span> (cuda_lib)</span><br><span class="line"><span class="keyword">FIND_PACKAGE</span>(CUDA REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 在NVCC_FLAGS变量中添加你的头文件的路径，比如这里就用到了cuda_samples提供的帮助函数</span></span><br><span class="line"><span class="keyword">SET</span>(CUDA_NVCC_FLAGS <span class="string">"-arch=sm_60"</span> <span class="string">"-I/usr/local/cuda-8.0/samples/common/inc"</span> <span class="string">"-I/home/nvidia/ros_bo/src/cuda_lib/include"</span> CACHE <span class="keyword">STRING</span> <span class="string">"nvcc flags"</span> FORCE)</span><br><span class="line"><span class="keyword">SET</span> (CUDA_VERBOSE_BUILD <span class="keyword">ON</span> CACHE BOOL <span class="string">"nvcc verbose"</span> FORCE)</span><br><span class="line"><span class="keyword">SET</span>(LIB_TYPE STATIC)</span><br><span class="line"><span class="comment">#添加一个库 libcuda_lib，在其他包中需要使用时，添加链接即可（target_link）</span></span><br><span class="line">CUDA_ADD_LIBRARY(cuda_lib <span class="variable">$&#123;LIB_TYPE&#125;</span> src/cuda_lib.cu)</span><br><span class="line"></span><br><span class="line">catkin_package(</span><br><span class="line">INCLUDE_DIRS <span class="keyword">include</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="keyword">include</span> </span><br><span class="line"> <span class="variable">$&#123;catkin_INCLUDE_DIRS&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(cuda_lib_node src/main.cpp)</span><br><span class="line"><span class="keyword">ADD_DEPENDENCIES</span>(cuda_lib_node cuda_lib)</span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span>(cuda_lib_node</span><br><span class="line">   <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">   <span class="variable">$&#123;PCL_LIBRARIES&#125;</span></span><br><span class="line">   cuda_lib</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>编写cu文件如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cuda.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cuda_runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现核函数</span></span><br><span class="line">__global__</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello_g</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  a[threadIdx.x] += b[threadIdx.x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现C函数，之后在别出调用时，直接调用该函数，就不必使用NVCC进行编译了</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hello_c</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a =<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> b= <span class="number">4</span>;</span><br><span class="line">    kernel&lt;&lt;<span class="number">1</span>,<span class="number">1</span>&gt;&gt;&gt;(&amp;a, &amp;b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>GPU</category>
        <category>Cuda</category>
      </categories>
      <tags>
        <tag>ROS</tag>
        <tag>Cuda</tag>
      </tags>
  </entry>
  <entry>
    <title>CUDA-0-基础</title>
    <url>/2016/08/26/GPU/Cuda/CUDA-0-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>本节介绍CUDA的基础概念。<br><img src="https://www.nvidia.cn/docs/IO/112626/header-cuda-parallel-programming-cn.jpg" alt="CUDA"></p>
<a id="more"></a>

<h1 id="NVCC编译"><a href="#NVCC编译" class="headerlink" title="NVCC编译"></a>NVCC编译</h1><p>NVCC是一个编译器，简化编译C和PTX代码的流程。提供和GCC类似的命令行模式。在不同的阶段调用不同的工具集。</p>
<h2 id="离线编译"><a href="#离线编译" class="headerlink" title="离线编译"></a>离线编译</h2><p>NVCC编译编译混有主机和设备代码。NVCC的工作流程主要在于分离主机和设备代码。编译设备代码成装配形式(PTX代码)或者二进制形式(cubin形式)。</p>
<ul>
<li>把调用核函数的&lt;&lt;…&gt;&gt;替换成必要的PTX代码或者cubin对象。<h2 id="即时编译"><a href="#即时编译" class="headerlink" title="即时编译"></a>即时编译</h2>应用程序在运行时加载PTX代码都会被设备驱动编译成二进制代码。</li>
</ul>
<h2 id="二进制兼容性"><a href="#二进制兼容性" class="headerlink" title="二进制兼容性"></a>二进制兼容性</h2><p>二进制代码是有架构的，也就是说每种架构下运行的二进制是有差异的。就行汇编一样，使用code选项指定目标架构产生相应的cubin对象。 <code>-code=sm_13</code>编译生成计算能力1.3的设备上运行的二进制代码。</p>
<h2 id="PTX兼容性"><a href="#PTX兼容性" class="headerlink" title="PTX兼容性"></a>PTX兼容性</h2><p>一些PTX指令只能支持高计算能力的设备。如全局的原子操作只能支持计算能力为1.1或更高的设备。将C编译成PTX。可以使用<code>-arch</code>指定编译选项指定的计算能力。</p>
<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>GPU</category>
        <category>Cuda</category>
      </categories>
      <tags>
        <tag>Cuda</tag>
      </tags>
  </entry>
  <entry>
    <title>YUYV转RGB-C-Cuda实现</title>
    <url>/2018/01/24/GPU/Cuda/YUYV%E8%BD%ACRGB-C-Cuda%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>介绍Cuda实现YUYV转RGB算法。</p>
<a id="more"></a>

<h1 id="1-YUV介绍"><a href="#1-YUV介绍" class="headerlink" title="1.YUV介绍"></a>1.YUV介绍</h1><p>  YUV是被欧洲电视系统所采用的一种颜色编码方法(属于PAL，Phase Alternation Line)，是PAL和SECAM模拟彩色电视制式采用的颜色空间。其中的Y、U、V几个字母不是英文单词的组合词，Y代表亮度，其实Y就是图像的灰度值；UV代表色差，U和V是构成彩色的两个分量。</p>
<h1 id="1-1-YUV转RGB公式"><a href="#1-1-YUV转RGB公式" class="headerlink" title="1.1 YUV转RGB公式"></a><a href="#11-yuv转rgb公式"></a>1.1 YUV转RGB公式</h1><p>YUV到RGB的转换有如下公式：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">R = <span class="number">1.164</span>*(Y<span class="number">-16</span>) + <span class="number">1.159</span>*(V<span class="number">-128</span>); </span><br><span class="line">G = <span class="number">1.164</span>*(Y<span class="number">-16</span>) - <span class="number">0.380</span>*(U<span class="number">-128</span>)+ <span class="number">0.813</span>*(V<span class="number">-128</span>); </span><br><span class="line">B = <span class="number">1.164</span>*(Y<span class="number">-16</span>) + <span class="number">2.018</span>*(U<span class="number">-128</span>));</span><br></pre></td></tr></table></figure>

<p>那么YUYV(Y0UY1V)的实现就是使用<code>Y0UV</code>转换出一个RGB像素，使用<code>Y1UV</code>转换出第二个像素，那么就实现了四个字节转换出6个字节（2个RGB像素）。</p>
<h1 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a><a href="#2代码实现"></a>2.代码实现</h1><p>C语言实现：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> CPU_YUYV2RGB(char* arrOut, char* arrIn)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned char y0, y1, u, v;</span><br><span class="line">	<span class="built_in">int</span> r, g, b;</span><br><span class="line">	<span class="built_in">int</span> nIndex = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(nIndex = <span class="number">0</span>; nIndex &lt; N/<span class="number">2</span>; nIndex++)</span><br><span class="line">	&#123;</span><br><span class="line">		y0 = *(arrIn + nIndex*<span class="number">4</span>);</span><br><span class="line">		u = *(arrIn + nIndex*<span class="number">4</span> + <span class="number">1</span>);</span><br><span class="line">		y1 = *(arrIn + nIndex*<span class="number">4</span> + <span class="number">2</span>);</span><br><span class="line">		v = *(arrIn + nIndex*<span class="number">4</span> + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">		r = <span class="number">1.164</span>*(y0<span class="number">-16</span>) + <span class="number">1.159</span>*(v<span class="number">-128</span>);</span><br><span class="line">		g = <span class="number">1.164</span>*(y0<span class="number">-16</span>) - <span class="number">0.380</span>*(u<span class="number">-128</span>) + <span class="number">0.813</span>*(v<span class="number">-128</span>);</span><br><span class="line">		b = <span class="number">1.164</span>*(y0<span class="number">-16</span>) + <span class="number">2.018</span>*(u<span class="number">-128</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (r &gt; <span class="number">255</span>) r = <span class="number">255</span>;</span><br><span class="line">		<span class="keyword">if</span> (g &gt; <span class="number">255</span>) g = <span class="number">255</span>;</span><br><span class="line">		<span class="keyword">if</span> (b &gt; <span class="number">255</span>) b = <span class="number">255</span>;</span><br><span class="line">		<span class="keyword">if</span> (r &lt; <span class="number">0</span>) r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (g &lt; <span class="number">0</span>) g = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (b &lt; <span class="number">0</span>) b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		*(arrOut + nIndex*<span class="number">6</span>) = r;</span><br><span class="line">		*(arrOut + nIndex*<span class="number">6</span>+<span class="number">1</span>) = g;</span><br><span class="line">		*(arrOut + nIndex*<span class="number">6</span>+<span class="number">2</span>) = b;</span><br><span class="line"></span><br><span class="line">		r = <span class="number">1.164</span>*(y1<span class="number">-16</span>) + <span class="number">1.159</span>*(v<span class="number">-128</span>);</span><br><span class="line">		g = <span class="number">1.164</span>*(y1<span class="number">-16</span>) - <span class="number">0.380</span>*(u<span class="number">-128</span>) + <span class="number">0.813</span>*(v<span class="number">-128</span>);</span><br><span class="line">		b = <span class="number">1.164</span>*(y1<span class="number">-16</span>) + <span class="number">2.018</span>*(u<span class="number">-128</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (r &gt; <span class="number">255</span>) r = <span class="number">255</span>;</span><br><span class="line">		<span class="keyword">if</span> (g &gt; <span class="number">255</span>) g = <span class="number">255</span>;</span><br><span class="line">		<span class="keyword">if</span> (b &gt; <span class="number">255</span>) b = <span class="number">255</span>;</span><br><span class="line">		<span class="keyword">if</span> (r &lt; <span class="number">0</span>) r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (g &lt; <span class="number">0</span>) g = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (b &lt; <span class="number">0</span>) b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		*(arrOut + nIndex*<span class="number">6</span>+<span class="number">3</span>) = r;</span><br><span class="line">		*(arrOut + nIndex*<span class="number">6</span>+<span class="number">4</span>) = g;</span><br><span class="line">		*(arrOut + nIndex*<span class="number">6</span>+<span class="number">5</span>) = b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Cuda代码实现：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">__global__ <span class="built_in">void</span> YUYV2RGB(char *g_out, char *g_in, <span class="built_in">int</span> N)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned <span class="built_in">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	unsigned char y0, y1, u, v;</span><br><span class="line">	<span class="built_in">int</span> r, g, b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> nStart = blockIdx.x * <span class="number">320</span> * <span class="number">4</span> + threadIdx.x * <span class="number">4</span> ;</span><br><span class="line">    <span class="built_in">int</span> nOut = blockIdx.x * <span class="number">320</span> * <span class="number">6</span> + threadIdx.x * <span class="number">6</span> ;</span><br><span class="line"></span><br><span class="line">    char *YUV = (char*)g_in + nStart;</span><br><span class="line">    char* RGB = (char*)g_out + nOut;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for (i = 0, j = 0; i &lt; (N &lt;&lt; 1); i += 4, j += 6)</span></span><br><span class="line">     <span class="comment">//&#123;</span></span><br><span class="line">       y0 = (unsigned char)YUV[i + <span class="number">0</span>];</span><br><span class="line">       u = (unsigned char)YUV[i + <span class="number">1</span>];</span><br><span class="line">       y1 = (unsigned char)YUV[i + <span class="number">2</span>];</span><br><span class="line">       v = (unsigned char)YUV[i + <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">       r = <span class="number">1.164</span>*(y0<span class="number">-16</span>) + <span class="number">1.159</span>*(v<span class="number">-128</span>);</span><br><span class="line">       g = <span class="number">1.164</span>*(y0<span class="number">-16</span>) - <span class="number">0.380</span>*(u<span class="number">-128</span>) + <span class="number">0.813</span>*(v<span class="number">-128</span>);</span><br><span class="line">       b = <span class="number">1.164</span>*(y0<span class="number">-16</span>) + <span class="number">2.018</span>*(u<span class="number">-128</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (r &gt; <span class="number">255</span>) r = <span class="number">255</span>;</span><br><span class="line">       <span class="keyword">if</span> (g &gt; <span class="number">255</span>) g = <span class="number">255</span>;</span><br><span class="line">       <span class="keyword">if</span> (b &gt; <span class="number">255</span>) b = <span class="number">255</span>;</span><br><span class="line">       <span class="keyword">if</span> (r &lt; <span class="number">0</span>) r = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (g &lt; <span class="number">0</span>) g = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (b &lt; <span class="number">0</span>) b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//YUV2RGB(y0, u, v, &amp;r, &amp;g, &amp;b);</span></span><br><span class="line">       RGB[j + <span class="number">0</span>] = r;</span><br><span class="line">       RGB[j + <span class="number">1</span>] = g;</span><br><span class="line">       RGB[j + <span class="number">2</span>] = b;</span><br><span class="line">       <span class="comment">//YUV2RGB(y1, u, v, &amp;r, &amp;g, &amp;b);</span></span><br><span class="line"></span><br><span class="line">       r = <span class="number">1.164</span>*(y1<span class="number">-16</span>) + <span class="number">1.159</span>*(v<span class="number">-128</span>);</span><br><span class="line">       g = <span class="number">1.164</span>*(y1<span class="number">-16</span>) - <span class="number">0.380</span>*(u<span class="number">-128</span>) + <span class="number">0.813</span>*(v<span class="number">-128</span>);</span><br><span class="line">       b = <span class="number">1.164</span>*(y1<span class="number">-16</span>) + <span class="number">2.018</span>*(u<span class="number">-128</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (r &gt; <span class="number">255</span>) r = <span class="number">255</span>;</span><br><span class="line">       <span class="keyword">if</span> (g &gt; <span class="number">255</span>) g = <span class="number">255</span>;</span><br><span class="line">       <span class="keyword">if</span> (b &gt; <span class="number">255</span>) b = <span class="number">255</span>;</span><br><span class="line">       <span class="keyword">if</span> (r &lt; <span class="number">0</span>) r = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (g &lt; <span class="number">0</span>) g = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (b &lt; <span class="number">0</span>) b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       RGB[j + <span class="number">3</span>] = r;</span><br><span class="line">       RGB[j + <span class="number">4</span>] = g;</span><br><span class="line">       RGB[j + <span class="number">5</span>] = b;</span><br><span class="line">     <span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>GPU</category>
        <category>Cuda</category>
      </categories>
      <tags>
        <tag>Cuda</tag>
        <tag>YUYV</tag>
        <tag>RGB</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCL-1-编程四大模型介绍</title>
    <url>/2017/08/28/GPU/OpenCL/OpenCL-1-%E5%9B%9B%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>本节介绍OpenCL的四个编程模型。</p>
<a id="more"></a>
<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h1><p>&emsp;&emsp;OPenCL作为开放性的异构计算的标准，支持的平台有CPU、GPU、DSP、FPGA。支持的设备如此不同，那么需要对它们有一个统一的分层、模型划分，才能让各家更好的实现–平台模型、执行模型、内存模型、编程模型。</p>
<h1 id="1-平台模型"><a href="#1-平台模型" class="headerlink" title="1.平台模型"></a>1.平台模型</h1><ul>
<li>OpenCL设备有两部分组成，宿主机和OpenCL设备<ul>
<li>宿主机负责整体流程控制，一般为CPU。</li>
<li>OpenCL设备主要负责数据运算操作。</li>
</ul>
</li>
<li>OpenCL设备内部由多个计算单元(CU)组成,每一个CU可以继续划分为处理单元(PU)。</li>
<li><strong>执行流程</strong>: 宿主机负责管理所有的OpenCL设备，宿主机发起计算任务，选择特定的OpenCL设备并建立计算环境。然后将计算任务和数据发送给OPenCL设备。设备调用内部计算单元进行计算，完成后将结果返还给宿主机，该次计算任务结束。</li>
</ul>
<h1 id="2-执行模型"><a href="#2-执行模型" class="headerlink" title="2.执行模型"></a>2.执行模型</h1><h2 id="2-1执行模型概念"><a href="#2-1执行模型概念" class="headerlink" title="2.1执行模型概念"></a>2.1执行模型概念</h2><p>&emsp;&emsp;OPenCL是一个主从处理模型，根本是宿主机如何利用OpenCL设备上大量的计算资源进行有效计算。所以OpenCL执行模型的任务就是<strong>如何高效地调用这些计算资源</strong>。</p>
<ul>
<li>宿主机将每一个处理单元(PE)分配一个索引号，这个唯一的索引号称为全局ID（Global ID），全体PE被看做一个工作空间的work-item。</li>
<li>因为我们可能处理数组、图形乃至三维图像，所以对应的工作空间也可以定义为一维、二维、三维。</li>
<li>为了更好的处理不同的数据，我们可以将工作空间进行粗粒度的划分，如将一部分ID划分到一组，这个组称为work-group,每一个组内也可以分配ID,不过这个ID称为局部ID（Local ID）。全局ID和局部ID存在映射关系。</li>
<li>OpenCL规范中使用一个长度为N的整数数组来描述工作空间的大小（N&lt;=3）。数组中的数值对应相应维度上工作点的个数。<ul>
<li>如果将我们常见的三维魔方想象成一个工作空间，那么一维即为红色的一行，即一维个数为3，二维为红色那个面，二维个数为9，三维即为整个工作空间，三维个数为27。</li>
</ul>
</li>
</ul>
<p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1516282831&di=e1a3b4daaf2435f61183fba516d8b739&imgtype=jpg&er=1&src=http%3A%2F%2Fpic.baike.soso.com%2Fp%2F20140514%2F20140514111325-626930652.jpg" alt="魔方"></p>
<h2 id="2-2上下文"><a href="#2-2上下文" class="headerlink" title="2.2上下文"></a>2.2上下文</h2><p>&emsp;&emsp;计算工作主要在OpenCL设备上进行，但宿主机也扮演着非常重要的角色。宿主机主要通过上下文(Context)管理OpenCL设备。上下文指的是所管理硬件和软件资源，如下所示：</p>
<ul>
<li>设备：OpenCL程序调用的计算设备</li>
<li>内核：在计算设备上执行的并行程序。</li>
<li>程序对象：内核程序的源代码(.cl文件)和可执行文件。</li>
<li>内存对象：计算设备执行OpenCL程序所需的变量。<br>上下文由宿主机使用API进行创建、管理、销毁。</li>
</ul>
<h2 id="2-3命令队列"><a href="#2-3命令队列" class="headerlink" title="2.3命令队列"></a>2.3命令队列</h2><p>&emsp;&emsp;宿主机主要通过命令对相应设备进行控制。根据计算量的大小，计算设备并不能立刻执行完被分配的计算任务。那么宿主机只能等着计算设备把任务计算完了才能继续分配新的任务么？显然不是，每一个计算设备都会有一个命令队列。<strong>命令队列只能管理一个计算设备</strong>。通过命令队列，就实现了宿主机和计算设备的异步控制与执行。</p>
<p>&emsp;&emsp;队列中的命令主要有三种：</p>
<ul>
<li>启动命令：OpenCL设备开始执行内核程序。</li>
<li>内存命令：在宿主机与内存设备之间移动数据，或者在两者之间进行内存映射。</li>
<li>同步命令：约束命令在计算设备上的执行：<ul>
<li>乱序执行： 命令按照在命令队列中的顺序进行发射，但不保证计算设备是按照这个顺序进行执行的。</li>
<li>有序执行： 命令按照在命令队列中的顺序进行发射和执行，上一条命令执行完成后才能发射下一条命令。</li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;宿主机程序可以为一个计算设备创建多个命令队列–<strong>一个计算设备可以有多个命令队列</strong>。这些命令队列没有关联。这也就意味着一个计算设备可以执行多个种类的任务，如小明可以在等待游戏加载的事件背几个英语单词 <del>_</del>。</p>
<h1 id="3-存储模型"><a href="#3-存储模型" class="headerlink" title="3.存储模型"></a>3.存储模型</h1><p>&emsp;&emsp;与通用计算程序的内存对象相似，OpenCL将设备中的存储器抽象成四层结构的存储模型：</p>
<ul>
<li>全局内存：工作空间中的所有节点都可以读写。（全局变量）</li>
<li>全局变量：工作空间中的所有节点都可以读，但不可以写。（全局常量）</li>
<li>本地内存：同一个工作组中的工作节点可以进行读写，对其他工作组不可见。不能通过宿主机进行初始化。（当前文件的全局变量）</li>
<li>私有内存：只属于工作节点。（函数中的局部变量）</li>
</ul>
<p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3991552943,3638402409&fm=27&gp=0.jpg" alt="内存模型"></p>
<p>在程序运行期间，需要宿主机和计算设备进行数据交换，存在两种方式：</p>
<ul>
<li>数据拷贝进行:将需要的数据拷贝到工作组空间，计算完成后再拷贝出去（传形参）</li>
<li>内存映射：将需要计算数据的地址传进去（传指针）</li>
</ul>
<h1 id="4-编程模型"><a href="#4-编程模型" class="headerlink" title="4.编程模型"></a>4.编程模型</h1><p>&emsp;&emsp;前面已经提到计算的时候可以按照两种模型来进行计算：数据并行和任务并行。</p>
<ul>
<li>数据并行：将需要计算的数据进行等分，分配给不同的计算设备进行计算。如需要进行两个很大矩阵的求和运算，那么就可以将矩阵数据分成几份，那么理论上计算事件缩减为原来的<code>1/N</code>。这适用与数据想关联不大的计算任务。</li>
<li>任务并行：如计算数据量不大，但每一个步骤前后依赖，如你必须先将水烧开才能下面条，如果你需要不断的煮面条，那么就可以将这个过程分成阶段，用好几个锅同时进行。具体细节参考工厂的流水线工作模式。</li>
</ul>
<p>&emsp;&emsp;既然有数据或任务的并行，那么同步就成为一个绕不开的节点。并行是指在计算设备执行内核的过程中，对于其他的节点是绝对独立的，互不影响。OpenCL有三种方式进行同步：</p>
<ul>
<li>同一个work-group的节点间进行数据同步。</li>
<li>同一个命令队列中的命令进行同步</li>
<li>同一个上下文中的命令队列进行同步。</li>
</ul>
<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>更多博主原创文章，请移步：</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>GPU</category>
        <category>OpenCL</category>
      </categories>
      <tags>
        <tag>OpenCL</tag>
        <tag>模型</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCL-0-基础概念</title>
    <url>/2017/08/26/GPU/OpenCL/OpenCL-0-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>OpenCL（全称Open Computing Language，开放运算语言）是第一个面向异构系统通用目的并行编程的开放式、免费标准。<br><img src="https://coderdock-1251264493.cos.ap-shanghai.myqcloud.com/OPenCL.png" alt="OpenCL"></p>
<a id="more"></a>

<h1 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1.是什么"></a>1.是什么</h1><p>&emsp;&emsp;OpenCL（全称Open Computing Language，开放运算语言）是第一个面向异构系统通用目的并行编程的开放式、免费标准。</p>
<p>&emsp;&emsp;有标准，就得有实现，目前而言，intel、Nvidia、ARM、AMD、QUALCOMM、Apple都有其对应的OpenCL实现。在这个系列中，我们着眼于OpenCL的语法以及编程概念。不去深究各家实现的异同。</p>
<p>&emsp;&emsp;我所使用的Nvidia的实现。在我的电脑上，显卡是 GTX-960M,去Nvidia官网下载相应的cuda-tool-kit进行安装，以及使用命令行安装<code>sudo apt-get install nvidia-opencl-dev  nvidia-opencl-icd-xxx</code>(xxx是与你的发行版本相对应的版本号，我的是384)。详细安装过程不再赘述。</p>
<ul>
<li><strong>异构</strong>：什么是异构，最简单的X86和ARM就是最明显的处理器架构，标准中说面向异构，那么也就是说只需要编写一次代码，就能够在不能的架构芯片上运行（功能怎么有点像JAVA）。</li>
<li><strong>并行</strong>: 我们总是希望能够有性能更高的的计算机。提高性能的方法之一是提高运行频率，不过现在各家的CPU在4GHZ都卡了脖子。另外一种方式就是，把任务分发出去，让不同的处理核心去进行。但如果处理不好，就成了简单的堆砌核心，形成<code>一核有难，七核围观</code>的尴尬局面。所有有的专家就经过研究后提出了<code>增加专门的处理单元，来提取异构单元中的每个并行项，是提升功率效率的唯一方法</code>。我对这句话的理解就是<code>农夫种田，渔民打鱼</code>，把合适的任务交给合适的处理单元来做，CPU处理控制，GPU处理大量简单的运算。所以此处的并行就是指<code>能够提取并行项，并正确处理</code>的意思。</li>
<li><strong>通用</strong>:既然说每一种架构都有其适合的处理任务类型，难道我要去学每一种架构的编程语言么，非也，这就是OpenCL做的事情。它向上提供统一的编程接口，下面的具体实现由各个厂商去实习。</li>
</ul>
<h1 id="2-学什么"><a href="#2-学什么" class="headerlink" title="2.学什么"></a>2.学什么</h1><ul>
<li>掌握所开发的异构系统的组成，(X86还是ARM总的分清吧，有几个核总得知道吧)</li>
<li>掌握这些设备的属性(最简单的CPU擅长逻辑，GPU擅长简单运算)。</li>
<li>使用合适的处理方式(任务并行或数据并行或两者兼有之)将任务进行分解，转化为具体架构平台上的指令(也称为内核)</li>
<li>建立用于计算的数据结构和内存对象</li>
<li>按照既定的顺序执行内核</li>
<li>核验结果</li>
</ul>
<h1 id="3-组成"><a href="#3-组成" class="headerlink" title="3.组成"></a>3.组成</h1><ul>
<li>平台模型： 可以理解为我们所用的主机，该主机可能包含多个OpenCL设备(CPU GPU),每一个设备可能包含多个计算单元（CU）,每一个计算单元又可能包含多个处理单元。</li>
<li>执行模型： OpenCL执行程序时，在主机上执行控制程序，分发内核（执行程序）到多个处理设备。</li>
<li>存储模型：根据实际的存储体系，OpenCL将内部存储器抽象成四层结构的存储器模型：全局内存、常量内存、本地内存、私有内存。</li>
<li>编程模型：数据并行、任务并行、二者混合。</li>
</ul>
<p>这一部分我们会在下一篇中进行详细解释。</p>
<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>GPU</category>
        <category>OpenCL</category>
      </categories>
      <tags>
        <tag>OpenCL</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCL-2-OpenCL事件</title>
    <url>/2017/09/02/GPU/OpenCL/OpenCL-2-OpenCL%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<p>本节介绍OpenCL的事件的相关知识。</p>
<a id="more"></a>

<p>&emsp;&emsp;由上一节我们已经清楚了宿主机通过命令队列向计算设备传递命令。计算设备计算后返回。但是宿主机需要管理多个计算设备，多个命令队列。那么宿主机是如何管理、调度这些对象的呢。没错，就是事件(event)。</p>
<h1 id="1-事件定义"><a href="#1-事件定义" class="headerlink" title="1.事件定义"></a>1.事件定义</h1><p>&emsp;&emsp;事件是与命令的状态相关联的对象。命令队列中的命令会产生事件，其他命令在执行之前需要等待某个事件。如我们下面条之前需要查看水开了没有，那么<code>水开了</code>就是一个事件。</p>
<p>根据场景的不同，可以分为内核端事件和宿主机端事件：</p>
<ul>
<li>内核端事件：主要负责异步执行命令的同步操作(多个处理单元的阶段同步)和全局内核和本地内存的同步。(内核端事件类似于<code>个人自扫门前雪</code>的意味，因为<code>人民内部矛盾内部解决嘛</code>)。</li>
<li>宿主机端事件：完成命令队列之间的同步操作(统筹各个计算设备的操作)。</li>
</ul>
<p>&emsp;&emsp;同时事件还可以划分为<code>命令事件</code>和<code>用户自定义事件</code>。</p>
<h1 id="2-事件分类"><a href="#2-事件分类" class="headerlink" title="2.事件分类"></a>2.事件分类</h1><h2 id="2-1命令事件"><a href="#2-1命令事件" class="headerlink" title="2.1命令事件"></a>2.1命令事件</h2><p>&emsp;&emsp;事件在命令之间传递状态信息。命令的状态即事件的值可以取以下：</p>
<ul>
<li>CL_QUEUED:命令已经加入命令队列。</li>
<li>CL_SUBMITTED:命令已经有宿主机提交给与所在命令队列相关联的设备。</li>
<li>CL_RUNNING:该命令正在执行。</li>
<li>CL_COMPLETE:命令已经完成</li>
<li>ERROR_CORE:负数，指代不同的错误情况。</li>
</ul>
<p>&emsp;&emsp;创建事件的方法有很多，最常见的还是命令在状态发生变化时。如下面的命令是将内核加入队列的API，那么就会产生一个<code>CL_QUEUED</code>命令。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">cl_int</span> <span class="string">clEnqueueNDRangeKernel(</span></span><br><span class="line">  <span class="attr">cl_command_queue</span> <span class="string">command_queue,</span></span><br><span class="line">  <span class="attr">cl_kernel</span> <span class="string">kernel,</span></span><br><span class="line">  <span class="attr">cl_unit</span> <span class="string">work_dim,</span></span><br><span class="line">  <span class="attr">const</span> <span class="string">size_t* global_work_offset,</span></span><br><span class="line">  <span class="attr">const</span> <span class="string">size_t* global_work_size,</span></span><br><span class="line">  <span class="attr">const</span> <span class="string">size_t* local_work_size,</span></span><br><span class="line">  <span class="attr">cl_uint</span> <span class="string">num_events_in_wait_list,</span></span><br><span class="line">  <span class="attr">const</span> <span class="string">cl_event* event_wait_list,</span></span><br><span class="line">  <span class="meta">cl_event*</span> <span class="string">event</span></span><br><span class="line">  <span class="attr">)</span></span><br></pre></td></tr></table></figure>
<p>我们着重关注一下后面三个参数：</p>
<ul>
<li><strong>num_events_in_wait_list</strong>:在执行这个命令之前需要等待几个事件。</li>
<li><strong>event_wait_list</strong>:这是一个列表，里面是要等待的具体事件。</li>
<li><strong>event</strong>：这个命令相关联的事件，如当前会将其赋值为<code>CL_QUEUED</code>,之后在执行的时候会赋值为<code>CL_RUNNING</code>等等。</li>
</ul>
<p>再看一下多个事件之间的联系的一个示例：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">cl_event k_events[<span class="number">2</span>];   <span class="comment">//定义两个事件</span></span><br><span class="line"><span class="function"><span class="title">clEnqueueNDRangeKernel</span>(<span class="params">command1, .... , 0, NULL, &amp;k_events[0]</span>)</span>;  <span class="comment">//将第一个命令加入队列，会对k_events[0]赋值，指向之前不需要等待任何事件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">clEnqueueNDRangeKernel</span>(<span class="params">command2, ...., 0, NULL, &amp;k_events[0]</span>)</span>;  <span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">clEnqueueNDRangeKernel</span>(<span class="params">command3, ...., 2,&amp;k_events, NULL</span>)</span>   <span class="comment">//执行这条命令时会等待前面的两个命令</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2用户自定义事件"><a href="#2-2用户自定义事件" class="headerlink" title="2.2用户自定义事件"></a>2.2用户自定义事件</h2><p>&emsp;&emsp;命令事件主要在命令队列中产生，影响同一个上下文的设备。如果我们需要与其他上下文进行同步，就需要使用到用户自定义事件：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">cl_event</span> <span class="selector-tag">clCreateUserEvent</span>(</span><br><span class="line">    cl_context context,     <span class="comment">//指定上下文</span></span><br><span class="line">    cl_uint* errcode_ret    <span class="comment">//该函数所关联的错误值</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>如果创建成功，errcode_ret会被赋值为<code>CL_SUCCESS</code>或者错误时，赋值为一下的值：</p>
<ul>
<li>CL_INVALID_EVENT:上下文不合法</li>
<li>CL_OUT_OF_RESOURCE: 资源未就绪或分配资源失败</li>
<li>CL_OUT_OF_HOST_MEMORY:宿主机资源未就绪或分配资源失败</li>
</ul>
<p>之后我们就可以在各个处理函数中设置返回的事件的值：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">cl_int</span> <span class="selector-tag">clSetUserEventStatus</span>(</span><br><span class="line">  cl_event event,       <span class="comment">//具体事件值</span></span><br><span class="line">  cl_int execution_status <span class="comment">//指向状态</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<h1 id="3-事件管理"><a href="#3-事件管理" class="headerlink" title="3.事件管理"></a>3.事件管理</h1><p>&emsp;&emsp;上面已经说过了用户自定义事件的设置，那么命令事件的管理又是通过那些API的呢？</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">clGetEventStatus</span><br><span class="line">clRetainEvent       <span class="comment">//增加引用计数，即得到事件</span></span><br><span class="line">cl_ReleaseEvent     <span class="comment">//减少引用计数</span></span><br></pre></td></tr></table></figure>
<p>当然如果需要获取事件的更详细的信息，需要用到：</p>
<figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line">cl<span class="number">_</span>int clGetEventInfo(</span><br><span class="line">  cl<span class="number">_</span>event event,           <span class="comment">//具体事件</span></span><br><span class="line">  cl<span class="number">_</span>event<span class="number">_</span>info param<span class="number">_n</span>ame, <span class="comment">//查询的信息，如命令队列，或者上下文</span></span><br><span class="line">  size<span class="number">_</span>t param<span class="number">_</span><span class="keyword">value</span><span class="number">_</span>size,  <span class="comment">//参数大小，</span></span><br><span class="line">  <span class="keyword">void</span>* param<span class="number">_</span><span class="keyword">value</span>,        <span class="comment">//指向的结果的指针</span></span><br><span class="line">  size<span class="number">_</span>t param<span class="number">_</span><span class="keyword">value</span><span class="number">_</span>size<span class="number">_</span>ret <span class="comment">//返回结果的大小</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<h1 id="4-事件回调"><a href="#4-事件回调" class="headerlink" title="4.事件回调"></a>4.事件回调</h1><p>&emsp;&emsp;事件是OpenCL中为命令指定明确顺序约束的机制。不过事件不能跨上下文，跨上下文边界时，只有一种选择，就是让宿主机帮忙等待一个事件，然后使用用户事件触发另一个上下文命令的执行。总而言之，由于事件不能跨上下文，所以宿主机必须代表两个命令队列在两个上下文之间管理事件。</p>
<p>&emsp;&emsp;同时，事件还可以使用OpenCL定义的回调机制与宿主机上的函数进行交互。回调就是应用程序异步调用的函数。</p>
<p>我们可以使用下面这个函数设置回调：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">cl_int</span> <span class="string">clSetEventCallback(</span></span><br><span class="line">  <span class="attr">cl_event</span> <span class="string">event,</span></span><br><span class="line">  <span class="attr">cl_int</span> <span class="string">command_exec_callback_type,</span></span><br><span class="line">  <span class="meta">void(CL_CALLBACK</span> <span class="string">*pfn_event_notify)(</span></span><br><span class="line">    <span class="attr">cl_event</span> <span class="string">event,</span></span><br><span class="line">    <span class="attr">cl_int</span> <span class="string">event_command_exec_status,</span></span><br><span class="line">    <span class="attr">void</span> <span class="string">*user_data),</span></span><br><span class="line">    <span class="attr">void</span> <span class="string">*user_data</span></span><br><span class="line">  <span class="attr">)</span></span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ul>
<li>撤销一个事件之前，与这个事件所关联的所有回调函数必须撤销，</li>
<li>回调函数不能是代价高昂的的处理函数，或者调用OpenCL的API来创建上下文或命令队列，或者调用阻塞函数。</li>
<li>为一个事件状态注册的多个回调函数，但不能保证按照注册的顺序执行。</li>
<li>回调函数应保证是线程安全的，会被异步调用。</li>
</ul>
<h1 id="5-内核事件"><a href="#5-内核事件" class="headerlink" title="5.内核事件"></a>5.内核事件</h1><p>&emsp;&emsp;上面的命令、事件都是要与命令队列相关联。可以同步命令，有助于命令与宿主机之间的交互提供细粒度的控制。</p>
<p>&emsp;&emsp;那么内核中是否有相同的机制呢？其实事件还可以出现在内核内部，内核中的事件主要用来支持在全局与局部内存之间的异步数据复制。下面这些函数用以支持这些功能。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">event_t</span> <span class="title">async_work_group_copy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">event_t</span> async_work_group_strided_copy</span></span><br><span class="line"><span class="function"><span class="keyword">event_t</span> wait_group_events</span></span><br></pre></td></tr></table></figure>
<p>会在后面的章节有所介绍。</p>
<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>GPU</category>
        <category>OpenCL</category>
      </categories>
      <tags>
        <tag>OpenCL</tag>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCL-3-同步机制</title>
    <url>/2017/09/06/GPU/OpenCL/OpenCL-3-%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>由于OpenCL在异构系统上进行计算，需要管理并调度多个设备，就需要在设备之间内部或外部进行数据交互以及同步。</p>
<a id="more"></a>
<h1 id="1-同步类型"><a href="#1-同步类型" class="headerlink" title="1.同步类型"></a>1.同步类型</h1><p>&emsp;&emsp;根据同步的类型，同步分为两部分：宿主机端同步和设备端同步。</p>
<h1 id="2-设备端同步"><a href="#2-设备端同步" class="headerlink" title="2.设备端同步"></a>2.设备端同步</h1><p>&emsp;&emsp;设备端同步主要指同一个内核内不同线程之前的同步，主要用于保证数据的一致性。根据工作组的划分，可以细分为组内同步和全局同步。</p>
<h2 id="2-1组内同步"><a href="#2-1组内同步" class="headerlink" title="2.1组内同步"></a>2.1组内同步</h2><p>&emsp;&emsp;OpenCL采用宽松的同步模型和内存一致性模型。通常来说，采用硬件实现能够最好的实现同步，但是作为一个跨平台的API,并不能完全实现这些特性。所以OpenCL的解决方案是让程序员明确的知道当前系统的状态，添加同步点，从而可以依据这些信息获取预期行为。</p>
<p>&emsp;&emsp;在x86(CPU)平台上，我们使用同步机制如果条件还未满足，我们可以使系统进入休眠等待条件满足。但是GPU上的线程与系统层级的线程不是一个概念，GPU的线程所占用的资源是固定的，不能释放的，这也就导致了如果不同的不同work group不能为同一个资源做同步，因为没有释放的概念，所以必然存在死锁的状态。所以只能组内同步。</p>
<p>&emsp;&emsp;组内同步的机制是<code>barrier</code>,即屏障，在组内所有的item没有到达这个barrier之前，所有的item是不想下执行的。</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">  item1</span><br><span class="line">    |<span class="string">       item2</span></span><br><span class="line"><span class="string">    </span>|<span class="string">         </span>|<span class="string">       item3</span></span><br><span class="line"><span class="string">    </span>|<span class="string">         </span>|<span class="string">         </span>|</span><br><span class="line">    |<span class="string"> 5s      </span>|<span class="string">4s       </span>|<span class="string"> 3s</span></span><br><span class="line"><span class="string">    </span>|<span class="string">         </span>|<span class="string">         </span>|</span><br><span class="line">------------------------------ 所有达到 barrier之后，同时出发</span><br><span class="line">    |<span class="string">         </span>|<span class="string">         </span>|</span><br><span class="line">    |<span class="string">         </span>|<span class="string">         </span>|</span><br></pre></td></tr></table></figure>
<h2 id="2-2全局同步"><a href="#2-2全局同步" class="headerlink" title="2.2全局同步"></a>2.2全局同步</h2><p>&emsp;&emsp;目前OpenCL不支持与组内同步类似的全局同步方式（原因上方已经介绍）。可以通过<code>global fence</code>以及原子操作来达到目的。</p>
<h1 id="3-宿主机端同步"><a href="#3-宿主机端同步" class="headerlink" title="3.宿主机端同步"></a>3.宿主机端同步</h1><p>&emsp;&emsp;OpenCL是基于任务并行，主机控制的模型，其中每一项任务都是数据并行的，具体通过使用和设备关联的线程安全的命令队列来实现。当然，内核、数据以及其他操作并不是简单调用来进行的，而是通过异步加入指定的队列中。</p>
<p>&emsp;&emsp;从宿主机角度来看，保证宿主机同步的要点有一下三条：</p>
<ul>
<li>调用clFinish函数，该函数将阻塞直至命令队列中的所有命令都执行完毕。</li>
<li>等待一个特定事件的完成</li>
<li>执行一个阻塞操作</li>
</ul>
<p>当然，根据所需要同步的计算设备的个数，可以分为<code>单设备同步</code>和<code>多设备同步</code>。</p>
<h2 id="3-1单设备同步"><a href="#3-1单设备同步" class="headerlink" title="3.1单设备同步"></a>3.1单设备同步</h2><h3 id="3-1-1设置barrier"><a href="#3-1-1设置barrier" class="headerlink" title="3.1.1设置barrier"></a>3.1.1设置barrier</h3><p>clFinish可以阻塞程序的执行直到命令队列中的所有命令都执行完成。但是这只是相当于在末尾加上了一个barrier。在中间加入barrier需要调用如下函数：</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">cl_int</span> <span class="function"><span class="title">clEnqueueBarrier</span>(</span></span><br><span class="line"><span class="function">  <span class="variable">cl_command_queue</span> <span class="variable">command_queue</span></span></span><br><span class="line"><span class="function">  )</span></span><br></pre></td></tr></table></figure>
<h3 id="3-1-2等待事件"><a href="#3-1-2等待事件" class="headerlink" title="3.1.2等待事件"></a>3.1.2等待事件</h3><p>&emsp;&emsp;等待事件，即将一个等待事件加入命令队列，只有这个等待事件满足以后，才能执行之后加入的命令，使用的命令如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">cl_int</span> <span class="string">clEnqueueWaitForEvents(</span></span><br><span class="line">  <span class="attr">cl_command_queue</span> <span class="string">command_queue,</span></span><br><span class="line">  <span class="attr">cl_uint</span> <span class="string">num_events,</span></span><br><span class="line">  <span class="attr">const</span> <span class="string">cl_event* event_list</span></span><br><span class="line">  <span class="attr">)</span></span><br></pre></td></tr></table></figure>
<p>从变量定义上很好理解，不再赘述。</p>
<h3 id="3-1-3阻塞访问"><a href="#3-1-3阻塞访问" class="headerlink" title="3.1.3阻塞访问"></a>3.1.3阻塞访问</h3><p>&emsp;&emsp;我们在进行网络访问或者进行IO读取的时候是如何进行阻塞与非阻塞的区分的呢，没错，往往是传入一个标志。对于OpenCL也是一样的，如：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">clEnqueReadBuffer</span>(<span class="params">que, CL_TRUEm....</span>)</span></span><br></pre></td></tr></table></figure>
<p>上面这个示例的第二个参数就是指定这个函数是否是同步操作，如果为TRUE，那么就会阻塞直至拷贝完成，如果为FALSE，在设置完后不等拷贝完成，就会返回。</p>
<h2 id="3-2多设备同步"><a href="#3-2多设备同步" class="headerlink" title="3.2多设备同步"></a>3.2多设备同步</h2><p>&emsp;&emsp;在之前我们已经了解到，使用事件只能在同一个上下文中实现同步。那么在不同的设备不同的上下文中如何实现同步呢，只剩下了一种方法，cFinish,等待另一个命令队列执行完成，之后的命令才能继续执行。如一个CPU一个GPU，两者需要互相访问彼此的数据，那么如何实现同步呢，如果CPU要访问CPU的数据，必须等待CPU当前的命令队列执行完成，不再占用内存，GPU才能进行访问。<br><img src="https://coderdock-1251264493.cos.ap-shanghai.myqcloud.com/sync.png" alt="同步"></p>
<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>GPU</category>
        <category>OpenCL</category>
      </categories>
      <tags>
        <tag>OpenCL</tag>
        <tag>同步</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCL-4-小试牛刀</title>
    <url>/2017/09/14/GPU/OpenCL/OpenCL-4-%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80/</url>
    <content><![CDATA[<p>前四章已经讲了那么多的概念，下面该真刀真枪地试一试了。</p>
<a id="more"></a>
<p>下面是宿主机端程序:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;OpenCL/opencl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CL/cl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SOURCE_SIZE (0x100000)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建2个输入向量</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> LIST_SIZE=<span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">int</span> *A=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*LIST_SIZE);</span><br><span class="line">    <span class="keyword">int</span> *B=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*LIST_SIZE);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;LIST_SIZE; i++) &#123;</span><br><span class="line">        A[i]=i;</span><br><span class="line">        B[i]=LIST_SIZE-i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//载入内核源码到source_str</span></span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> *source_str;</span><br><span class="line">    <span class="keyword">size_t</span> source_size;</span><br><span class="line">    fp=fopen(<span class="string">"vector_add_kernel.cl"</span>,<span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to load kernel\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    source_str=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(MAX_SOURCE_SIZE);</span><br><span class="line">    source_size=fread(source_str,<span class="number">1</span>,MAX_SOURCE_SIZE,fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="comment">//获得平台和设备信息</span></span><br><span class="line">    cl_platform_id platform_id=<span class="literal">NULL</span>;</span><br><span class="line">    cl_device_id device_id=<span class="literal">NULL</span>;</span><br><span class="line">    cl_uint ret_num_devices;</span><br><span class="line">    cl_uint ret_num_platforms;</span><br><span class="line">    cl_int ret=clGetPlatformIDs(<span class="number">1</span>, &amp;platform_id, &amp;ret_num_platforms);</span><br><span class="line">    ret=clGetDeviceIDs(platform_id, CL_DEVICE_TYPE_DEFAULT, <span class="number">1</span>, &amp;device_id, &amp;ret_num_devices);</span><br><span class="line">    <span class="comment">//创建OpenCL上下文</span></span><br><span class="line">    cl_context context=clCreateContext(<span class="literal">NULL</span>,<span class="number">1</span>,&amp;device_id,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;ret);</span><br><span class="line">    <span class="comment">//创建命令队列</span></span><br><span class="line">    cl_command_queue command_queue=clCreateCommandQueue(context,device_id,<span class="number">0</span>,&amp;ret);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建内存缓冲对象，在设备上为每个向量</span></span><br><span class="line">    cl_mem a_mem_obj=clCreateBuffer(context,CL_MEM_READ_ONLY,</span><br><span class="line">            LIST_SIZE*<span class="keyword">sizeof</span>(<span class="keyword">int</span>),<span class="literal">NULL</span>,&amp;ret);</span><br><span class="line">    cl_mem b_mem_obj=clCreateBuffer(context,CL_MEM_READ_ONLY,</span><br><span class="line">            LIST_SIZE*<span class="keyword">sizeof</span>(<span class="keyword">int</span>),<span class="literal">NULL</span>,&amp;ret);</span><br><span class="line">    cl_mem c_mem_obj=clCreateBuffer(context,CL_MEM_WRITE_ONLY,</span><br><span class="line">    LIST_SIZE*<span class="keyword">sizeof</span>(<span class="keyword">int</span>),<span class="literal">NULL</span>,&amp;ret);</span><br><span class="line">    <span class="comment">//拷贝数据A和B到对应的内存缓冲</span></span><br><span class="line">    ret=clEnqueueWriteBuffer(command_queue,a_mem_obj,CL_TRUE,<span class="number">0</span>,</span><br><span class="line">    LIST_SIZE*<span class="keyword">sizeof</span>(<span class="keyword">int</span>),A,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    ret=clEnqueueWriteBuffer(command_queue,a_mem_obj,CL_TRUE,<span class="number">0</span>,</span><br><span class="line">    LIST_SIZE*<span class="keyword">sizeof</span>(<span class="keyword">int</span>),B,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建程序</span></span><br><span class="line">    cl_program program=clCreateProgramWithSource(context,<span class="number">1</span>,</span><br><span class="line">    (<span class="keyword">const</span> <span class="keyword">char</span>**)&amp;source_str,(<span class="keyword">const</span> <span class="keyword">size_t</span>*)&amp;source_size, &amp;ret);</span><br><span class="line">    <span class="comment">//构建程序</span></span><br><span class="line">    ret=clBuildProgram(program,<span class="number">1</span>,&amp;device_id,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//创建OpenCL内核</span></span><br><span class="line">    cl_kernel kernel=clCreateKernel(program,<span class="string">"vector_add"</span>,&amp;ret);</span><br><span class="line">    <span class="comment">//设置内核参数</span></span><br><span class="line">    ret=clSetKernelArg(kernel,<span class="number">0</span>,<span class="keyword">sizeof</span>(cl_mem),(<span class="keyword">void</span>*)&amp;a_mem_obj);</span><br><span class="line">    ret=clSetKernelArg(kernel,<span class="number">1</span>,<span class="keyword">sizeof</span>(cl_mem),(<span class="keyword">void</span>*)&amp;b_mem_obj);</span><br><span class="line">    ret=clSetKernelArg(kernel,<span class="number">2</span>,<span class="keyword">sizeof</span>(cl_mem),(<span class="keyword">void</span>*)&amp;c_mem_obj);</span><br><span class="line">    <span class="comment">//执行内核</span></span><br><span class="line">    <span class="keyword">size_t</span> global_item_size=LIST_SIZE;  <span class="comment">//处理整个列表</span></span><br><span class="line">    <span class="keyword">size_t</span> local_item_size=<span class="number">64</span>;          <span class="comment">//分割为64个组</span></span><br><span class="line">    ret=clEnqueueNDRangeKernel(command_queue,kernel,<span class="number">1</span>,<span class="literal">NULL</span>,</span><br><span class="line">    &amp;global_item_size,&amp;local_item_size,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//读取内存缓冲C到本地变量C</span></span><br><span class="line">    <span class="keyword">int</span> *C=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*LIST_SIZE);</span><br><span class="line">    ret=clEnqueueReadBuffer(command_queue,c_mem_obj,CL_TRUE,<span class="number">0</span>,</span><br><span class="line">    LIST_SIZE*<span class="keyword">sizeof</span>(<span class="keyword">int</span>),C,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//显示结果</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;LIST_SIZE; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d + %d = %d\n"</span>, A[i], B[i], C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//清理资源</span></span><br><span class="line">    ret=clFlush(command_queue);</span><br><span class="line">    ret=clFinish(command_queue);</span><br><span class="line">    ret=clReleaseKernel(kernel);</span><br><span class="line">    ret=clReleaseProgram(program);</span><br><span class="line">    ret=clReleaseMemObject(a_mem_obj);</span><br><span class="line">    ret=clReleaseMemObject(b_mem_obj);</span><br><span class="line">    ret=clReleaseMemObject(c_mem_obj);</span><br><span class="line">    ret=clReleaseCommandQueue(command_queue);</span><br><span class="line">    ret=clReleaseContext(context);</span><br><span class="line">    <span class="built_in">free</span>(A);</span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">    <span class="built_in">free</span>(C);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是内核程序（vector_add_kernel.cl）:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">__kernel void vector<span class="constructor">_add(<span class="params">__global</span> <span class="params">const</span> <span class="params">int</span> <span class="operator">*</span>A, <span class="params">__global</span> <span class="params">const</span> <span class="params">int</span> <span class="operator">*</span>B, <span class="params">__global</span> <span class="params">int</span> <span class="operator">*</span>C)</span> &#123;</span><br><span class="line">    <span class="comment">//获得当前要处理元素的索</span></span><br><span class="line">    <span class="built_in">int</span> i=get<span class="constructor">_global_id(0)</span>;</span><br><span class="line">    <span class="comment">//做计算</span></span><br><span class="line">    C<span class="literal">[<span class="identifier">i</span>]</span>=A<span class="literal">[<span class="identifier">i</span>]</span>+B<span class="literal">[<span class="identifier">i</span>]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后使用命令：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">gcc -o <span class="keyword">Test</span> <span class="keyword">Test</span>.c -I&lt;Header_to_OpenCL_Path&gt;</span><br></pre></td></tr></table></figure>
<p>进行编译。</p>
<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>GPU</category>
        <category>OpenCL</category>
      </categories>
      <tags>
        <tag>OpenCL</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL是什么</title>
    <url>/2018/06/10/GPU/OpenGL/OpenGL-0-OpenGL%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>对OpenGL有一个大概的认识！</p>
<a id="more"></a>


<p>今天是我们OpenGL 系列教程的第零讲。在后面的教程我们中会讲述OPenGL工作的详细流程以及原理，以及怎么使用OpenGL，这一听起来很牛叉的东西。 现在我们先来大概认识一下openGL到底是个什么东东。OpenGL的全称是 Open Graphic Library, 即 开放的图像库。图形库嘛，就是用来显示图形的程序。我们都知道，再复杂的图形都是由点 线 面 三种元素构成的，而OpenGL就是使用GPU、显卡来绘制这些基础元素的，从而组成我们看到的的各种图形。话说在很久以前，老王在他们软件公司是负责开发软件图形界面的，总是调用 Nvidia、Intel、AMD提供的GPU驱动进行软件图形的编程，但是三家的实现思路不一致，老李家的驱动画一个矩形要传入 X 、Y、宽度、 高度这四个参数、 但是呢、老赵家却要传入传入左上角的 X、Y以及右下角的 X、Y。 这让老王那个烦啊，搞得他那个生活都不和谐了。于是他就去了老赵，老李家，打算跟他们商量一下统一调用的问题、恰巧老赵老李不在家，只有他俩媳妇儿在家，于是。。 老王就走了。。。。改天再来。后来呢，老王就根据自己丰富的图形编程经验，给老赵老李出了一个参考标准，其实呢、就是一个头文件，这里边规定了一个函数实现什么功能，传入什么样的参数，并且对他们说，你们谁实现的好，我就多买谁家的GPU。于是呢 ，老王从此以后，只要写一套程序就可以运行在所有的GPU上了。老王呢就是 KHRONOS,这里我们不多做介绍，只需要知道从此我们使用GPU进行图形编程，只需要调用openGL就可以实现同样的效果就可以了。</p>
<p>一套API,就是说，包含同一个头文件，调用各个显卡厂商提供的驱动函数，就可以实现同样的功能，。</p>
<p>一套标准，就是说，这个标准对大多数的硬件都是适用的，正如这张图里所展示的，所有的接口都是规定好的,无论我们买哪一家的内存，都是可以直接插上去使用的。对于软件也是如此。大多数的显卡厂商都实现了这个API，业内进行GPU图形编程的时候、首先想到的应该是opengl。 等等，为什么是应该，因为在Windows上还有DirectX 以及最近的新标准 ValKan,不过这是后话，我们这里不多说。</p>
<p>但是当我们提到 OpenGL,又会听 openGL 2.0    3.0  openGL ES 2.0  OpenGL ES 3.0, 那么他们之前有什么区别呢。2.0 和 3.0 主要区别就是，3.0比2.0多了1.0，其次才是进行了一些支持特性上的升级，Dock本人知道的也不太多，就不卖弄呢，只需要知道3.0比2.0更高级，但是 3.0的一些高级新特性显卡厂商还没有进行完全支持。 ES主要就是指 Emebed System , 顾名思义，就是针对针对手机、PDA和游戏主机等<a href="https://baike.baidu.com/item/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E5%A4%87" target="_blank" rel="noopener">嵌入式设备</a>而设计的。  是 <a href="https://baike.baidu.com/item/OpenGL" target="_blank" rel="noopener">OpenGL</a>三维图形 API 的子集，我们的安卓手机，Iphone手机就是运行的 ES版本。 那么 固定管线和非固定管线有什么区别呢，</p>
<p>假如你的面前有一条河，固定管线就相当于由一个老伯乘着船将你们渡过去， 来了牛，度过去，来了车， 度过去， 来了老王、度过去、来了老王媳妇儿、。。。 渡过出去。可以看出，功能比较单一。但是呢，非固定管线就不一样了，我们可以从桥上边开车过去，可以骑车过去。可以跑过去，甚至呢，滚过去都可以、非固定管线不再提供固定功能-这里就是指撑船的老伯，而是建好一个通道，让你自己决定 怎么过去。那么我们怎么过去的方式就是Shader,我们自己编写的运行在GPU上的程序。关于Shader怎么写，我们会在后续的章节中详细介绍。</p>
<p>使用 OpenGL 我们可以在几乎你能想到的所有操作系统上写出绚丽多彩，运行高效的程序！</p>
<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>GPU</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>Vivado-HLS--操作流程</title>
    <url>/2017/11/07/Zynq/Vivado/Vivado-HLS-%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>Zynq</category>
        <category>Vivado</category>
      </categories>
      <tags>
        <tag>vivado</tag>
        <tag>hls</tag>
      </tags>
  </entry>
  <entry>
    <title>打造自己的VIM编辑器</title>
    <url>/2017/02/25/%E6%97%A5%E5%B8%B8/Tools/Dock%E5%B7%A5%E5%85%B7-%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84VIM%E7%BC%96%E8%BE%91%E5%99%A8/</url>
    <content><![CDATA[<ul>
<li>作为一个经常在Linux下开发的程序员，怎么能没有自己<strong><em>高逼格</em></strong>的VIM编辑器呢？<br>在这片教程中会一步步的搭建起自己的高逼格VIM！<a id="more"></a>

</li>
</ul>
<h2 id="1-主题"><a href="#1-主题" class="headerlink" title="1. 主题"></a>1. 主题</h2><p>&emsp;&emsp;刀客喜欢的主题有两个：<strong>molokai</strong> 、<strong>Solarized</strong></p>
<h3 id="1-1-molokai"><a href="#1-1-molokai" class="headerlink" title="1.1 molokai"></a>1.1 molokai</h3><p>&emsp;&emsp;molokai的特点是色彩艳丽，设置为暗色背景很适合程序员开发。<br>并且网上的教程都是使用Bundle进行安装，但刀客尝试后发现自己无法正常安装。还是一步步的从GIt进行安装更靠谱点。</p>
<blockquote>
<ul>
<li>git clone <a href="mailto:git@github.com">git@github.com</a>:tomasr/molokai.git</li>
<li>将colors 文件夹的molokai.vim 拷贝到~/.vim/colors</li>
<li>在~/.vimrc中添加如下语句：</li>
</ul>
</blockquote>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">colorscheme  molokai</span><br><span class="line"><span class="builtin-name">set</span> <span class="attribute">t_Co</span>=256</span><br><span class="line"><span class="builtin-name">set</span> <span class="attribute">background</span>=dark</span><br></pre></td></tr></table></figure>

<p>噔噔噔噔！打开vim编辑器是不是变得很炫酷了？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7774609-8bcbc88a48fcc65e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tool-molokai.png"></p>
<h3 id="1-2-Solarized"><a href="#1-2-Solarized" class="headerlink" title="1.2 Solarized"></a>1.2 Solarized</h3><p>&emsp;&emsp;Solarized主题是使用最广泛的vim主题。但刀客还是更喜欢molokai一点。</p>
<blockquote>
<ul>
<li>git clone <a href="mailto:git@github.com">git@github.com</a>/altercation/vim-colors-solarized</li>
<li>将colors 文件夹的molokai.vim 拷贝到~/.vim/colors</li>
<li>在~/.vimrc中添加如下语句：</li>
</ul>
</blockquote>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">syntax enable</span><br><span class="line"><span class="builtin-name">set</span> <span class="attribute">background</span>=dark</span><br><span class="line">colorscheme solarized</span><br></pre></td></tr></table></figure>

<p>快快地打开你的vim编辑器看一下吧。</p>
<h2 id="2-VIM-安装"><a href="#2-VIM-安装" class="headerlink" title="2. VIM 安装"></a>2. VIM 安装</h2><ul>
<li>作为一个程序员怎么能够不会使用源码这么高（苦）大（逼）的软件安装方式呢？好吧！是因为我要安装YCM(YouCompleteMe)代码自动不全工具需要Python的支持，但通过命令行安装的VIM一般不支持Python。</li>
</ul>
<h3 id="2-1-卸载VIM"><a href="#2-1-卸载VIM" class="headerlink" title="2.1 卸载VIM"></a>2.1 卸载VIM</h3><p>&emsp;&emsp;如果你的电脑上安装着vim,你需要完全卸载之前的VIM,方法很简单也很粗暴：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> <span class="builtin-name">remove</span> vimsudo apt-<span class="builtin-name">get</span> <span class="builtin-name">remove</span> vim-runtime</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> <span class="builtin-name">remove</span> vim -tiny</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> <span class="builtin-name">remove</span> vim-common</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> <span class="builtin-name">remove</span> vim-doc</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> <span class="builtin-name">remove</span> vim-script</span><br></pre></td></tr></table></figure>
<p>保证把vim卸载的渣渣都不剩。</p>
<h3 id="2-2-安装"><a href="#2-2-安装" class="headerlink" title="2.2 安装"></a>2.2 安装</h3><p>&emsp;&emsp;先安装一下依赖吧，很简单,反正也不多：</p>
<figure class="highlight q"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install libncurses5-<span class="built_in">dev</span> libgnome2-<span class="built_in">dev</span> libgnomeui-<span class="built_in">dev</span> libgtk2<span class="number">.0</span>-<span class="built_in">dev</span></span><br><span class="line"> libatk1<span class="number">.0</span>-<span class="built_in">dev</span> libbonoboui2-<span class="built_in">dev</span> libcairo2-<span class="built_in">dev</span> libx11-<span class="built_in">dev</span> libxpm-<span class="built_in">dev</span> libxt-<span class="built_in">dev</span></span><br><span class="line"> python-<span class="built_in">dev</span> python3-<span class="built_in">dev</span> ruby-<span class="built_in">dev</span>  liblua5<span class="number">.1</span>-<span class="built_in">dev</span> libperl-<span class="built_in">dev</span> git</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;然后下载vim,之后进行配置、编译、安装，三板斧嘛，开始：</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~</span><br><span class="line">git clone https:<span class="string">//github.com/vim/vim.git</span></span><br><span class="line"><span class="keyword">cd</span> vim</span><br><span class="line"><span class="string">./configure</span> <span class="params">--with-features=huge</span> \</span><br><span class="line">            <span class="params">--enable-multibyte</span> \</span><br><span class="line">            <span class="params">--enable-rubyinterp=yes</span> \</span><br><span class="line">            <span class="params">--enable-pythoninterp=yes</span> \</span><br><span class="line">            <span class="params">--with-python-config-dir=/usr/lib/python2</span>.7/config-x86_64-linux-gnu \</span><br><span class="line">            <span class="params">--enable-python3interp=yes</span> \</span><br><span class="line">            <span class="params">--with-python3-config-dir=/usr/lib/python3</span>.5/config-3.5m-x86_64_linux-gnu \</span><br><span class="line">            <span class="params">--enable-perlinterp=yes</span> \</span><br><span class="line">            <span class="params">--enable-luainterp=yes</span> \</span><br><span class="line">            <span class="params">--enable-gui=gtk2</span> <span class="params">--enable-cscope</span> <span class="params">--prefix=/usr</span></span><br><span class="line">make VIMRUNTIMEDIR=<span class="string">/usr/share/vim/vim80</span></span><br><span class="line"><span class="keyword">cd</span> ~<span class="string">/vim</span></span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p><strong>齐活</strong>！</p>
<h2 id="3-安装YCM"><a href="#3-安装YCM" class="headerlink" title="3.安装YCM"></a>3.安装YCM</h2><p>&emsp;&emsp;VIM被称为编辑器之神，而YCM则是vim中最难装的插件，简直就是<strong><em>神的脚后跟</em></strong>。<br>在网上搜索YCM的安装，基本都是使用Bundle安装，可是我试了好几次还是安装不上。算了还是苦逼地从源码安装吧。</p>
<p>&emsp;&emsp;经过刀客我的尝试，终于从源码安装上了YCM!</p>
<h3 id="3-1-下载YCM"><a href="#3-1-下载YCM" class="headerlink" title="3.1 下载YCM"></a>3.1 下载YCM</h3><p>&emsp;&emsp;首先将YCM从git下载到本地，我选了 <code>~/.vim/bundle/</code>。因为之前通过Bundle安装没有成功，正好有这么一个文件夹，没有的自己见一个就是了。。。。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载 （在 `～/.vim/bundle` 目录下）</span></span><br><span class="line">git <span class="keyword">clone</span> <span class="title">--recursive</span> git@github.com/Valloric/YouCompleteMe.git</span><br><span class="line"><span class="comment"># 检查完整性（在 `～/.vim/bundle/YouCompleteMe` 目录下）</span></span><br><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>
<p>这样就开始编译安装了是么？ NO No NO!,我们还需要安装依赖呢</p>
<figure class="highlight q"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line">sudo apt-<span class="built_in">get</span> install llvm<span class="number">-5.0</span> clang<span class="number">-5.0</span> libclang<span class="number">-5.0</span>-<span class="built_in">dev</span>  libboost-<span class="built_in">all</span>-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure>
<p>我统一选择了5.0版本，你要根据自己的软件源里的版本进行安装哦。</p>
<h3 id="3-3-编译安装"><a href="#3-3-编译安装" class="headerlink" title="3.3 编译安装"></a>3.3 编译安装</h3><p>在家目录下新建一个安装目录，然后进行执行一下命令：</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">mkdir ~<span class="string">/.ycm_build</span></span><br><span class="line"><span class="keyword">cd</span> ~<span class="string">/.ycm_build</span></span><br><span class="line">cmake -G <span class="string">"Unix Makefiles"</span> -DUSE_SYSTEM_BOOST=ON -DUSE_SYSTEM_LIBCLANG=ON . ~<span class="string">/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp</span></span><br><span class="line">cmake -G <span class="string">"Unix Makefiles"</span> -DUSE_SYSTEM_BOOST=ON -DEXTERNAL_LIBCLANG_PATH=<span class="string">/usr/lib/x86_64-linux-gnu/libclang-5.0.so</span> . ~<span class="string">/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp</span></span><br><span class="line">cmake <span class="params">--build</span> . <span class="params">--target</span> ycm_core <span class="params">--config</span> Release</span><br></pre></td></tr></table></figure>
<p>将配置文件拷贝到 <code>~/.vim</code></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">cp ~<span class="regexp">/.vim/</span>bundle<span class="regexp">/YouCompleteMe/</span>third_party<span class="regexp">/ycmd/</span>examples<span class="regexp">/.ycm_extra_conf.py ~/</span>.vim<span class="regexp">/</span></span><br></pre></td></tr></table></figure>
<p>最后在 <code>~/.vimrc</code>中添加以下语句：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_server_python_interpreter</span>=<span class="string">'/usr/bin/python'</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_global_ycm_extra_conf</span>=<span class="string">'~/.vim/.ycm_extra_conf.py'</span></span><br></pre></td></tr></table></figure>
<p>打开你的编辑器看一下吧！<br><img src="https://upload-images.jianshu.io/upload_images/7774609-9b58618ebfbb8067.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tool-YCM.png"></p>
<h2 id="4-安装ctags和taglist"><a href="#4-安装ctags和taglist" class="headerlink" title="4.安装ctags和taglist"></a>4.安装ctags和taglist</h2><p>&emsp;&emsp;众所周知，在Linux阅读大型源码是一件比较困难的事情，我们可以使用SourceInsigh或者UnderStand，但是总有一种被强奸的感觉，因为这样做不Linux啊。</p>
<p>&emsp;&emsp;总的来说，ctags负责将源码中的各个变量生成各个标签，我们可以随时查看调用位置。而taglist基于ctags提供了结构化浏览的功能，我们可以查看一个结构体中有哪些变量等等。</p>
<h3 id="4-1-安装ctags"><a href="#4-1-安装ctags" class="headerlink" title="4.1 安装ctags"></a>4.1 安装ctags</h3><p>使用命令行：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install ctags</span><br></pre></td></tr></table></figure>
<p>或者从github上下载源码后，使用三板斧：</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">./configure &amp;&amp; <span class="built_in">make</span> &amp;&amp; <span class="built_in">make</span> install</span><br></pre></td></tr></table></figure>
<p>在<code>.vimrc</code>中添加</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">map &lt;C-F12&gt; :!ctags -R --c++<span class="attribute">-kinds</span>=+p <span class="attribute">--fields</span>=+iaS <span class="attribute">--extra</span>=+q .&lt;CR&gt;</span><br></pre></td></tr></table></figure>
<p>我们就可以进入代码根目录后，打开Vim，按下Ctrl-F12快捷键自动生成tags文件。命令执行完后，会在源代码目录生成tags文件。Vim默认会自动读取当前目录下的tags文件，所以不需要修改~/.vimrc文件。</p>
<p>此时，我们已经具有定义跳转的功能了。有两组快捷键是最常用的。</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">Ctrl-]    跳转到光标所在符号的定义。</span><br><span class="line">Ctrl-<span class="built_in">t</span>    回到上次跳转前的位置。</span><br></pre></td></tr></table></figure>
<p>更多功能通过命令man ctags或在Vim命令行下运行help ctags查询。</p>
<h3 id="4-2-安装Taglist"><a href="#4-2-安装Taglist" class="headerlink" title="4.2 安装Taglist"></a>4.2 安装Taglist</h3><p>从下方网址下载talist包，解压打<code>~/.vim</code>，注意的是如果之前已经存在了<code>doc</code>或者<code>plugin</code>文件夹，我们只需要将对应文件放置到对应文件夹即可。</p>
<p>然后在 <code>.vimrc</code>中添加如下两句：</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">Tlist_Show_One_File=1</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">Tlist_Exit_OnlyWindow=1</span></span><br></pre></td></tr></table></figure>

<h2 id="5-安装NERDTree"><a href="#5-安装NERDTree" class="headerlink" title="5 安装NERDTree"></a>5 安装NERDTree</h2><p>&emsp;&emsp;我们使用VIM进行大型源码编程的时候总是无法看到目录结构，这是一件比较苦恼的事情，那么我们就可以使用NERDTree来解决。方法很简单：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/scrooloose/nerdtree.git ~/</span><br></pre></td></tr></table></figure>
<p>然后将目录中的文件放置到对应的文件夹即可。进入 vims使用命令 <code>NERDTreeToggle</code>看看目录结构出来了没有。我们也可以在<code>.vimrc</code>中设置快捷键</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">map &lt;F6&gt; <span class="symbol">:NERDTreeToggle&lt;CR&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样就可以使用 <code>F6</code>打开或者关闭目录结构了。</p>
<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>日常</category>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>编程工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Keil Print输出</title>
    <url>/2020/05/24/%E6%97%A5%E5%B8%B8/Tools/Keil-print%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<ul>
<li><p>在keil中使能print输出</p>
<a id="more"></a>
</li>
<li><p><code>C++</code>、<code>ASM</code>标签添加<code>DEBUG_ENABLE_SEMIHOST</code>选项</p>
</li>
<li><p>选中<code>use microLib</code> </p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">#include <span class="string">"stdio.h"</span></span><br><span class="line"></span><br><span class="line">#define ITM_Port8(<span class="name">n</span>)    (<span class="name">*</span>((<span class="name">volatile</span> unsigned char *)(0xE0000000+4*n)))</span><br><span class="line">#define ITM_Port16(<span class="name">n</span>)   (<span class="name">*</span>((<span class="name">volatile</span> unsigned short*)(<span class="number">0</span>xE0000000+4*n)))</span><br><span class="line">#define ITM_Port32(<span class="name">n</span>)   (<span class="name">*</span>((<span class="name">volatile</span> unsigned long *)(0xE0000000+4*n)))</span><br><span class="line"></span><br><span class="line">#define DEMCR           (<span class="name">*</span>((<span class="name">volatile</span> unsigned long *)(0xE000EDFC)))</span><br><span class="line">#define TRCENA          0x01000000</span><br><span class="line"></span><br><span class="line">struct __FILE &#123; int handle; /* Add whatever you need here */ &#125;;</span><br><span class="line">FILE __stdout;</span><br><span class="line">FILE __stdin;</span><br><span class="line"></span><br><span class="line">int fputc(int ch, FILE *f) &#123;</span><br><span class="line">  if (<span class="name">DEMCR</span> &amp; TRCENA) &#123;</span><br><span class="line">    while (<span class="name">ITM_Port32</span>(<span class="number">0</span>) == <span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">    ITM_Port8(<span class="number">0</span>) = ch<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line">  return(<span class="name">ch</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>日常</category>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>编程工具</tag>
      </tags>
  </entry>
  <entry>
    <title>我的Makefilee模板</title>
    <url>/2017/03/08/%E6%97%A5%E5%B8%B8/Tools/%E6%88%91%E7%9A%84Makefilee%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>&emsp;&emsp;在Linux下开发，使用Makefile组织源码工程师基本功。在本篇文章中会介绍Makefile的基础知识以及Dock经常使用的Makefile函数及模板。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7774609-84480fd03d362420.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Makefile.jpg"></p>
<a id="more"></a>

<h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h1><p>&emsp;&emsp;每一个Makefile选项都是由 <code>Target</code>、<code>Prerequisite</code>、<code>Function</code>三部分组成，如：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target</span>: prerequisites</span><br><span class="line">          <span class="keyword">command</span></span><br></pre></td></tr></table></figure>
<p>一个实例如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">hello</span>: <span class="selector-tag">hello</span><span class="selector-class">.c</span></span><br><span class="line">    <span class="selector-tag">gcc</span> <span class="selector-tag">hello</span><span class="selector-class">.c</span> <span class="selector-tag">-o</span> <span class="selector-tag">hello</span></span><br></pre></td></tr></table></figure>
<p>这样在我们使用 <code>make hello</code>的时候,就会调用 <code>gcc hello.c -o hello</code>命令。</p>
<h1 id="2-常用函数"><a href="#2-常用函数" class="headerlink" title="2.常用函数"></a>2.常用函数</h1><p>&emsp;&emsp;通配函数，下面这个会通配所有以 <code>.cpp</code>结尾的文件。如当前文件夹下有a.cpp &emsp;b.c &emsp;c.cpp,那么 SRC_CPP的值就会是 a.cpp &emsp;c.cpp</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">SRC_CPP = <span class="variable">$(<span class="built_in">wildcard</span> *.cpp)</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;替换函数。我们在实际开发中常用到的一点就是讲.cpp .c转换为.o文件，但是总不能一个一个去敲吧。那么替换函数就派上用场了。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">OBJS += <span class="variable">$(<span class="built_in">patsubst</span> %c, %o, <span class="variable">$(SRC_C)</span>)</span></span><br></pre></td></tr></table></figure>
<p>上面这条就是把 $SRC_C中每一项的<code>c</code>换为 <code>o</code>。</p>
<h1 id="3-Makefile模板"><a href="#3-Makefile模板" class="headerlink" title="3.Makefile模板"></a>3.Makefile模板</h1><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#CXX = g++</span></span><br><span class="line"><span class="comment">#CC	= gcc</span></span><br><span class="line">CXX = arm-linux-gnu-g++</span><br><span class="line">CC = arm-linux-gnu-gcc</span><br><span class="line"></span><br><span class="line">CXXFLAGS = -pthread -Wall -std=c++11</span><br><span class="line">INCLUDE_PATH = -I./inc</span><br><span class="line"></span><br><span class="line">SRC_CPP = <span class="variable">$(<span class="built_in">wildcard</span> *.cpp)</span></span><br><span class="line">SRC_C	+= <span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span></span><br><span class="line"></span><br><span class="line">OBJS += <span class="variable">$(<span class="built_in">patsubst</span> %c, %o, <span class="variable">$(SRC_C)</span>)</span></span><br><span class="line">OBJS += <span class="variable">$(<span class="built_in">patsubst</span> %cpp, %o, <span class="variable">$(SRC_CPP)</span>)</span></span><br><span class="line"></span><br><span class="line">TARGET=Hello        <span class="comment">#自定义自己的目标文件</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>:<span class="variable">$(OBJS)</span></span><br><span class="line">	<span class="variable">$(CXX)</span>  <span class="variable">$^</span> <span class="variable">$(CXXFLAGS)</span> -o <span class="variable">$@</span> -L./ -lsxtl</span><br><span class="line"></span><br><span class="line"><span class="section">.cpp.o:         #cpp 编译成 o</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -c <span class="variable">$(CXXFLAGS)</span> <span class="variable">$(INCLUDE_PATH)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">.c.o:           # c 编译成 o</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -c <span class="variable">$(CXXFLAGS)</span> <span class="variable">$(INCLUDE_PATH)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm <span class="variable">$(OBJS)</span></span><br><span class="line">    rm <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>
<p>每次Dock需要重新配置一个Makefile的时候就会将上边这个Makefile修改一下，适配新工程。</p>
<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>日常</category>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello CoderDock</title>
    <url>/2016/08/26/%E6%97%A5%E5%B8%B8/%E6%97%A5%E5%B8%B8%E5%90%90%E6%A7%BD/Hello-CoderDock/</url>
    <content><![CDATA[<a id="more"></a>


<p>Hi, I am Coder Dock!<br>欢迎来到我的博客，我会在这里一点点记录自己成为一个技术大牛的历程（期待吧）。</p>
<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>日常</category>
        <category>日常吐槽</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>libevent安装使用</title>
    <url>/2017/06/18/%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6/Libevent/libevent%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>编程框架</category>
        <category>Libevent</category>
      </categories>
  </entry>
  <entry>
    <title>libevent系列-基本了解</title>
    <url>/2017/06/17/%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6/Libevent/libevent%E7%B3%BB%E5%88%97-%E5%9F%BA%E6%9C%AC%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<p>Libevent 是一个用C语言编写的、轻量级的开源高性能事件通知库。<br><img src="https://coderdock-1251264493.picsh.myqcloud.com/libevent.png" alt="libevent"></p>
<a id="more"></a>

<h1 id="1-特性"><a href="#1-特性" class="headerlink" title="1.特性"></a>1.特性</h1><ul>
<li>事件驱动（event-driven），高性能;</li>
<li>轻量级，专注于网络；</li>
<li>源代码相当精炼、易读；</li>
<li>跨平台，支持Windows、Linux、Mac Os；</li>
<li>支持多种I/O多路复用技术， epoll、poll、dev/poll、select和kqueue等；</li>
<li>支持I/O，定时器和信号等事件；</li>
<li>注册事件优先级；</li>
</ul>
<h1 id="2-功能"><a href="#2-功能" class="headerlink" title="2. 功能"></a>2. 功能</h1><p>Libevent提供了事件通知，io缓存事件，定时器，超时，异步解析dns，事件驱动的http server以及一个rpc框架。</p>
<ul>
<li>事件通知：当文件描述符可读可写时将执行回调函数。</li>
<li>Io缓存：缓存事件提供了输入输出缓存，能自动的读入和写入，用户不必直接操作io。</li>
<li>定时器：libevent提供了定时器的机制，能够在一定的时间间隔之后调用回调函数。</li>
<li>信号：触发信号，执行回调。</li>
<li>异步的dns解析：libevent提供了异步解析dns服务器的dns解析函数集。</li>
<li>事件驱动的http服务器：libevent提供了一个简单的，可集成到应用程序中的HTTP服务器。</li>
<li>RPC客户端服务器框架：libevent为创建RPC服务器和客户端创建了一个RPC框架，能自动的封装和解封数据结构。</li>
</ul>
<h1 id="3-学习的好处"><a href="#3-学习的好处" class="headerlink" title="3.学习的好处"></a>3.学习的好处</h1><p>通过阅读libevent的源代码，能够更好地学习函数指针、c语言的多态支持、链表和堆等进阶编程基础以及对事件通知机制有更加深刻的理解。<br>下载libevent源码：<br><code>git clone git@github.com:nmathewson/Libevent.git</code></p>
<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>编程框架</category>
        <category>Libevent</category>
      </categories>
      <tags>
        <tag>libevent</tag>
        <tag>基础了解</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式Qt5.8移植-使用-一键调试配置</title>
    <url>/2017/06/23/%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6/Qt/%E5%B5%8C%E5%85%A5%E5%BC%8FQt5-8%E7%A7%BB%E6%A4%8D-%E4%BD%BF%E7%94%A8-%E4%B8%80%E9%94%AE%E8%B0%83%E8%AF%95%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>本节介绍片一键上传并配置程序。</p>
<a id="more"></a>
<p><img src="https://coderdock-1251264493.picsh.myqcloud.com/set.png" alt="Kit"><br>出现以下输出说明配置成功。<br><img src="https://coderdock-1251264493.picsh.myqcloud.com/test.png" alt="Kit"><br>QT Creator调试时需要在目标机执行命令和部署文件，进行这些可信操作是基于SSH加密，因此我们在使用PassWord连接成功后，需要向目标机部署公钥，以取得执行可信操作的能力。</p>
<ul>
<li>进入用户家目录下，执行<code>ssh-keygen –t rsa – C</code>命令，在 .ssh目录下生成两个秘钥–id_rsa(私钥)、id_rsa.pub（公钥）。</li>
<li>按下图进行秘钥的部署和测试。<br><img src="https://coderdock-1251264493.picsh.myqcloud.com/onekey.png" alt="Kit"><br>之后点击Test,如果输出成功，就可以进行一键调试了。</li>
</ul>
<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>编程框架</category>
        <category>QT</category>
        <category>QT移植</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式Qt5.8移植-基础</title>
    <url>/2017/06/15/%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6/Qt/%E5%B5%8C%E5%85%A5%E5%BC%8FQt5-8%E7%A7%BB%E6%A4%8D-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>本章介绍Qt的基础知识。<br><img src="https://coderdock-1251264493.cos.ap-shanghai.myqcloud.com/qt.png" alt="QT"></p>
<a id="more"></a>
<h1 id="1-QT介绍"><a href="#1-QT介绍" class="headerlink" title="1. QT介绍"></a>1. QT介绍</h1><p>&emsp;&emsp;Qt 是一个跨平台的C++应用程序框架，支持Windows、Linux、Mac OS X、Android、iOS、Windows Phone、嵌入式系统等。也就是说，Qt 可以同时支持桌面应用程序开发、嵌入式开发和移动开发，覆盖了现有的所有主流平台。你只需要编写一次代码，发布到不同平台前重新编译即可。</p>
<p>&emsp;&emsp;Qt 不仅仅是一个GUI库，它除了可以创建漂亮的界面，还有很多其他组件，例如，你不再需要研究STL，不再需要C++的<string>头文件，不再需要去找解析XML、连接数据库、Socket 的各种第三方库，这些 Qt 都已经内置了。</p>
<p>&emsp;&emsp;由于Qt具有封装性好、简单易学、跨平台的特性，已经被用来开发许多著名软件，如WPS、YY语音、Skype、VirtualBox、Opera、Google地图、Adobe Photoshop Album 等。</p>
<h1 id="2-QT安装"><a href="#2-QT安装" class="headerlink" title="2. QT安装"></a>2. QT安装</h1><p>&emsp;&emsp;本系列文章会分为三个四个部分进行讲解，<code>Qt Creator 安装</code>，<code>交叉编译QT并支持VNC</code>,<code>嵌入式QT开发环境配置</code>,<code>一键调试配置</code>。<br>在本节将会详细介绍Qt的下载、安装、配置等操作。本节所指的QT为QT安装包，其包括了两部分：</p>
<ul>
<li>QT框架 – 用于支持生成应用程序</li>
<li>QT Creator – 进行QT开发的官方推荐IDE（集成开发环境</li>
</ul>
<h2 id="2-1-QT下载"><a href="#2-1-QT下载" class="headerlink" title="2.1  QT下载"></a>2.1  QT下载</h2><ul>
<li>使用浏览器打开 <a href="https://download.qt.io/archive/qt/" target="_blank" rel="noopener">https://download.qt.io/archive/qt/</a> ，该网址包含着QT的所有历史版本，本次安装使用 5.8 版本，点击进入5.8目录。</li>
<li>本次平台使用Linux系统，所以选择 qt-opensource-linux-x64-5.8.0.run进行下载</li>
<li>打开 Ubuntu终端，创建安装目录，推荐在 /opt 下安装，步骤如下：<ul>
<li>进入 /opt 目录： cd /opt</li>
<li>创建 Qt 目录 ： sudo mkdir Qt (之后需要输入root密码)<h2 id="2-2-Qt-Creator安装"><a href="#2-2-Qt-Creator安装" class="headerlink" title="2.2 Qt Creator安装"></a>2.2 Qt Creator安装</h2></li>
</ul>
</li>
<li>进入上一节Qt的下载目录，更改安装文件权限为 777 并运行安装，步骤如下：<ul>
<li>更改权限: sudo chmod 777 qt-opensource-linux-x64-5.8.0.run</li>
<li>执行安装：sudo ./qt-opensource-linux-x64-5.8.0.run</li>
</ul>
</li>
<li>之后会让我们选择安装位置，我们选择前面创建的Qt目录，然后一路Next下去就好了。</li>
</ul>
<h1 id="3-交叉编译工具"><a href="#3-交叉编译工具" class="headerlink" title="3.交叉编译工具"></a>3.交叉编译工具</h1><p>&emsp;&emsp;在进行交叉编译前，我们需要安装与目标机相适用的交叉编译工具链，参照我之前的文章去下载合适的编译工具或者从商家获取合适的交叉编译工具。使用 which aarch64-linux-gnu-gcc 命令可以查看工具链安装位置。</p>
<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>编程框架</category>
        <category>QT</category>
        <category>QT移植</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式Qt5.8移植-编译-支持VNC</title>
    <url>/2017/06/20/%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6/Qt/%E5%B5%8C%E5%85%A5%E5%BC%8FQt5-8%E7%A7%BB%E6%A4%8D-%E7%BC%96%E8%AF%91-%E6%94%AF%E6%8C%81VNC/</url>
    <content><![CDATA[<p>本章介绍Qt交叉编译的过程</p>
<a id="more"></a>

<h1 id="1-下载源码"><a href="#1-下载源码" class="headerlink" title="1.下载源码"></a>1.下载源码</h1><ul>
<li><p>去上一篇文章中的下载地址 下载qt-everywhere-opensource-src-5.8.0.tar.gz </p>
</li>
<li><p>使用命令 tar xvzf qt-everywhere-opensource-src-5.8.0.tar.gz 进行解压</p>
<h1 id="1-VNC说明"><a href="#1-VNC说明" class="headerlink" title="1.VNC说明"></a>1.VNC说明</h1><p>&emsp;&emsp;在QT5之后，QT不再支持QWS机制，即-qt-gfx-vnc配置项在QT5之后不再支持，QT5使用QPA(Qt Platform Abstraction Qt平台抽象)进行取代，当QT需要支持新平台时，需要为其编译一个新插件，在qtbase/src/plugins/platforms目录下存在着该版本QT支持的插件工程，包括Android，linuxfb，directfb，以及我们需要的vnc，想要使用VNC，需要在配置时使用选项 –qpa vnc进行指定。</p>
</li>
<li><p>进入上一步已经解压好的源码目录，将 /qtbase/mkspecs/ 目录下的linux-arm-gnueabi-g++ 进行如下修改，主要是将文件中的所有 linux-arm-gnueabi- 替换为了 arm-linux-(根据实际情况替换前缀)。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># qmake configuration for building with aarch64-linux-gnu-g++</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">MAKEFILE_GENERATOR = UNIX</span><br><span class="line">CONFIG += incremental</span><br><span class="line">QMAKE_INCREMENTAL_STYLE = sublib</span><br><span class="line"><span class="keyword">include</span>(../common/linux.conf)</span><br><span class="line"><span class="keyword">include</span>(./common/gcc-base-unix.conf)</span><br><span class="line"><span class="keyword">include</span>(../common/g++-unix.conf)</span><br><span class="line"><span class="comment"># modifications to g++.conf</span></span><br><span class="line">QMAKE_CC = arm-linux-gnu-gcc</span><br><span class="line">QMAKE_CXX = arm-linux-gnu-g++</span><br><span class="line">QMAKE_LINK = arm-linux-gnu-g++</span><br><span class="line">QMAKE_LINK_SHLIB = arm-linux-gnu-g++</span><br><span class="line"><span class="comment"># modifications to linux.conf</span></span><br><span class="line">QMAKE_AR = arm-linux-gnu-ar cqs</span><br><span class="line">QMAKE_OBJCOPY = arm-linux-gnu-objcopy</span><br><span class="line">QMAKE_NM = arm-linux-gnu-nm -P</span><br><span class="line">QMAKE_STRIP = arm-linux-gnu-strip</span><br><span class="line">load(qt_config)</span><br></pre></td></tr></table></figure>
<p>具体配置选项帮助见配置选项，我们需要的注意点有：</p>
</li>
</ul>
<p>a) –prefix：在目标机上的安装目录，这是在目标机上执行程序时寻找链接库的位置。</p>
<p>b) –extprefix在宿主机上的安装目录，这个位置是我们使用Qt Creator进行交叉编译时寻找链接库的位置。</p>
<p>c) –qpa vn  -qt-gfx-vnc在QT5之后不再支持qws机制，需要在配置时使用选项 –qpa vnc进行指定。</p>
<p>d)一般情况下我们不使用系统的png，jpeg等库，需要指定 –no-libpng,同理，我们配置-qt-libpng使用qt自带的png等库。</p>
<ul>
<li>使用如下命令进行编译之后等待完成即可<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"> ./configure -prefix /usr/arm/qt5.<span class="number">8</span> -extprefix /usr/arm/qt5.<span class="number">8</span> -opensource -xplatform linux-arm-gnueabi-g++ -<span class="keyword">no</span>-glib -<span class="keyword">no</span>-cups -<span class="keyword">no</span>-accessibility -<span class="keyword">no</span>-openssl -<span class="keyword">no</span>-libpng -<span class="keyword">no</span>-libjpeg -qt-zlib -<span class="keyword">no</span>-dbus -<span class="keyword">no</span>-pkg-config -optimized-qmake -nomake examples -qtlibinfix DhSc -qpa vnc -<span class="keyword">debug</span> -<span class="keyword">no</span>-opengl -qt-libpng</span><br><span class="line"></span><br><span class="line"><span class="keyword">make</span> -j4</span><br><span class="line"></span><br><span class="line"><span class="keyword">make</span> install</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>安装完成后，就可以在 <code>/usr/arm</code>发现输出文件。</p>
<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>编程框架</category>
        <category>QT</category>
        <category>QT移植</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式Qt5.8移植-安装-环境配置</title>
    <url>/2017/06/22/%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6/Qt/%E5%B5%8C%E5%85%A5%E5%BC%8FQt5-8%E7%A7%BB%E6%A4%8D-%E5%AE%89%E8%A3%85-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>本节介绍配置交叉编译套件的安装配置。</p>
<a id="more"></a>
<h1 id="1-添加构建套件"><a href="#1-添加构建套件" class="headerlink" title="1.添加构建套件"></a>1.添加构建套件</h1><p>打开QT Creator，进入 Tools-&gt;Options-&gt;Build&amp;Run</p>
<ul>
<li>点击 Compilers选项单，添加交叉编译工具链的g++，同理加入gcc<br><img src="https://coderdock-1251264493.picsh.myqcloud.com/kit.png" alt="Kit"><br><img src="https://coderdock-1251264493.picsh.myqcloud.com/kit2.png" alt="Kit"><br><img src="https://coderdock-1251264493.picsh.myqcloud.com/kit3.png" alt="Kit"><br>设置完这三步以后，就可以使用交叉编译的构建套件，和开发桌面程序是一样的。</li>
</ul>
<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>编程框架</category>
        <category>QT</category>
        <category>QT移植</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Yocto-Project-使用技巧</title>
    <url>/2017/09/07/%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6/Yocto/Yocto-Project-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>Yocto是一个开源的构建自己的Linux发行版本的工具。笔者在使用PetaLinx过程中发现能够掌握一些底层的BitBake很有帮助。</p>
<a id="more"></a>

<ul>
<li>bitbake -b 直接执行一个 .bb文件</li>
<li>-k 尽可能的继续执行在出现一个错误以后</li>
<li>-f force</li>
<li>-c CMD</li>
<li>-C INVALIDATE_STAM 禁止一项功能，如某个任务中禁止 compile任务</li>
<li>-r PREFILE –read=PREFILE 在进行某一项任务时读取天特定的文件 时机是在读取 bitbake.conf 之前</li>
<li>-R POSTFILE 在之后</li>
<li>-v verbose 终端显示而不是写入log文件</li>
<li>-D debug</li>
<li>-q quite</li>
<li>-n –dry-run 不执行</li>
<li>-s show version</li>
<li>-e show environment</li>
<li>–no-setsence 不执行setsence任务， sstate会被忽略，所有的会被重新build</li>
<li>–setsence-only</li>
</ul>
<ul>
<li>确定一个包的名字 ： bitbake -s | grep something</li>
<li>bitbake -e ： 显示到终端</li>
<li>确定一个包所执行的task ： bitbake package -c listtasks</li>
<li>确定下载地址： bitbake -e linux-imx | grep ^SRC_URI=</li>
</ul>
<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>编程框架</category>
        <category>Yocto</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>yocto</tag>
      </tags>
  </entry>
  <entry>
    <title>Python面向对象编程</title>
    <url>/2017/01/09/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>本节介绍Python面向对象的相关操作</p>
<a id="more"></a>
<h1 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1.基础概念"></a>1.基础概念</h1><ul>
<li>*<em>类(Class): *</em>用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</li>
<li><strong>类变量：</strong>类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</li>
<li><strong>数据成员：</strong>类变量或者实例变量用于处理类及其实例对象的相关的数据。</li>
<li><strong>方法重写：</strong>如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</li>
<li><strong>实例变量：</strong>定义在方法中的变量，只作用于当前实例的类。</li>
<li><strong>继承：</strong>即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。</li>
<li><strong>实例化：</strong>创建一个类的实例，类的具体对象。</li>
<li><strong>方法：</strong>类中定义的函数。</li>
<li><strong>对象：</strong>通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</li>
</ul>
<h1 id="2-类应用"><a href="#2-类应用" class="headerlink" title="2.类应用"></a>2.类应用</h1><h2 id="2-1编写类"><a href="#2-1编写类" class="headerlink" title="2.1编写类"></a>2.1编写类</h2><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Employee</span>: </span></span><br><span class="line"><span class="string">'所有员工的基类'</span>  </span><br><span class="line">	empCount = <span class="number">0</span>  </span><br><span class="line">	<span class="function"><span class="keyword">def</span>  <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, name, salary)</span></span>: </span><br><span class="line">		<span class="keyword">self</span>.name = name  </span><br><span class="line">		<span class="keyword">self</span>.salary = salary  </span><br><span class="line">		Employee.empCount += <span class="number">1</span>  </span><br><span class="line">	<span class="function"><span class="keyword">def</span>  <span class="title">displayCount</span><span class="params">(<span class="keyword">self</span>)</span></span>: </span><br><span class="line">		print  <span class="string">"Total Employee %d"</span> % Employee.empCount  </span><br><span class="line">	<span class="function"><span class="keyword">def</span>  <span class="title">displayEmployee</span><span class="params">(<span class="keyword">self</span>)</span></span>: </span><br><span class="line">		print  <span class="string">"Name : "</span>, <span class="keyword">self</span>.name, <span class="string">", Salary: "</span>, <span class="keyword">self</span>.salary</span><br></pre></td></tr></table></figure>
<p><strong>init</strong>的作用就是我们C++中的构造函数。</p>
<h2 id="2-2-实例类"><a href="#2-2-实例类" class="headerlink" title="2.2 实例类"></a>2.2 实例类</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="string">"创建 Employee 类的第一个对象"</span>  </span><br><span class="line">emp1 = <span class="constructor">Employee(<span class="string">"Zara"</span>, 2000)</span>  </span><br><span class="line"><span class="string">"创建 Employee 类的第二个对象"</span>  </span><br><span class="line">emp2 = <span class="constructor">Employee(<span class="string">"Manni"</span>, 5000)</span>  </span><br><span class="line">emp1.display<span class="constructor">Employee()</span>  </span><br><span class="line">emp2.display<span class="constructor">Employee()</span>  </span><br><span class="line">print  <span class="string">"Total Employee %d"</span> % <span class="module-access"><span class="module"><span class="identifier">Employee</span>.</span></span>empCount</span><br></pre></td></tr></table></figure>
<h2 id="2-3-Python内置类属性"><a href="#2-3-Python内置类属性" class="headerlink" title="2.3 Python内置类属性"></a>2.3 Python内置类属性</h2><ul>
<li><strong>dict</strong> : 类的属性（包含一个字典，由类的数据属性组成）</li>
<li><strong>doc</strong> :类的文档字符串</li>
<li><strong>name</strong>: 类名</li>
<li><strong>module</strong>: 类定义所在的模块（类的全名是’<strong>main</strong>.className’，如果类位于一个导入模块mymod中，那么className.<strong>module</strong> 等于 mymod）</li>
<li><strong>bases</strong> : 类的所有父类构成元素（包含了一个由所有父类组成的元组）</li>
</ul>
<p>Python内置类属性调用实例如下：</p>
<h2 id="2-4类的析构"><a href="#2-4类的析构" class="headerlink" title="2.4类的析构"></a>2.4类的析构</h2><p>&emsp;&emsp;Python的析构函数和C++的是一样的，都提供一个默认的析构函数。</p>
<p>&emsp;&emsp;Python 使用了引用计数这一简单技术来跟踪和回收垃圾。在 Python 内部记录着所有使用中的对象各有多少引用。一个内部跟踪变量，称为一个引用计数器。当对象被创建时， 就创建了一个引用计数， 当这个对象不再需要时， 也就是说， 这个对象的引用计数变为0 时， 它被垃圾回收。但是回收不是”立即”的， 由解释器在适当的时机，将垃圾对象占用的内存空间回收。</p>
<h2 id="2-5-类的继承"><a href="#2-5-类的继承" class="headerlink" title="2.5 类的继承"></a>2.5 类的继承</h2><p>&emsp;&emsp;面向对象的编程带来的主要好处之一是代码的重用，实现这种重用的方法之一是通过继承机制。继承完全可以理解成类之间的类型和子类型关系。</p>
<p>&emsp;&emsp;需要注意的地方：<strong>继承语法</strong> class 派生类名（<strong>基类名</strong>）：//… 基类名写在括号里，基本类是在类定义的时候，在元组之中指明的。</p>
<p>在python中继承中的一些特点：</p>
<ul>
<li>1：在继承中基类的构造（<strong>init</strong>()方法）不会被自动调用，它需要在其派生类的构造中亲自专门调用。</li>
<li>2：在调用基类的方法时，需要加上基类的类名前缀，且需要带上self参数变量。区别在于类中调用普通函数时并不需要带上self参数</li>
<li>3：Python总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）。</li>
</ul>
<p>如果在继承元组中列了一个以上的类，那么它就被称作”多重继承” 。</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="type">SubClassName</span>  (<span class="type">ParentClass1</span>[,  <span class="type">ParentClass2</span>,  ...]):</span></span><br></pre></td></tr></table></figure>
<h2 id="2-6-方法重写"><a href="#2-6-方法重写" class="headerlink" title="2.6 方法重写"></a>2.6 方法重写</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python </span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Parent</span>:</span> <span class="comment"># 定义父类  </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span>  <span class="title">myMethod</span><span class="params">(self)</span>:</span> </span><br><span class="line">	<span class="keyword">print</span>  <span class="string">'调用父类方法'</span>  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Child</span><span class="params">(Parent)</span>:</span> <span class="comment"># 定义子类  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span>  <span class="title">myMethod</span><span class="params">(self)</span>:</span> </span><br><span class="line"><span class="keyword">print</span>  <span class="string">'调用子类方法'</span>  </span><br><span class="line"></span><br><span class="line">c = Child()  <span class="comment"># 子类实例  </span></span><br><span class="line">c.myMethod()  <span class="comment"># 子类调用重写方法</span></span><br></pre></td></tr></table></figure>


<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux输入子系统Core源码简要分析</title>
    <url>/2017/06/03/ARM&amp;Linux/Linux%E9%A9%B1%E5%8A%A8/Linux%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9FCore%E6%BA%90%E7%A0%81%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>本章对Linux输入子系统InPutCore的源码进行简要分析。</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">_________ _        _______          _________</span><br><span class="line">\__   __/( (    /|<span class="string">(  ____ )</span>|<span class="string">\     /</span>|<span class="string">\__   __/</span></span><br><span class="line"><span class="string">   ) (   </span>|<span class="string">  \  ( </span>||<span class="string"> (    )</span>||<span class="string"> )   ( </span>|<span class="string">   ) (</span></span><br><span class="line"><span class="string">   </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string">   \ </span>|<span class="string"> </span>||<span class="string"> (____)</span>||<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>|</span><br><span class="line">   |<span class="string"> </span>|<span class="string">   </span>|<span class="string"> (\ \) </span>||<span class="string">  _____)</span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>|</span><br><span class="line">   |<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string"> \   </span>||<span class="string"> (      </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>|</span><br><span class="line">___) (___|<span class="string"> )  \  </span>||<span class="string"> )      </span>|<span class="string"> (___) </span>|<span class="string">   </span>|<span class="string"> </span>|</span><br><span class="line">\_______/|<span class="string">/    )_)</span>|<span class="string">/       (_______)   )_(</span></span><br><span class="line"></span><br><span class="line"><span class="string"> _______  _______  _______  _______</span></span><br><span class="line"><span class="string">(  ____ \(  ___  )(  ____ )(  ____ \</span></span><br><span class="line">|<span class="string"> (    \/</span>|<span class="string"> (   ) </span>||<span class="string"> (    )</span>||<span class="string"> (    \/</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">      </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>||<span class="string"> (____)</span>||<span class="string"> (__</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">      </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>||<span class="string">     __)</span>|<span class="string">  __)</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">      </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>||<span class="string"> (\ (   </span>|<span class="string"> (</span></span><br><span class="line">|<span class="string"> (____/\</span>|<span class="string"> (___) </span>||<span class="string"> ) \ \__</span>|<span class="string"> (____/\</span></span><br><span class="line"><span class="string">(_______/(_______)</span>|<span class="string">/   \__/(_______/</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>想要读懂Linux输入子系统的源码需要先明确三个结构体：</p>
<p>input_handle建立 input_dev 和 input_handler的联系，通过两个list保存系统中所有的device和 handler。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct input_handle - links input device <span class="keyword">with</span> an input handler</span><br><span class="line"> * @private: handler-specific data</span><br><span class="line"> * @open: counter showing whether <span class="keyword">the</span> handle <span class="keyword">is</span> 'open', i.e. should deliver</span><br><span class="line"> *	events <span class="keyword">from</span> <span class="keyword">its</span> device</span><br><span class="line"> * @<span class="built_in">name</span>: <span class="built_in">name</span> <span class="keyword">given</span> <span class="keyword">to</span> <span class="keyword">the</span> handle <span class="keyword">by</span> handler <span class="keyword">that</span> created <span class="keyword">it</span></span><br><span class="line"> * @dev: input device <span class="keyword">the</span> handle <span class="keyword">is</span> attached <span class="keyword">to</span></span><br><span class="line"> * @handler: handler <span class="keyword">that</span> works <span class="keyword">with</span> <span class="keyword">the</span> device <span class="keyword">through</span> this handle</span><br><span class="line"> * @d_node: used <span class="keyword">to</span> <span class="keyword">put</span> <span class="keyword">the</span> handle <span class="keyword">on</span> device's <span class="built_in">list</span> <span class="keyword">of</span> attached handles</span><br><span class="line"> * @h_node: used <span class="keyword">to</span> <span class="keyword">put</span> <span class="keyword">the</span> handle <span class="keyword">on</span> handler's <span class="built_in">list</span> <span class="keyword">of</span> handles <span class="keyword">from</span> which</span><br><span class="line"> *	<span class="keyword">it</span> gets events</span><br><span class="line"> */</span><br><span class="line">struct input_handle &#123;</span><br><span class="line">	void *private;</span><br><span class="line">	int open;</span><br><span class="line">	const char *<span class="built_in">name</span>;</span><br><span class="line">	struct input_dev *dev;</span><br><span class="line">	struct input_handler *handler;</span><br><span class="line">  struct list_head	d_node;</span><br><span class="line">	struct list_head	h_node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>input_dev表征一个输入设备：<br>在向InputCore注册一个输入设备前，需要先分配一个此结构体并且初始化某些值，如设置按键类型，按键值等。如需要定时操作，初始化timer_list，这样就可以进行定时操作了。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>struct input_dev - represents </span>an<span class="markdown"> input device</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@name: name of </span>the<span class="markdown"> device</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@phys: physical path to </span>the<span class="markdown"> device in </span>the<span class="markdown"> system hierarchy</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@uniq: unique identification code for </span>the<span class="markdown"> device (if device has it)</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@id: id of </span>the<span class="markdown"> device (struct input_id)</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@propbit: bitmap of device properties and quirks</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@evbit: bitmap of types of events supported by </span>the<span class="markdown"> device (EV_KEY,</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>EV_REL, etc.)</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@keybit: bitmap of keys/buttons this device has</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@relbit: bitmap of relative axes for </span>the<span class="markdown"> device</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@absbit: bitmap of absolute axes for </span>the<span class="markdown"> device</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@mscbit: bitmap of miscellaneous events supported by </span>the<span class="markdown"> device</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@ledbit: bitmap of leds present on </span>the<span class="markdown"> device</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@sndbit: bitmap of sound effects supported by </span>the<span class="markdown"> device</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@ffbit: bitmap of force feedback effects supported by </span>the<span class="markdown"> device</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@swbit: bitmap of switches present on </span>the<span class="markdown"> device</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@hint<span class="emphasis">_events_</span>per_packet: average number of events generated by </span>the</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>device in </span>a<span class="markdown"> packet (between EV<span class="emphasis">_SYN/SYN_</span>REPORT events). Used by</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>event handlers to estimate size of </span>the<span class="markdown"> buffer needed to hold</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>events.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@keycodemax: size of keycode table</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@keycodesize: size of elements in keycode table</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@keycode: map of scancodes to keycodes for this device</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@getkeycode: optional legacy method to retrieve current keymap.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@setkeycode: optional method to alter current keymap, used to implement</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>sparse keymaps. If not supplied default mechanism </span>will<span class="markdown"> be used.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>The method is being called while holding event_lock and thus must</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>not sleep</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@ff: force feedback structure associated with </span>the<span class="markdown"> device if device</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>supports force feedback effects</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@repeat_key: stores key code of </span>the<span class="markdown"> last key pressed; used to implement</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>software autorepeat</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@timer: timer for software autorepeat</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@rep: current values for autorepeat parameters (delay, rate)</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@mt: pointer to multitouch state</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@absinfo: array of &amp;struct input_absinfo elements holding information</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>about absolute axes (current value, min, max, flat, fuzz,</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>resolution)</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@key: reflects current state of device's keys/buttons</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@led: reflects current state of device's LEDs</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@snd: reflects current state of sound effects</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@sw: reflects current state of device's switches</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@open: this method is called when </span>the<span class="markdown"> very first user calls</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>input<span class="emphasis">_open_</span>device(). The driver must prepare </span>the<span class="markdown"> device</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>to start generating events (start polling thread,</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>request </span>an<span class="markdown"> IRQ, submit URB, etc.)</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@close: this method is called when </span>the<span class="markdown"> very last user calls</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>input<span class="emphasis">_close_</span>device().</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@flush: purges </span>the<span class="markdown"> device. Most commonly used to get rid of force</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>feedback effects loaded into </span>the<span class="markdown"> device when disconnecting</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>from it</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@event: event handler for events sent <span class="emphasis">_to_</span> </span>the<span class="markdown"> device, </span>like<span class="markdown"> EV_LED</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>or EV_SND. The device is expected to carry out </span>the<span class="markdown"> requested</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>action (turn on </span>a<span class="markdown"> LED, play sound, etc.) The call is protected</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>by @event_lock and must not sleep</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@grab: input handle that currently has </span>the<span class="markdown"> device grabbed (via</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>EVIOCGRAB ioctl). When </span>a<span class="markdown"> handle grabs </span>a<span class="markdown"> device it becomes sole</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>recipient for all input events coming from </span>the<span class="markdown"> device</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@event_lock: this spinlock is taken when input core receives</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>and processes </span>a<span class="markdown"> new event for </span>the<span class="markdown"> device (in input_event()).</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>Code that accesses and/or modifies parameters of </span>a<span class="markdown"> device</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>(</span>such<span class="markdown"> as keymap or absmin, absmax, absfuzz, etc.) after device</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>has been registered with input core must take this lock.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@mutex: serializes calls to open(), close() and flush() methods</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@users: stores number of users (input handlers) that opened this</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>device. It is used by input<span class="emphasis">_open_</span>device() and input<span class="emphasis">_close_</span>device()</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>to make sure that dev-&gt;open() is only called when </span>the<span class="markdown"> first</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>user opens device and dev-&gt;close() is called when </span>the<span class="markdown"> very</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>last user closes </span>the<span class="markdown"> device</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@going_away: marks devices that </span>are<span class="markdown"> in </span>a<span class="markdown"> middle of unregistering and</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>causes input<span class="emphasis">_open_</span>device*() fail with -ENODEV.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@dev: driver model's view of this device</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@h_list: list of input handles associated with </span>the<span class="markdown"> device. When</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>accessing </span>the<span class="markdown"> list dev-&gt;mutex must be held</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@node: used to place </span>the<span class="markdown"> device onto input<span class="emphasis">_dev_</span>list</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@num_vals: number of values queued in </span>the<span class="markdown"> current frame</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@max_vals: maximum number of values queued in </span>a<span class="markdown"> frame</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@vals: array of values queued in </span>the<span class="markdown"> current frame</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@devres_managed: indicates that devices is managed with devres framework</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>and needs not be explicitly unregistered or freed.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> */</span></span></span><br><span class="line">struct input_dev &#123;</span><br><span class="line">	<span class="keyword">const</span> char *name;</span><br><span class="line">	<span class="keyword">const</span> char *phys;</span><br><span class="line">	<span class="keyword">const</span> char *uniq;</span><br><span class="line">	struct input_id id;</span><br><span class="line">	unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];</span><br><span class="line">	unsigned long evbit[BITS_TO_LONGS(EV_CNT)];</span><br><span class="line">	unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];</span><br><span class="line">	unsigned long relbit[BITS_TO_LONGS(REL_CNT)];</span><br><span class="line">	unsigned long absbit[BITS_TO_LONGS(ABS_CNT)];</span><br><span class="line">	unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];</span><br><span class="line">	unsigned long ledbit[BITS_TO_LONGS(LED_CNT)];</span><br><span class="line">	unsigned long sndbit[BITS_TO_LONGS(SND_CNT)];</span><br><span class="line">	unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];</span><br><span class="line">	unsigned long swbit[BITS_TO_LONGS(SW_CNT)];</span><br><span class="line">	unsigned <span class="built_in">int</span> hint_events_per_packet;</span><br><span class="line">	unsigned <span class="built_in">int</span> keycodemax;</span><br><span class="line">	unsigned <span class="built_in">int</span> keycodesize;</span><br><span class="line">	<span class="keyword">void</span> *keycode;</span><br><span class="line">	<span class="built_in">int</span> (*setkeycode)(struct input_dev *dev,</span><br><span class="line">			  <span class="keyword">const</span> struct input_keymap_entry *ke,</span><br><span class="line">			  unsigned <span class="built_in">int</span> *old_keycode);</span><br><span class="line">	<span class="built_in">int</span> (*getkeycode)(struct input_dev *dev,</span><br><span class="line">			  struct input_keymap_entry *ke);</span><br><span class="line">	struct ff_device *ff;</span><br><span class="line">	unsigned <span class="built_in">int</span> repeat_key;</span><br><span class="line">	struct timer_list timer;</span><br><span class="line">	<span class="built_in">int</span> rep[REP_CNT];</span><br><span class="line">	struct input_mt *mt;</span><br><span class="line">	struct input_absinfo *absinfo;</span><br><span class="line">	unsigned long key[BITS_TO_LONGS(KEY_CNT)];</span><br><span class="line">	unsigned long led[BITS_TO_LONGS(LED_CNT)];</span><br><span class="line">	unsigned long snd[BITS_TO_LONGS(SND_CNT)];</span><br><span class="line">	unsigned long sw[BITS_TO_LONGS(SW_CNT)];</span><br><span class="line">	<span class="built_in">int</span> (*open)(struct input_dev *dev);</span><br><span class="line">	<span class="keyword">void</span> (*close)(struct input_dev *dev);</span><br><span class="line">	<span class="built_in">int</span> (*flush)(struct input_dev *dev, struct file *file);</span><br><span class="line">	<span class="built_in">int</span> (*event)(struct input_dev *dev, unsigned <span class="built_in">int</span> type, unsigned <span class="built_in">int</span> code, <span class="built_in">int</span> value);</span><br><span class="line">	struct input_handle __rcu *grab;</span><br><span class="line">	spinlock_t event_lock;</span><br><span class="line">	struct mutex mutex;</span><br><span class="line">	unsigned <span class="built_in">int</span> users;</span><br><span class="line">	<span class="built_in">bool</span> going_away;</span><br><span class="line">	struct device dev;</span><br><span class="line">	struct list_head	h_list;</span><br><span class="line">	struct list_head	node;</span><br><span class="line">	unsigned <span class="built_in">int</span> num_vals;</span><br><span class="line">	unsigned <span class="built_in">int</span> max_vals;</span><br><span class="line">	struct input_value *vals;</span><br><span class="line">	<span class="built_in">bool</span> devres_managed;</span><br><span class="line">&#125;;</span><br><span class="line">#define to_input_dev(d) container_of(d, struct input_dev, dev)</span><br></pre></td></tr></table></figure>

<p>input_handler</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>struct input_handler - implements one of interfaces for input devices</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@private: driver-specific data</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@event: event handler. This method is being called by input core with</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>interrupts disabled and dev-&gt;event_lock spinlock held and </span>so</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>it may not sleep</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@events: event sequence handler. This method is being called by</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>input core with interrupts disabled and dev-&gt;event_lock</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>spinlock held and </span>so<span class="markdown"> it may not sleep</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@filter: similar to @event; separates normal event handlers from</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>"filters".</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@match: called after comparing device's id with handler's id_table</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>to perform fine-grained matching between device and handler</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@connect: called when attaching </span>a<span class="markdown"> handler to </span>an<span class="markdown"> input device</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@disconnect: disconnects </span>a<span class="markdown"> handler from input device</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@start: starts handler for given handle. This function is called by</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>input core right after connect() method and also when </span>a<span class="markdown"> process</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>that "grabbed" </span>a<span class="markdown"> device releases it</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@legacy_minors: set to %true by drivers using legacy minor ranges</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@minor: beginning of range of 32 legacy minors for devices this driver</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>can provide</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@name: name of </span>the<span class="markdown"> handler, to be shown in /proc/bus/input/handlers</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@id_table: pointer to </span>a<span class="markdown"> table of input<span class="emphasis">_device_</span>ids this driver can</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *	</span>handle</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@h_list: list of input handles associated with </span>the<span class="markdown"> handler</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@node: for placing </span>the<span class="markdown"> driver onto input<span class="emphasis">_handler_</span>list</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> *</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Input handlers attach to input devices and create input handles. There</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span></span>are<span class="markdown"> likely several handlers attached to any given input device at </span>the</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>same time. All of them </span>will<span class="markdown"> get their copy of input event generated by</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span></span>the<span class="markdown"> device.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> *</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>The very same structure is used to implement input filters. Input core</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>allows filters to run first and </span>will<span class="markdown"> not pass event to regular handlers</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>if any of </span>the<span class="markdown"> filters indicate that </span>the<span class="markdown"> event </span>should<span class="markdown"> be filtered (by</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>returning %true from their filter() method).</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> *</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Note that input core serializes calls to connect() and disconnect()</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>methods.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> */</span></span></span><br><span class="line">struct input_handler &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> *private;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> (*event)(struct input_handle *handle, unsigned <span class="built_in">int</span> type, unsigned <span class="built_in">int</span> code, <span class="built_in">int</span> value);</span><br><span class="line">	<span class="keyword">void</span> (*events)(struct input_handle *handle,</span><br><span class="line">		       <span class="keyword">const</span> struct input_value *vals, unsigned <span class="built_in">int</span> count);</span><br><span class="line">	<span class="built_in">bool</span> (*filter)(struct input_handle *handle, unsigned <span class="built_in">int</span> type, unsigned <span class="built_in">int</span> code, <span class="built_in">int</span> value);</span><br><span class="line">	<span class="built_in">bool</span> (*match)(struct input_handler *handler, struct input_dev *dev);</span><br><span class="line">	<span class="built_in">int</span> (*connect)(struct input_handler *handler, struct input_dev *dev, <span class="keyword">const</span> struct input_device_id *id);</span><br><span class="line">	<span class="keyword">void</span> (*disconnect)(struct input_handle *handle);</span><br><span class="line">	<span class="keyword">void</span> (*start)(struct input_handle *handle);</span><br><span class="line">	<span class="built_in">bool</span> legacy_minors;</span><br><span class="line">	<span class="built_in">int</span> minor;</span><br><span class="line">	<span class="keyword">const</span> char *name;</span><br><span class="line">	<span class="keyword">const</span> struct input_device_id *id_table;</span><br><span class="line">	struct list_head	h_list;</span><br><span class="line">	struct list_head	node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以下是inputcore的源码，我们需要着重关注，进行了中文注释的部分， 以及 <code>register_input_device</code>、<code>register_input_handler</code>、<code>attach_to_handler</code>、<code>input_handle_event</code>等几个关键操作：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The input core</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Copyright (c) 1999-2002 Vojtech Pavlik</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This program is free software; you can redistribute it and/or modify it</span></span><br><span class="line"><span class="comment"> * under the terms of the GNU General Public License version 2 as published by</span></span><br><span class="line"><span class="comment"> * the Free Software Foundation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pr_fmt(fmt) KBUILD_BASENAME <span class="meta-string">": "</span> fmt</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/idr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/input/mt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/random.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/rcupdate.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"input-compat.h"</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">"Vojtech Pavlik &lt;vojtech@suse.cz&gt;"</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">"Input core"</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INPUT_MAX_CHAR_DEVICES		1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INPUT_FIRST_DYNAMIC_DEV		256</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_IDA</span><span class="params">(input_ida)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">LIST_HEAD</span><span class="params">(input_dev_list)</span></span>;       <span class="comment">//初始化设备列表</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">LIST_HEAD</span><span class="params">(input_handler_list)</span></span>;   <span class="comment">//初始化handler列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * input_mutex protects access to both input_dev_list and input_handler_list.</span></span><br><span class="line"><span class="comment"> * This also causes input_[un]register_device and input_[un]register_handler</span></span><br><span class="line"><span class="comment"> * be mutually exclusive which simplifies locking in drivers implementing</span></span><br><span class="line"><span class="comment"> * input handlers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_MUTEX</span><span class="params">(input_mutex)</span></span>;       <span class="comment">//在 input_[un]register_device input_[un]register_handler 起保护作用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> <span class="title">input_value_sync</span> = &#123;</span> EV_SYN, SYN_REPORT, <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">is_event_supported</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> code,</span></span></span><br><span class="line"><span class="function"><span class="params">				     <span class="keyword">unsigned</span> <span class="keyword">long</span> *bm, <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">max</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> code &lt;= <span class="built_in">max</span> &amp;&amp; test_bit(code, bm);           <span class="comment">//没超过事件的最大值，并且 1 &lt;&lt; code &amp; *bm != 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模糊绝对坐标</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_defuzz_abs_event</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> old_val, <span class="keyword">int</span> fuzz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (fuzz) &#123;</span><br><span class="line">		<span class="keyword">if</span> (value &gt; old_val - fuzz / <span class="number">2</span> &amp;&amp; value &lt; old_val + fuzz / <span class="number">2</span>)</span><br><span class="line">			<span class="keyword">return</span> old_val;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (value &gt; old_val - fuzz &amp;&amp; value &lt; old_val + fuzz)</span><br><span class="line">			<span class="keyword">return</span> (old_val * <span class="number">3</span> + value) / <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (value &gt; old_val - fuzz * <span class="number">2</span> &amp;&amp; value &lt; old_val + fuzz * <span class="number">2</span>)</span><br><span class="line">			<span class="keyword">return</span> (old_val + value) / <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动重复做某一事件码,在设备驱动中我们可以调用此借口使核心层定时上传event,而不用在设备驱动中使用定时器</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">input_start_autorepeat</span><span class="params">(struct input_dev *dev, <span class="keyword">int</span> code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (test_bit(EV_REP, dev-&gt;evbit) &amp;&amp;</span><br><span class="line">	    dev-&gt;rep[REP_PERIOD] &amp;&amp; dev-&gt;rep[REP_DELAY] &amp;&amp;</span><br><span class="line">	    dev-&gt;timer.data) &#123;</span><br><span class="line">		dev-&gt;repeat_key = code;</span><br><span class="line">		mod_timer(&amp;dev-&gt;timer,</span><br><span class="line">			  jiffies + msecs_to_jiffies(dev-&gt;rep[REP_DELAY])); <span class="comment">//ms转jiffies</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//停止自动重复</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">input_stop_autorepeat</span><span class="params">(struct input_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	del_timer(&amp;dev-&gt;timer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Pass event first through all filters and then, if event has not been</span></span><br><span class="line"><span class="comment"> * filtered out, through all open handles. This function is called with</span></span><br><span class="line"><span class="comment"> * dev-&gt;event_lock held and interrupts disabled.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//由input得到对应的handler，怎么得到呢？就是查看由所有handler的filter函数决定，</span></span><br><span class="line"><span class="comment">//如果某一个handler能够处理某一类型的event 和 code</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">input_to_handler</span><span class="params">(struct input_handle *handle,</span></span></span><br><span class="line"><span class="function"><span class="params">			struct input_value *vals, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span> = <span class="title">handle</span>-&gt;<span class="title">handler</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">end</span> = <span class="title">vals</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">v</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (handler-&gt;filter) &#123;</span><br><span class="line">		<span class="keyword">for</span> (v = vals; v != vals + count; v++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (handler-&gt;filter(handle, v-&gt;type, v-&gt;code, v-&gt;value))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">end</span> != v)</span><br><span class="line">				*<span class="built_in">end</span> = *v;</span><br><span class="line">			<span class="built_in">end</span>++;      <span class="comment">//如果上面有一个通过-continue,那么 count = 0;,直接返回0</span></span><br><span class="line">		&#125;</span><br><span class="line">		count = <span class="built_in">end</span> - vals;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!count)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果handler函数实现的序列处理，那么就调用序列处理，否则以一个调用event</span></span><br><span class="line">	<span class="keyword">if</span> (handler-&gt;events)</span><br><span class="line">		handler-&gt;events(handle, vals, count);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (handler-&gt;event)</span><br><span class="line">		<span class="keyword">for</span> (v = vals; v != vals + count; v++)</span><br><span class="line">			handler-&gt;event(handle, v-&gt;type, v-&gt;code, v-&gt;value);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Pass values first through all filters and then, if event has not been</span></span><br><span class="line"><span class="comment"> * filtered out, through all open handles. This function is called with</span></span><br><span class="line"><span class="comment"> * dev-&gt;event_lock held and interrupts disabled.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//上传某一个值的时候，需要先通过所有的filter</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">input_pass_values</span><span class="params">(struct input_dev *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">			      struct input_value *vals, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> *<span class="title">handle</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">v</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!count)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line"></span><br><span class="line">	handle = rcu_dereference(dev-&gt;grab);</span><br><span class="line">	<span class="keyword">if</span> (handle) &#123;</span><br><span class="line">        <span class="comment">//如果传入参数指定了handl,那么就传人指定的handle，否则在列表中一个个尝试</span></span><br><span class="line">		count = input_to_handler(handle, vals, count);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		list_for_each_entry_rcu(handle, &amp;dev-&gt;h_list, d_node)</span><br><span class="line">			<span class="keyword">if</span> (handle-&gt;<span class="built_in">open</span>) &#123;</span><br><span class="line">				count = input_to_handler(handle, vals, count);</span><br><span class="line">				<span class="keyword">if</span> (!count)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* trigger auto repeat for key events */</span></span><br><span class="line">    <span class="comment">//如果该设备设置了重复位，就启动重复上传</span></span><br><span class="line">	<span class="keyword">if</span> (test_bit(EV_REP, dev-&gt;evbit) &amp;&amp; test_bit(EV_KEY, dev-&gt;evbit)) &#123;</span><br><span class="line">		<span class="keyword">for</span> (v = vals; v != vals + count; v++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (v-&gt;type == EV_KEY &amp;&amp; v-&gt;value != <span class="number">2</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (v-&gt;value)</span><br><span class="line">					input_start_autorepeat(dev, v-&gt;code);</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					input_stop_autorepeat(dev);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">input_pass_event</span><span class="params">(struct input_dev *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">			     <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> <span class="title">vals</span>[] = &#123;</span> &#123; type, code, value &#125; &#125;;</span><br><span class="line"></span><br><span class="line">	input_pass_values(dev, vals, ARRAY_SIZE(vals));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Generate software autorepeat event. Note that we take</span></span><br><span class="line"><span class="comment"> * dev-&gt;event_lock here to avoid racing with input_event</span></span><br><span class="line"><span class="comment"> * which may cause keys get "stuck".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//重复上传事件的具体实现函数，在上传事件后，修改定时器</span></span><br><span class="line"><span class="comment">//前面的auto_repeat_start只是启动了重复上传的定时器，并没有上传具体事件（值）</span></span><br><span class="line"><span class="comment">//注意在这里会使用自旋锁防止竞争</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">input_repeat_key</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span> = (<span class="title">void</span> *) <span class="title">data</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;dev-&gt;event_lock, flags); <span class="comment">//在得到锁之后会保存中断信息</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (test_bit(dev-&gt;repeat_key, dev-&gt;key) &amp;&amp;</span><br><span class="line">	    is_event_supported(dev-&gt;repeat_key, dev-&gt;keybit, KEY_MAX)) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> <span class="title">vals</span>[] =  &#123;</span></span><br><span class="line">			&#123; EV_KEY, dev-&gt;repeat_key, <span class="number">2</span> &#125;,</span><br><span class="line">			input_value_sync</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		input_pass_values(dev, vals, ARRAY_SIZE(vals));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (dev-&gt;rep[REP_PERIOD])</span><br><span class="line">			mod_timer(&amp;dev-&gt;timer, jiffies +</span><br><span class="line">					msecs_to_jiffies(dev-&gt;rep[REP_PERIOD]));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	spin_unlock_irqrestore(&amp;dev-&gt;event_lock, flags);    <span class="comment">//还原中断信息，为的是在得到锁的期间的其他输入在之后能够接着被处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INPUT_IGNORE_EVENT	0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INPUT_PASS_TO_HANDLERS	1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INPUT_PASS_TO_DEVICE	2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INPUT_SLOT		4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INPUT_FLUSH		8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INPUT_PASS_TO_ALL	(INPUT_PASS_TO_HANDLERS | INPUT_PASS_TO_DEVICE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ABS事件的处理函数，在input_get_disposition函数中根据事件类型进行调用，</span></span><br><span class="line"><span class="comment">//在该函数中并没有与handler进行交互</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_handle_abs_event</span><span class="params">(struct input_dev *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">				  <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> *pval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_mt</span> *<span class="title">mt</span> = <span class="title">dev</span>-&gt;<span class="title">mt</span>;</span></span><br><span class="line">	<span class="keyword">bool</span> is_mt_event;</span><br><span class="line">	<span class="keyword">int</span> *pold;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (code == ABS_MT_SLOT) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * "Stage" the event; we'll flush it later, when we</span></span><br><span class="line"><span class="comment">		 * get actual touch data.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (mt &amp;&amp; *pval &gt;= <span class="number">0</span> &amp;&amp; *pval &lt; mt-&gt;num_slots)</span><br><span class="line">			mt-&gt;slot = *pval;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> INPUT_IGNORE_EVENT;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	is_mt_event = input_is_mt_value(code);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!is_mt_event) &#123;</span><br><span class="line">		pold = &amp;dev-&gt;absinfo[code].value;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mt) &#123;</span><br><span class="line">		pold = &amp;mt-&gt;slots[mt-&gt;slot].<span class="built_in">abs</span>[code - ABS_MT_FIRST];</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Bypass filtering for multi-touch events when</span></span><br><span class="line"><span class="comment">		 * not employing slots.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		pold = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pold) &#123;</span><br><span class="line">		*pval = input_defuzz_abs_event(*pval, *pold,</span><br><span class="line">						dev-&gt;absinfo[code].fuzz);</span><br><span class="line">		<span class="keyword">if</span> (*pold == *pval)</span><br><span class="line">			<span class="keyword">return</span> INPUT_IGNORE_EVENT;</span><br><span class="line"></span><br><span class="line">		*pold = *pval;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Flush pending "slot" event */</span></span><br><span class="line">	<span class="keyword">if</span> (is_mt_event &amp;&amp; mt &amp;&amp; mt-&gt;slot != input_abs_get_val(dev, ABS_MT_SLOT)) &#123;</span><br><span class="line">		input_abs_set_val(dev, ABS_MT_SLOT, mt-&gt;slot);</span><br><span class="line">		<span class="keyword">return</span> INPUT_PASS_TO_HANDLERS | INPUT_SLOT;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> INPUT_PASS_TO_HANDLERS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到事件要发送的目的地</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_get_disposition</span><span class="params">(struct input_dev *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">			  <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> *pval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> disposition = INPUT_IGNORE_EVENT;</span><br><span class="line">	<span class="keyword">int</span> value = *pval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (type) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_SYN:</span><br><span class="line">		<span class="keyword">switch</span> (code) &#123;</span><br><span class="line">		<span class="keyword">case</span> SYN_CONFIG:</span><br><span class="line">			disposition = INPUT_PASS_TO_ALL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> SYN_REPORT:</span><br><span class="line">			disposition = INPUT_PASS_TO_HANDLERS | INPUT_FLUSH;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SYN_MT_REPORT:</span><br><span class="line">			disposition = INPUT_PASS_TO_HANDLERS;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_KEY:</span><br><span class="line">		<span class="keyword">if</span> (is_event_supported(code, dev-&gt;keybit, KEY_MAX)) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* auto-repeat bypasses state updates */</span></span><br><span class="line">            <span class="comment">//按键事件值不是2的时候，就直接传送给所有的handler</span></span><br><span class="line">			<span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</span><br><span class="line">				disposition = INPUT_PASS_TO_HANDLERS;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//不是2时，进行相应转换，即 value转换为 1&lt;&lt;value，</span></span><br><span class="line">            <span class="comment">//在设备驱动层与handler的值表示方法有差异， n = 1&lt;&lt;n</span></span><br><span class="line">			<span class="keyword">if</span> (!!test_bit(code, dev-&gt;key) != !!value) &#123;</span><br><span class="line">				__change_bit(code, dev-&gt;key);</span><br><span class="line">				disposition = INPUT_PASS_TO_HANDLERS;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_SW:</span><br><span class="line">		<span class="keyword">if</span> (is_event_supported(code, dev-&gt;swbit, SW_MAX) &amp;&amp;</span><br><span class="line">		    !!test_bit(code, dev-&gt;sw) != !!value) &#123;</span><br><span class="line"></span><br><span class="line">			__change_bit(code, dev-&gt;sw);</span><br><span class="line">			disposition = INPUT_PASS_TO_HANDLERS;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_ABS:</span><br><span class="line">		<span class="keyword">if</span> (is_event_supported(code, dev-&gt;absbit, ABS_MAX))</span><br><span class="line">			disposition = input_handle_abs_event(dev, code, &amp;value);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_REL:</span><br><span class="line">		<span class="keyword">if</span> (is_event_supported(code, dev-&gt;relbit, REL_MAX) &amp;&amp; value)</span><br><span class="line">			disposition = INPUT_PASS_TO_HANDLERS;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_MSC:</span><br><span class="line">		<span class="keyword">if</span> (is_event_supported(code, dev-&gt;mscbit, MSC_MAX))</span><br><span class="line">			disposition = INPUT_PASS_TO_ALL;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_LED:</span><br><span class="line">		<span class="keyword">if</span> (is_event_supported(code, dev-&gt;ledbit, LED_MAX) &amp;&amp;</span><br><span class="line">		    !!test_bit(code, dev-&gt;led) != !!value) &#123;</span><br><span class="line"></span><br><span class="line">			__change_bit(code, dev-&gt;led);</span><br><span class="line">			disposition = INPUT_PASS_TO_ALL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_SND:</span><br><span class="line">		<span class="keyword">if</span> (is_event_supported(code, dev-&gt;sndbit, SND_MAX)) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!!test_bit(code, dev-&gt;snd) != !!value)</span><br><span class="line">				__change_bit(code, dev-&gt;snd);</span><br><span class="line">			disposition = INPUT_PASS_TO_ALL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_REP:</span><br><span class="line">		<span class="keyword">if</span> (code &lt;= REP_MAX &amp;&amp; value &gt;= <span class="number">0</span> &amp;&amp; dev-&gt;rep[code] != value) &#123;</span><br><span class="line">			dev-&gt;rep[code] = value;</span><br><span class="line">			disposition = INPUT_PASS_TO_ALL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_FF:</span><br><span class="line">		<span class="keyword">if</span> (value &gt;= <span class="number">0</span>)</span><br><span class="line">			disposition = INPUT_PASS_TO_ALL;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_PWR:</span><br><span class="line">		disposition = INPUT_PASS_TO_ALL;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*pval = value;</span><br><span class="line">	<span class="keyword">return</span> disposition;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"><span class="comment">//该函数为核心层事件处理的核心函数，依据 设备 事件类型 事件值 进行相应的上传</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">input_handle_event</span><span class="params">(struct input_dev *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">			       <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> disposition = input_get_disposition(dev, type, code, &amp;value);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (disposition != INPUT_IGNORE_EVENT &amp;&amp; type != EV_SYN)</span><br><span class="line">		add_input_randomness(type, code, value);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((disposition &amp; INPUT_PASS_TO_DEVICE) &amp;&amp; dev-&gt;event)</span><br><span class="line">		dev-&gt;event(dev, type, code, value);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;vals)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传送给handler的事件处理</span></span><br><span class="line">	<span class="keyword">if</span> (disposition &amp; INPUT_PASS_TO_HANDLERS) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">v</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (disposition &amp; INPUT_SLOT) &#123;</span><br><span class="line">			v = &amp;dev-&gt;vals[dev-&gt;num_vals++];</span><br><span class="line">			v-&gt;type = EV_ABS;</span><br><span class="line">			v-&gt;code = ABS_MT_SLOT;</span><br><span class="line">			v-&gt;value = dev-&gt;mt-&gt;slot;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		v = &amp;dev-&gt;vals[dev-&gt;num_vals++];</span><br><span class="line">		v-&gt;type = type;</span><br><span class="line">		v-&gt;code = code;</span><br><span class="line">		v-&gt;value = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (disposition &amp; INPUT_FLUSH) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dev-&gt;num_vals &gt;= <span class="number">2</span>)</span><br><span class="line">			input_pass_values(dev, dev-&gt;vals, dev-&gt;num_vals);</span><br><span class="line">		dev-&gt;num_vals = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (dev-&gt;num_vals &gt;= dev-&gt;max_vals - <span class="number">2</span>) &#123;</span><br><span class="line">		dev-&gt;vals[dev-&gt;num_vals++] = input_value_sync;</span><br><span class="line">		input_pass_values(dev, dev-&gt;vals, dev-&gt;num_vals);</span><br><span class="line">		dev-&gt;num_vals = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_event() - report new input event</span></span><br><span class="line"><span class="comment"> * @dev: device that generated the event</span></span><br><span class="line"><span class="comment"> * @type: type of the event</span></span><br><span class="line"><span class="comment"> * @code: event code</span></span><br><span class="line"><span class="comment"> * @value: value of the event</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function should be used by drivers implementing various input</span></span><br><span class="line"><span class="comment"> * devices to report input events. See also input_inject_event().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> input_event() may be safely used right after input device was</span></span><br><span class="line"><span class="comment"> * allocated with input_allocate_device(), even before it is registered</span></span><br><span class="line"><span class="comment"> * with input_register_device(), but the event will not reach any of the</span></span><br><span class="line"><span class="comment"> * input handlers. Such early invocation of input_event() may be used</span></span><br><span class="line"><span class="comment"> * to 'seed' initial state of a switch or initial position of absolute</span></span><br><span class="line"><span class="comment"> * axis, etc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//调用上一个函数，只不过加了自旋锁保护，同时也是一个对外的接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_event</span><span class="params">(struct input_dev *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">		 <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (is_event_supported(type, dev-&gt;evbit, EV_MAX)) &#123;</span><br><span class="line"></span><br><span class="line">		spin_lock_irqsave(&amp;dev-&gt;event_lock, flags);</span><br><span class="line">		input_handle_event(dev, type, code, value);</span><br><span class="line">		spin_unlock_irqrestore(&amp;dev-&gt;event_lock, flags);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_event);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_inject_event() - send input event from input handler</span></span><br><span class="line"><span class="comment"> * @handle: input handle to send event through</span></span><br><span class="line"><span class="comment"> * @type: type of the event</span></span><br><span class="line"><span class="comment"> * @code: event code</span></span><br><span class="line"><span class="comment"> * @value: value of the event</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Similar to input_event() but will ignore event if device is</span></span><br><span class="line"><span class="comment"> * "grabbed" and handle injecting event is not the one that owns</span></span><br><span class="line"><span class="comment"> * the device.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//这个是handler调用的事件处理接口，当某一个handler不能处理上传给它的一个事件时、</span></span><br><span class="line"><span class="comment">//可以调用这个接口，进行反馈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_inject_event</span><span class="params">(struct input_handle *handle,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span> = <span class="title">handle</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> *<span class="title">grab</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (is_event_supported(type, dev-&gt;evbit, EV_MAX)) &#123;</span><br><span class="line">		spin_lock_irqsave(&amp;dev-&gt;event_lock, flags);</span><br><span class="line"></span><br><span class="line">		rcu_read_lock();</span><br><span class="line">		grab = rcu_dereference(dev-&gt;grab);</span><br><span class="line">		<span class="keyword">if</span> (!grab || grab == handle)</span><br><span class="line">			input_handle_event(dev, type, code, value);</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">		spin_unlock_irqrestore(&amp;dev-&gt;event_lock, flags);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_inject_event);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_alloc_absinfo - allocates array of input_absinfo structs</span></span><br><span class="line"><span class="comment"> * @dev: the input device emitting absolute events</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the absinfo struct the caller asked for is already allocated, this</span></span><br><span class="line"><span class="comment"> * functions will not do anything.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//为abs事件分配 abs_info结构体</span></span><br><span class="line"><span class="comment">//在input_set_abs_params中调用，这也就意味着如果你有ABS事件，那么你需要调用set_params接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_alloc_absinfo</span><span class="params">(struct input_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;absinfo)</span><br><span class="line">		dev-&gt;absinfo = kcalloc(ABS_CNT, <span class="keyword">sizeof</span>(*dev-&gt;absinfo),</span><br><span class="line">					GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">	WARN(!dev-&gt;absinfo, <span class="string">"%s(): kcalloc() failed?\n"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_alloc_absinfo);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_set_abs_params</span><span class="params">(struct input_dev *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> axis,</span></span></span><br><span class="line"><span class="function"><span class="params">			  <span class="keyword">int</span> <span class="built_in">min</span>, <span class="keyword">int</span> <span class="built_in">max</span>, <span class="keyword">int</span> fuzz, <span class="keyword">int</span> flat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_absinfo</span> *<span class="title">absinfo</span>;</span></span><br><span class="line"></span><br><span class="line">	input_alloc_absinfo(dev);</span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;absinfo)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	absinfo = &amp;dev-&gt;absinfo[axis];</span><br><span class="line">	absinfo-&gt;minimum = <span class="built_in">min</span>;</span><br><span class="line">	absinfo-&gt;maximum = <span class="built_in">max</span>;</span><br><span class="line">	absinfo-&gt;fuzz = fuzz;</span><br><span class="line">	absinfo-&gt;flat = flat;</span><br><span class="line"></span><br><span class="line">	__set_bit(EV_ABS, dev-&gt;evbit);</span><br><span class="line">	__set_bit(axis, dev-&gt;absbit);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_set_abs_params);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_grab_device - grabs device for exclusive use</span></span><br><span class="line"><span class="comment"> * @handle: input handle that wants to own the device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When a device is grabbed by an input handle all events generated by</span></span><br><span class="line"><span class="comment"> * the device are delivered only to this handle. Also events injected</span></span><br><span class="line"><span class="comment"> * by other input handles are ignored while device is grabbed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//得到某个设备做排他使用，即如果某个handler得到了某个设备，那么这个设备产生的所有事件将只发送给这一个handler</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_grab_device</span><span class="params">(struct input_handle *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span> = <span class="title">handle</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">	retval = mutex_lock_interruptible(&amp;dev-&gt;mutex);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;grab) &#123;</span><br><span class="line">		retval = -EBUSY;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rcu_assign_pointer(dev-&gt;grab, handle);</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">	mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_grab_device);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放独占设备</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __input_release_device(struct input_handle *handle)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span> = <span class="title">handle</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> *<span class="title">grabber</span>;</span></span><br><span class="line"></span><br><span class="line">	grabber = rcu_dereference_protected(dev-&gt;grab,</span><br><span class="line">					    lockdep_is_held(&amp;dev-&gt;mutex));</span><br><span class="line">	<span class="keyword">if</span> (grabber == handle) &#123;</span><br><span class="line">		rcu_assign_pointer(dev-&gt;grab, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="comment">/* Make sure input_pass_event() notices that grab is gone */</span></span><br><span class="line">		synchronize_rcu();</span><br><span class="line"></span><br><span class="line">		list_for_each_entry(handle, &amp;dev-&gt;h_list, d_node)</span><br><span class="line">			<span class="keyword">if</span> (handle-&gt;<span class="built_in">open</span> &amp;&amp; handle-&gt;handler-&gt;start)</span><br><span class="line">				handle-&gt;handler-&gt;start(handle);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_release_device - release previously grabbed device</span></span><br><span class="line"><span class="comment"> * @handle: input handle that owns the device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Releases previously grabbed device so that other input handles can</span></span><br><span class="line"><span class="comment"> * start receiving input events. Upon release all handlers attached</span></span><br><span class="line"><span class="comment"> * to the device have their start() method called so they have a change</span></span><br><span class="line"><span class="comment"> * to synchronize device state with the rest of the system.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_release_device</span><span class="params">(struct input_handle *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span> = <span class="title">handle</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;dev-&gt;mutex);</span><br><span class="line">	__input_release_device(handle);</span><br><span class="line">	mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_release_device);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_open_device - open input device</span></span><br><span class="line"><span class="comment"> * @handle: handle through which device is being accessed</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function should be called by input handlers when they</span></span><br><span class="line"><span class="comment"> * want to start receive events from given input device.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_open_device</span><span class="params">(struct input_handle *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//得到传入handle的dev</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span> = <span class="title">handle</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">	retval = mutex_lock_interruptible(&amp;dev-&gt;mutex);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;going_away) &#123;</span><br><span class="line">		retval = -ENODEV;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	handle-&gt;<span class="built_in">open</span>++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用对应dev-&gt;open打开设备，</span></span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;users++ &amp;&amp; dev-&gt;<span class="built_in">open</span>)</span><br><span class="line">		retval = dev-&gt;<span class="built_in">open</span>(dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (retval) &#123;</span><br><span class="line">		dev-&gt;users--;</span><br><span class="line">		<span class="keyword">if</span> (!--handle-&gt;<span class="built_in">open</span>) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Make sure we are not delivering any more events</span></span><br><span class="line"><span class="comment">			 * through this handle</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			synchronize_rcu();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">	mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_open_device);</span><br><span class="line"></span><br><span class="line"><span class="comment">//就是调用对应的flush函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_flush_device</span><span class="params">(struct input_handle *handle, struct file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span> = <span class="title">handle</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">	retval = mutex_lock_interruptible(&amp;dev-&gt;mutex);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;<span class="built_in">flush</span>)</span><br><span class="line">		retval = dev-&gt;<span class="built_in">flush</span>(dev, file);</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_flush_device);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_close_device - close input device</span></span><br><span class="line"><span class="comment"> * @handle: handle through which device is being accessed</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function should be called by input handlers when they</span></span><br><span class="line"><span class="comment"> * want to stop receive events from given input device.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_close_device</span><span class="params">(struct input_handle *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span> = <span class="title">handle</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;dev-&gt;mutex);</span><br><span class="line"></span><br><span class="line">	__input_release_device(handle);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!--dev-&gt;users &amp;&amp; dev-&gt;<span class="built_in">close</span>)</span><br><span class="line">		dev-&gt;<span class="built_in">close</span>(dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!--handle-&gt;<span class="built_in">open</span>) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * synchronize_rcu() makes sure that input_pass_event()</span></span><br><span class="line"><span class="comment">		 * completed and that no more input events are delivered</span></span><br><span class="line"><span class="comment">		 * through this handle</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		synchronize_rcu();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_close_device);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Simulate keyup events for all keys that are marked as pressed.</span></span><br><span class="line"><span class="comment"> * The function must be called with dev-&gt;event_lock held.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//模拟一个释放按键的动作，比如handler要断开与设备的联系，但设备正在按键按下期间，那么可能导致驱动 “stuck"</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">input_dev_release_keys</span><span class="params">(struct input_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> need_sync = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">int</span> code;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (is_event_supported(EV_KEY, dev-&gt;evbit, EV_MAX)) &#123;</span><br><span class="line">		for_each_set_bit(code, dev-&gt;key, KEY_CNT) &#123;</span><br><span class="line">			input_pass_event(dev, EV_KEY, code, <span class="number">0</span>);</span><br><span class="line">			need_sync = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (need_sync)</span><br><span class="line">			input_pass_event(dev, EV_SYN, SYN_REPORT, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">memset</span>(dev-&gt;key, <span class="number">0</span>, <span class="keyword">sizeof</span>(dev-&gt;key));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Prepare device for unregistering</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">input_disconnect_device</span><span class="params">(struct input_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> *<span class="title">handle</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Mark device as going away. Note that we take dev-&gt;mutex here</span></span><br><span class="line"><span class="comment">	 * not to protect access to dev-&gt;going_away but rather to ensure</span></span><br><span class="line"><span class="comment">	 * that there are no threads in the middle of input_open_device()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mutex_lock(&amp;dev-&gt;mutex);</span><br><span class="line">	dev-&gt;going_away = <span class="literal">true</span>;</span><br><span class="line">	mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line"></span><br><span class="line">	spin_lock_irq(&amp;dev-&gt;event_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Simulate keyup events for all pressed keys so that handlers</span></span><br><span class="line"><span class="comment">	 * are not left with "stuck" keys. The driver may continue</span></span><br><span class="line"><span class="comment">	 * generate events even after we done here but they will not</span></span><br><span class="line"><span class="comment">	 * reach any handlers.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	input_dev_release_keys(dev);</span><br><span class="line"></span><br><span class="line">	list_for_each_entry(handle, &amp;dev-&gt;h_list, d_node)</span><br><span class="line">		handle-&gt;<span class="built_in">open</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	spin_unlock_irq(&amp;dev-&gt;event_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_scancode_to_scalar() - converts scancode in &amp;struct input_keymap_entry</span></span><br><span class="line"><span class="comment"> * @ke: keymap entry containing scancode to be converted.</span></span><br><span class="line"><span class="comment"> * @scancode: pointer to the location where converted scancode should</span></span><br><span class="line"><span class="comment"> *	be stored.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is used to convert scancode stored in &amp;struct keymap_entry</span></span><br><span class="line"><span class="comment"> * into scalar form understood by legacy keymap handling methods. These</span></span><br><span class="line"><span class="comment"> * methods expect scancodes to be represented as 'unsigned int'.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//不同数据长度之间的转化</span></span><br><span class="line"><span class="comment">//如设备驱动层用的是8位长度，但handler层使用的32位长度，那么就需要转换</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_scancode_to_scalar</span><span class="params">(<span class="keyword">const</span> struct input_keymap_entry *ke,</span></span></span><br><span class="line"><span class="function"><span class="params">			     <span class="keyword">unsigned</span> <span class="keyword">int</span> *scancode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (ke-&gt;len) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		*scancode = *((u8 *)ke-&gt;scancode);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		*scancode = *((u16 *)ke-&gt;scancode);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">		*scancode = *((u32 *)ke-&gt;scancode);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_scancode_to_scalar);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Those routines handle the default case where no [gs]etkeycode() is</span></span><br><span class="line"><span class="comment"> * defined. In this case, an array indexed by the scancode is used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">input_fetch_keycode</span><span class="params">(struct input_dev *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">					<span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (dev-&gt;keycodesize) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> ((u8 *)dev-&gt;keycode)[index];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		<span class="keyword">return</span> ((u16 *)dev-&gt;keycode)[index];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> ((u32 *)dev-&gt;keycode)[index];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_default_getkeycode</span><span class="params">(struct input_dev *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">				    struct input_keymap_entry *ke)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> index;</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;keycodesize)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ke-&gt;flags &amp; INPUT_KEYMAP_BY_INDEX)</span><br><span class="line">		index = ke-&gt;index;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		error = input_scancode_to_scalar(ke, &amp;index);</span><br><span class="line">		<span class="keyword">if</span> (error)</span><br><span class="line">			<span class="keyword">return</span> error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (index &gt;= dev-&gt;keycodemax)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	ke-&gt;keycode = input_fetch_keycode(dev, index);</span><br><span class="line">	ke-&gt;index = index;</span><br><span class="line">	ke-&gt;len = <span class="keyword">sizeof</span>(index);</span><br><span class="line">	<span class="built_in">memcpy</span>(ke-&gt;scancode, &amp;index, <span class="keyword">sizeof</span>(index));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_default_setkeycode</span><span class="params">(struct input_dev *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">				    <span class="keyword">const</span> struct input_keymap_entry *ke,</span></span></span><br><span class="line"><span class="function"><span class="params">				    <span class="keyword">unsigned</span> <span class="keyword">int</span> *old_keycode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> index;</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;keycodesize)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ke-&gt;flags &amp; INPUT_KEYMAP_BY_INDEX) &#123;</span><br><span class="line">		index = ke-&gt;index;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		error = input_scancode_to_scalar(ke, &amp;index);</span><br><span class="line">		<span class="keyword">if</span> (error)</span><br><span class="line">			<span class="keyword">return</span> error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (index &gt;= dev-&gt;keycodemax)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;keycodesize &lt; <span class="keyword">sizeof</span>(ke-&gt;keycode) &amp;&amp;</span><br><span class="line">			(ke-&gt;keycode &gt;&gt; (dev-&gt;keycodesize * <span class="number">8</span>)))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (dev-&gt;keycodesize) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">			u8 *k = (u8 *)dev-&gt;keycode;</span><br><span class="line">			*old_keycode = k[index];</span><br><span class="line">			k[index] = ke-&gt;keycode;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">			u16 *k = (u16 *)dev-&gt;keycode;</span><br><span class="line">			*old_keycode = k[index];</span><br><span class="line">			k[index] = ke-&gt;keycode;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">default</span>: &#123;</span><br><span class="line">			u32 *k = (u32 *)dev-&gt;keycode;</span><br><span class="line">			*old_keycode = k[index];</span><br><span class="line">			k[index] = ke-&gt;keycode;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	__clear_bit(*old_keycode, dev-&gt;keybit);</span><br><span class="line">	__set_bit(ke-&gt;keycode, dev-&gt;keybit);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dev-&gt;keycodemax; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (input_fetch_keycode(dev, i) == *old_keycode) &#123;</span><br><span class="line">			__set_bit(*old_keycode, dev-&gt;keybit);</span><br><span class="line">			<span class="keyword">break</span>; <span class="comment">/* Setting the bit twice is useless, so break */</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_get_keycode - retrieve keycode currently mapped to a given scancode</span></span><br><span class="line"><span class="comment"> * @dev: input device which keymap is being queried</span></span><br><span class="line"><span class="comment"> * @ke: keymap entry</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function should be called by anyone interested in retrieving current</span></span><br><span class="line"><span class="comment"> * keymap. Presently evdev handlers use it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_get_keycode</span><span class="params">(struct input_dev *dev, struct input_keymap_entry *ke)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;dev-&gt;event_lock, flags);</span><br><span class="line">	retval = dev-&gt;getkeycode(dev, ke);</span><br><span class="line">	spin_unlock_irqrestore(&amp;dev-&gt;event_lock, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_get_keycode);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_set_keycode - attribute a keycode to a given scancode</span></span><br><span class="line"><span class="comment"> * @dev: input device which keymap is being updated</span></span><br><span class="line"><span class="comment"> * @ke: new keymap entry</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function should be called by anyone needing to update current</span></span><br><span class="line"><span class="comment"> * keymap. Presently keyboard and evdev handlers use it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_set_keycode</span><span class="params">(struct input_dev *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">		      <span class="keyword">const</span> struct input_keymap_entry *ke)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> old_keycode;</span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ke-&gt;keycode &gt; KEY_MAX)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;dev-&gt;event_lock, flags);</span><br><span class="line"></span><br><span class="line">	retval = dev-&gt;setkeycode(dev, ke, &amp;old_keycode);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make sure KEY_RESERVED did not get enabled. */</span></span><br><span class="line">	__clear_bit(KEY_RESERVED, dev-&gt;keybit);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Simulate keyup event if keycode is not present</span></span><br><span class="line"><span class="comment">	 * in the keymap anymore</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (test_bit(EV_KEY, dev-&gt;evbit) &amp;&amp;</span><br><span class="line">	    !is_event_supported(old_keycode, dev-&gt;keybit, KEY_MAX) &amp;&amp;</span><br><span class="line">	    __test_and_clear_bit(old_keycode, dev-&gt;key)) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> <span class="title">vals</span>[] =  &#123;</span></span><br><span class="line">			&#123; EV_KEY, old_keycode, <span class="number">0</span> &#125;,</span><br><span class="line">			input_value_sync</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		input_pass_values(dev, vals, ARRAY_SIZE(vals));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">	spin_unlock_irqrestore(&amp;dev-&gt;event_lock, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_set_keycode);</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数dev为设备驱动层的属性</span></span><br><span class="line"><span class="comment">//input_device_id为handler的属性</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">input_match_device_id</span><span class="params">(<span class="keyword">const</span> struct input_dev *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">			   <span class="keyword">const</span> struct input_device_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//先判断flag中是否设置了某一属性，如依据BUS VENDOR进行对比</span></span><br><span class="line">	<span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_BUS)</span><br><span class="line">		<span class="keyword">if</span> (id-&gt;bustype != dev-&gt;id.bustype)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_VENDOR)</span><br><span class="line">		<span class="keyword">if</span> (id-&gt;vendor != dev-&gt;id.vendor)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_PRODUCT)</span><br><span class="line">		<span class="keyword">if</span> (id-&gt;product != dev-&gt;id.product)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_VERSION)</span><br><span class="line">		<span class="keyword">if</span> (id-&gt;version != dev-&gt;id.version)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//确认input_device中设置的事件是否是handler能处理的子集</span></span><br><span class="line">	<span class="keyword">if</span> (!bitmap_subset(id-&gt;evbit, dev-&gt;evbit, EV_MAX) ||</span><br><span class="line">	    !bitmap_subset(id-&gt;keybit, dev-&gt;keybit, KEY_MAX) ||</span><br><span class="line">	    !bitmap_subset(id-&gt;relbit, dev-&gt;relbit, REL_MAX) ||</span><br><span class="line">	    !bitmap_subset(id-&gt;absbit, dev-&gt;absbit, ABS_MAX) ||</span><br><span class="line">	    !bitmap_subset(id-&gt;mscbit, dev-&gt;mscbit, MSC_MAX) ||</span><br><span class="line">	    !bitmap_subset(id-&gt;ledbit, dev-&gt;ledbit, LED_MAX) ||</span><br><span class="line">	    !bitmap_subset(id-&gt;sndbit, dev-&gt;sndbit, SND_MAX) ||</span><br><span class="line">	    !bitmap_subset(id-&gt;ffbit, dev-&gt;ffbit, FF_MAX) ||</span><br><span class="line">	    !bitmap_subset(id-&gt;swbit, dev-&gt;swbit, SW_MAX) ||</span><br><span class="line">	    !bitmap_subset(id-&gt;propbit, dev-&gt;propbit, INPUT_PROP_MAX)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_match_device_id);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> struct input_device_id *<span class="title">input_match_device</span><span class="params">(struct input_handler *handler,</span></span></span><br><span class="line"><span class="function"><span class="params">							struct input_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//依次将设备的与handler的Idtable进行对比</span></span><br><span class="line">	<span class="keyword">for</span> (id = handler-&gt;id_table; id-&gt;flags || id-&gt;driver_info; id++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (input_match_device_id(dev, id) &amp;&amp;</span><br><span class="line">		    (!handler-&gt;match || handler-&gt;match(handler, dev))) &#123;</span><br><span class="line">			<span class="keyword">return</span> id;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_attach_handler</span><span class="params">(struct input_dev *dev, struct input_handler *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id</span>;</span></span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">	id = input_match_device(handler, dev);</span><br><span class="line">	<span class="keyword">if</span> (!id)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对比通过后，通过connect建立联系</span></span><br><span class="line">	error = handler-&gt;<span class="built_in">connect</span>(handler, dev, id);</span><br><span class="line">	<span class="keyword">if</span> (error &amp;&amp; error != -ENODEV)</span><br><span class="line">		pr_err(<span class="string">"failed to attach handler %s to device %s, error: %d\n"</span>,</span><br><span class="line">		       handler-&gt;name, kobject_name(&amp;dev-&gt;dev.kobj), error);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_bits_to_string</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> buf_size,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">unsigned</span> <span class="keyword">long</span> bits, <span class="keyword">bool</span> skip_empty)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (in_compat_syscall()) &#123;</span><br><span class="line">		u32 dword = bits &gt;&gt; <span class="number">32</span>;</span><br><span class="line">		<span class="keyword">if</span> (dword || !skip_empty)</span><br><span class="line">			len += <span class="built_in">snprintf</span>(buf, buf_size, <span class="string">"%x "</span>, dword);</span><br><span class="line"></span><br><span class="line">		dword = bits &amp; <span class="number">0xffffffff</span>UL;</span><br><span class="line">		<span class="keyword">if</span> (dword || !skip_empty || len)</span><br><span class="line">			len += <span class="built_in">snprintf</span>(buf + len, <span class="built_in">max</span>(buf_size - len, <span class="number">0</span>),</span><br><span class="line">					<span class="string">"%x"</span>, dword);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (bits || !skip_empty)</span><br><span class="line">			len += <span class="built_in">snprintf</span>(buf, buf_size, <span class="string">"%lx"</span>, bits);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* !CONFIG_COMPAT */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_bits_to_string</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> buf_size,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">unsigned</span> <span class="keyword">long</span> bits, <span class="keyword">bool</span> skip_empty)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> bits || !skip_empty ?</span><br><span class="line">		<span class="built_in">snprintf</span>(buf, buf_size, <span class="string">"%lx"</span>, bits) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">proc_bus_input_dir</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(input_devices_poll_wait)</span></span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> input_devices_state;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input_wakeup_procfs_readers</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	input_devices_state++;</span><br><span class="line">	wake_up(&amp;input_devices_poll_wait);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">input_proc_devices_poll</span><span class="params">(struct file *file, poll_table *wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	poll_wait(file, &amp;input_devices_poll_wait, wait);</span><br><span class="line">	<span class="keyword">if</span> (file-&gt;f_version != input_devices_state) &#123;</span><br><span class="line">		file-&gt;f_version = input_devices_state;</span><br><span class="line">		<span class="keyword">return</span> POLLIN | POLLRDNORM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> input_seq_state &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="keyword">unsigned</span> short pos;</span><br><span class="line">		<span class="keyword">bool</span> mutex_acquired;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">void</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">input_devices_seq_start</span><span class="params">(struct seq_file *seq, <span class="keyword">loff_t</span> *pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> input_seq_state *state = (<span class="keyword">union</span> input_seq_state *)&amp;seq-&gt;<span class="keyword">private</span>;</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We need to fit into seq-&gt;private pointer */</span></span><br><span class="line">	BUILD_BUG_ON(<span class="keyword">sizeof</span>(<span class="keyword">union</span> input_seq_state) != <span class="keyword">sizeof</span>(seq-&gt;<span class="keyword">private</span>));</span><br><span class="line"></span><br><span class="line">	error = mutex_lock_interruptible(&amp;input_mutex);</span><br><span class="line">	<span class="keyword">if</span> (error) &#123;</span><br><span class="line">		state-&gt;mutex_acquired = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(error);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	state-&gt;mutex_acquired = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> seq_list_start(&amp;input_dev_list, *pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">input_devices_seq_next</span><span class="params">(struct seq_file *seq, <span class="keyword">void</span> *v, <span class="keyword">loff_t</span> *pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> seq_list_next(v, &amp;input_dev_list, pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">input_seq_stop</span><span class="params">(struct seq_file *seq, <span class="keyword">void</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> input_seq_state *state = (<span class="keyword">union</span> input_seq_state *)&amp;seq-&gt;<span class="keyword">private</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (state-&gt;mutex_acquired)</span><br><span class="line">		mutex_unlock(&amp;input_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">input_seq_print_bitmap</span><span class="params">(struct seq_file *seq, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">				   <span class="keyword">unsigned</span> <span class="keyword">long</span> *bitmap, <span class="keyword">int</span> <span class="built_in">max</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">bool</span> skip_empty = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">18</span>];</span><br><span class="line"></span><br><span class="line">	seq_printf(seq, <span class="string">"B: %s="</span>, name);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = BITS_TO_LONGS(<span class="built_in">max</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="keyword">if</span> (input_bits_to_string(buf, <span class="keyword">sizeof</span>(buf),</span><br><span class="line">					 bitmap[i], skip_empty)) &#123;</span><br><span class="line">			skip_empty = <span class="literal">false</span>;</span><br><span class="line">			seq_printf(seq, <span class="string">"%s%s"</span>, buf, i &gt; <span class="number">0</span> ? <span class="string">" "</span> : <span class="string">""</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If no output was produced print a single 0.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (skip_empty)</span><br><span class="line">		seq_putc(seq, <span class="string">'0'</span>);</span><br><span class="line"></span><br><span class="line">	seq_putc(seq, <span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_devices_seq_show</span><span class="params">(struct seq_file *seq, <span class="keyword">void</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span> = <span class="title">container_of</span>(<span class="title">v</span>, <span class="title">struct</span> <span class="title">input_dev</span>, <span class="title">node</span>);</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *path = kobject_get_path(&amp;dev-&gt;dev.kobj, GFP_KERNEL);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> *<span class="title">handle</span>;</span></span><br><span class="line"></span><br><span class="line">	seq_printf(seq, <span class="string">"I: Bus=%04x Vendor=%04x Product=%04x Version=%04x\n"</span>,</span><br><span class="line">		   dev-&gt;id.bustype, dev-&gt;id.vendor, dev-&gt;id.product, dev-&gt;id.version);</span><br><span class="line"></span><br><span class="line">	seq_printf(seq, <span class="string">"N: Name=\"%s\"\n"</span>, dev-&gt;name ? dev-&gt;name : <span class="string">""</span>);</span><br><span class="line">	seq_printf(seq, <span class="string">"P: Phys=%s\n"</span>, dev-&gt;phys ? dev-&gt;phys : <span class="string">""</span>);</span><br><span class="line">	seq_printf(seq, <span class="string">"S: Sysfs=%s\n"</span>, path ? path : <span class="string">""</span>);</span><br><span class="line">	seq_printf(seq, <span class="string">"U: Uniq=%s\n"</span>, dev-&gt;uniq ? dev-&gt;uniq : <span class="string">""</span>);</span><br><span class="line">	seq_puts(seq, <span class="string">"H: Handlers="</span>);</span><br><span class="line"></span><br><span class="line">	list_for_each_entry(handle, &amp;dev-&gt;h_list, d_node)</span><br><span class="line">		seq_printf(seq, <span class="string">"%s "</span>, handle-&gt;name);</span><br><span class="line">	seq_putc(seq, <span class="string">'\n'</span>);</span><br><span class="line"></span><br><span class="line">	input_seq_print_bitmap(seq, <span class="string">"PROP"</span>, dev-&gt;propbit, INPUT_PROP_MAX);</span><br><span class="line"></span><br><span class="line">	input_seq_print_bitmap(seq, <span class="string">"EV"</span>, dev-&gt;evbit, EV_MAX);</span><br><span class="line">	<span class="keyword">if</span> (test_bit(EV_KEY, dev-&gt;evbit))</span><br><span class="line">		input_seq_print_bitmap(seq, <span class="string">"KEY"</span>, dev-&gt;keybit, KEY_MAX);</span><br><span class="line">	<span class="keyword">if</span> (test_bit(EV_REL, dev-&gt;evbit))</span><br><span class="line">		input_seq_print_bitmap(seq, <span class="string">"REL"</span>, dev-&gt;relbit, REL_MAX);</span><br><span class="line">	<span class="keyword">if</span> (test_bit(EV_ABS, dev-&gt;evbit))</span><br><span class="line">		input_seq_print_bitmap(seq, <span class="string">"ABS"</span>, dev-&gt;absbit, ABS_MAX);</span><br><span class="line">	<span class="keyword">if</span> (test_bit(EV_MSC, dev-&gt;evbit))</span><br><span class="line">		input_seq_print_bitmap(seq, <span class="string">"MSC"</span>, dev-&gt;mscbit, MSC_MAX);</span><br><span class="line">	<span class="keyword">if</span> (test_bit(EV_LED, dev-&gt;evbit))</span><br><span class="line">		input_seq_print_bitmap(seq, <span class="string">"LED"</span>, dev-&gt;ledbit, LED_MAX);</span><br><span class="line">	<span class="keyword">if</span> (test_bit(EV_SND, dev-&gt;evbit))</span><br><span class="line">		input_seq_print_bitmap(seq, <span class="string">"SND"</span>, dev-&gt;sndbit, SND_MAX);</span><br><span class="line">	<span class="keyword">if</span> (test_bit(EV_FF, dev-&gt;evbit))</span><br><span class="line">		input_seq_print_bitmap(seq, <span class="string">"FF"</span>, dev-&gt;ffbit, FF_MAX);</span><br><span class="line">	<span class="keyword">if</span> (test_bit(EV_SW, dev-&gt;evbit))</span><br><span class="line">		input_seq_print_bitmap(seq, <span class="string">"SW"</span>, dev-&gt;swbit, SW_MAX);</span><br><span class="line"></span><br><span class="line">	seq_putc(seq, <span class="string">'\n'</span>);</span><br><span class="line"></span><br><span class="line">	kfree(path);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> <span class="title">input_devices_seq_ops</span> = &#123;</span></span><br><span class="line">	.start	= input_devices_seq_start,</span><br><span class="line">	.next	= input_devices_seq_next,</span><br><span class="line">	.<span class="built_in">stop</span>	= input_seq_stop,</span><br><span class="line">	.show	= input_devices_seq_show,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_proc_devices_open</span><span class="params">(struct inode *inode, struct file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> seq_open(file, &amp;input_devices_seq_ops);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">input_devices_fileops</span> = &#123;</span></span><br><span class="line">	.owner		= THIS_MODULE,</span><br><span class="line">	.<span class="built_in">open</span>		= input_proc_devices_open,</span><br><span class="line">	.poll		= input_proc_devices_poll,</span><br><span class="line">	.<span class="built_in">read</span>		= seq_read,</span><br><span class="line">	.llseek		= seq_lseek,</span><br><span class="line">	.<span class="built_in">release</span>	= seq_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">input_handlers_seq_start</span><span class="params">(struct seq_file *seq, <span class="keyword">loff_t</span> *pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> input_seq_state *state = (<span class="keyword">union</span> input_seq_state *)&amp;seq-&gt;<span class="keyword">private</span>;</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We need to fit into seq-&gt;private pointer */</span></span><br><span class="line">	BUILD_BUG_ON(<span class="keyword">sizeof</span>(<span class="keyword">union</span> input_seq_state) != <span class="keyword">sizeof</span>(seq-&gt;<span class="keyword">private</span>));</span><br><span class="line"></span><br><span class="line">	error = mutex_lock_interruptible(&amp;input_mutex);</span><br><span class="line">	<span class="keyword">if</span> (error) &#123;</span><br><span class="line">		state-&gt;mutex_acquired = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(error);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	state-&gt;mutex_acquired = <span class="literal">true</span>;</span><br><span class="line">	state-&gt;pos = *pos;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> seq_list_start(&amp;input_handler_list, *pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">input_handlers_seq_next</span><span class="params">(struct seq_file *seq, <span class="keyword">void</span> *v, <span class="keyword">loff_t</span> *pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> input_seq_state *state = (<span class="keyword">union</span> input_seq_state *)&amp;seq-&gt;<span class="keyword">private</span>;</span><br><span class="line"></span><br><span class="line">	state-&gt;pos = *pos + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> seq_list_next(v, &amp;input_handler_list, pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_handlers_seq_show</span><span class="params">(struct seq_file *seq, <span class="keyword">void</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span> = <span class="title">container_of</span>(<span class="title">v</span>, <span class="title">struct</span> <span class="title">input_handler</span>, <span class="title">node</span>);</span></span><br><span class="line">	<span class="keyword">union</span> input_seq_state *state = (<span class="keyword">union</span> input_seq_state *)&amp;seq-&gt;<span class="keyword">private</span>;</span><br><span class="line"></span><br><span class="line">	seq_printf(seq, <span class="string">"N: Number=%u Name=%s"</span>, state-&gt;pos, handler-&gt;name);</span><br><span class="line">	<span class="keyword">if</span> (handler-&gt;filter)</span><br><span class="line">		seq_puts(seq, <span class="string">" (filter)"</span>);</span><br><span class="line">	<span class="keyword">if</span> (handler-&gt;legacy_minors)</span><br><span class="line">		seq_printf(seq, <span class="string">" Minor=%d"</span>, handler-&gt;minor);</span><br><span class="line">	seq_putc(seq, <span class="string">'\n'</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> <span class="title">input_handlers_seq_ops</span> = &#123;</span></span><br><span class="line">	.start	= input_handlers_seq_start,</span><br><span class="line">	.next	= input_handlers_seq_next,</span><br><span class="line">	.<span class="built_in">stop</span>	= input_seq_stop,</span><br><span class="line">	.show	= input_handlers_seq_show,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_proc_handlers_open</span><span class="params">(struct inode *inode, struct file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> seq_open(file, &amp;input_handlers_seq_ops);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">input_handlers_fileops</span> = &#123;</span></span><br><span class="line">	.owner		= THIS_MODULE,</span><br><span class="line">	.<span class="built_in">open</span>		= input_proc_handlers_open,</span><br><span class="line">	.<span class="built_in">read</span>		= seq_read,</span><br><span class="line">	.llseek		= seq_lseek,</span><br><span class="line">	.<span class="built_in">release</span>	= seq_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">input_proc_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">entry</span>;</span></span><br><span class="line"></span><br><span class="line">	proc_bus_input_dir = proc_mkdir(<span class="string">"bus/input"</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!proc_bus_input_dir)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	entry = proc_create(<span class="string">"devices"</span>, <span class="number">0</span>, proc_bus_input_dir,</span><br><span class="line">			    &amp;input_devices_fileops);</span><br><span class="line">	<span class="keyword">if</span> (!entry)</span><br><span class="line">		<span class="keyword">goto</span> fail1;</span><br><span class="line"></span><br><span class="line">	entry = proc_create(<span class="string">"handlers"</span>, <span class="number">0</span>, proc_bus_input_dir,</span><br><span class="line">			    &amp;input_handlers_fileops);</span><br><span class="line">	<span class="keyword">if</span> (!entry)</span><br><span class="line">		<span class="keyword">goto</span> fail2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> fail2:	remove_proc_entry(<span class="string">"devices"</span>, proc_bus_input_dir);</span><br><span class="line"> fail1: remove_proc_entry(<span class="string">"bus/input"</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">input_proc_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	remove_proc_entry(<span class="string">"devices"</span>, proc_bus_input_dir);</span><br><span class="line">	remove_proc_entry(<span class="string">"handlers"</span>, proc_bus_input_dir);</span><br><span class="line">	remove_proc_entry(<span class="string">"bus/input"</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* !CONFIG_PROC_FS */</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input_wakeup_procfs_readers</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">input_proc_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input_proc_exit</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INPUT_DEV_STRING_ATTR_SHOW(name)				\</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">ssize_t</span> input_dev_show_#<span class="meta">#name(struct device *dev,		\</span></span><br><span class="line">				     <span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span> *<span class="title">attr</span>,	\</span></span><br><span class="line"><span class="class">				     <span class="title">char</span> *<span class="title">buf</span>)				\</span></span><br><span class="line"><span class="class">&#123;</span>									\</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">input_dev</span> = <span class="title">to_input_dev</span>(<span class="title">dev</span>);</span>		\</span><br><span class="line">									\</span><br><span class="line">	<span class="keyword">return</span> scnprintf(buf, PAGE_SIZE, <span class="string">"%s\n"</span>,			\</span><br><span class="line">			 input_dev-&gt;name ? input_dev-&gt;name : <span class="string">""</span>);	\</span><br><span class="line">&#125;									\</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEVICE_ATTR</span><span class="params">(name, S_IRUGO, input_dev_show_##name, <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">INPUT_DEV_STRING_ATTR_SHOW</span><span class="params">(name)</span></span>;</span><br><span class="line">INPUT_DEV_STRING_ATTR_SHOW(phys);</span><br><span class="line">INPUT_DEV_STRING_ATTR_SHOW(uniq);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_print_modalias_bits</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> <span class="built_in">size</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">				     <span class="keyword">char</span> name, <span class="keyword">unsigned</span> <span class="keyword">long</span> *bm,</span></span></span><br><span class="line"><span class="function"><span class="params">				     <span class="keyword">unsigned</span> <span class="keyword">int</span> min_bit, <span class="keyword">unsigned</span> <span class="keyword">int</span> max_bit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>, i;</span><br><span class="line"></span><br><span class="line">	len += <span class="built_in">snprintf</span>(buf, <span class="built_in">max</span>(<span class="built_in">size</span>, <span class="number">0</span>), <span class="string">"%c"</span>, name);</span><br><span class="line">	<span class="keyword">for</span> (i = min_bit; i &lt; max_bit; i++)</span><br><span class="line">		<span class="keyword">if</span> (bm[BIT_WORD(i)] &amp; BIT_MASK(i))</span><br><span class="line">			len += <span class="built_in">snprintf</span>(buf + len, <span class="built_in">max</span>(<span class="built_in">size</span> - len, <span class="number">0</span>), <span class="string">"%X,"</span>, i);</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_print_modalias</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> <span class="built_in">size</span>, struct input_dev *id,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">int</span> add_cr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">	len = <span class="built_in">snprintf</span>(buf, <span class="built_in">max</span>(<span class="built_in">size</span>, <span class="number">0</span>),</span><br><span class="line">		       <span class="string">"input:b%04Xv%04Xp%04Xe%04X-"</span>,</span><br><span class="line">		       id-&gt;id.bustype, id-&gt;id.vendor,</span><br><span class="line">		       id-&gt;id.product, id-&gt;id.version);</span><br><span class="line"></span><br><span class="line">	len += input_print_modalias_bits(buf + len, <span class="built_in">size</span> - len,</span><br><span class="line">				<span class="string">'e'</span>, id-&gt;evbit, <span class="number">0</span>, EV_MAX);</span><br><span class="line">	len += input_print_modalias_bits(buf + len, <span class="built_in">size</span> - len,</span><br><span class="line">				<span class="string">'k'</span>, id-&gt;keybit, KEY_MIN_INTERESTING, KEY_MAX);</span><br><span class="line">	len += input_print_modalias_bits(buf + len, <span class="built_in">size</span> - len,</span><br><span class="line">				<span class="string">'r'</span>, id-&gt;relbit, <span class="number">0</span>, REL_MAX);</span><br><span class="line">	len += input_print_modalias_bits(buf + len, <span class="built_in">size</span> - len,</span><br><span class="line">				<span class="string">'a'</span>, id-&gt;absbit, <span class="number">0</span>, ABS_MAX);</span><br><span class="line">	len += input_print_modalias_bits(buf + len, <span class="built_in">size</span> - len,</span><br><span class="line">				<span class="string">'m'</span>, id-&gt;mscbit, <span class="number">0</span>, MSC_MAX);</span><br><span class="line">	len += input_print_modalias_bits(buf + len, <span class="built_in">size</span> - len,</span><br><span class="line">				<span class="string">'l'</span>, id-&gt;ledbit, <span class="number">0</span>, LED_MAX);</span><br><span class="line">	len += input_print_modalias_bits(buf + len, <span class="built_in">size</span> - len,</span><br><span class="line">				<span class="string">'s'</span>, id-&gt;sndbit, <span class="number">0</span>, SND_MAX);</span><br><span class="line">	len += input_print_modalias_bits(buf + len, <span class="built_in">size</span> - len,</span><br><span class="line">				<span class="string">'f'</span>, id-&gt;ffbit, <span class="number">0</span>, FF_MAX);</span><br><span class="line">	len += input_print_modalias_bits(buf + len, <span class="built_in">size</span> - len,</span><br><span class="line">				<span class="string">'w'</span>, id-&gt;swbit, <span class="number">0</span>, SW_MAX);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (add_cr)</span><br><span class="line">		len += <span class="built_in">snprintf</span>(buf + len, <span class="built_in">max</span>(<span class="built_in">size</span> - len, <span class="number">0</span>), <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">input_dev_show_modalias</span><span class="params">(struct device *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">				       struct device_attribute *attr,</span></span></span><br><span class="line"><span class="function"><span class="params">				       <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">id</span> = <span class="title">to_input_dev</span>(<span class="title">dev</span>);</span></span><br><span class="line">	<span class="keyword">ssize_t</span> len;</span><br><span class="line"></span><br><span class="line">	len = input_print_modalias(buf, PAGE_SIZE, id, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">min_t</span>(<span class="keyword">int</span>, len, PAGE_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEVICE_ATTR</span><span class="params">(modalias, S_IRUGO, input_dev_show_modalias, <span class="literal">NULL</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_print_bitmap</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> buf_size, <span class="keyword">unsigned</span> <span class="keyword">long</span> *bitmap,</span></span></span><br><span class="line"><span class="function"><span class="params">			      <span class="keyword">int</span> <span class="built_in">max</span>, <span class="keyword">int</span> add_cr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">input_dev_show_properties</span><span class="params">(struct device *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">					 struct device_attribute *attr,</span></span></span><br><span class="line"><span class="function"><span class="params">					 <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">input_dev</span> = <span class="title">to_input_dev</span>(<span class="title">dev</span>);</span></span><br><span class="line">	<span class="keyword">int</span> len = input_print_bitmap(buf, PAGE_SIZE, input_dev-&gt;propbit,</span><br><span class="line">				     INPUT_PROP_MAX, <span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">min_t</span>(<span class="keyword">int</span>, len, PAGE_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEVICE_ATTR</span><span class="params">(properties, S_IRUGO, input_dev_show_properties, <span class="literal">NULL</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> *<span class="title">input_dev_attrs</span>[] = &#123;</span></span><br><span class="line">	&amp;dev_attr_name.attr,</span><br><span class="line">	&amp;dev_attr_phys.attr,</span><br><span class="line">	&amp;dev_attr_uniq.attr,</span><br><span class="line">	&amp;dev_attr_modalias.attr,</span><br><span class="line">	&amp;dev_attr_properties.attr,</span><br><span class="line">	<span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> <span class="title">input_dev_attr_group</span> = &#123;</span></span><br><span class="line">	.attrs	= input_dev_attrs,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INPUT_DEV_ID_ATTR(name)						\</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">ssize_t</span> input_dev_show_id_#<span class="meta">#name(struct device *dev,		\</span></span><br><span class="line">					<span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span> *<span class="title">attr</span>,	\</span></span><br><span class="line"><span class="class">					<span class="title">char</span> *<span class="title">buf</span>)			\</span></span><br><span class="line"><span class="class">&#123;</span>									\</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">input_dev</span> = <span class="title">to_input_dev</span>(<span class="title">dev</span>);</span>		\</span><br><span class="line">	<span class="keyword">return</span> scnprintf(buf, PAGE_SIZE, <span class="string">"%04x\n"</span>, input_dev-&gt;id.name);	\</span><br><span class="line">&#125;									\</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEVICE_ATTR</span><span class="params">(name, S_IRUGO, input_dev_show_id_##name, <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">INPUT_DEV_ID_ATTR</span><span class="params">(bustype)</span></span>;</span><br><span class="line">INPUT_DEV_ID_ATTR(vendor);</span><br><span class="line">INPUT_DEV_ID_ATTR(product);</span><br><span class="line">INPUT_DEV_ID_ATTR(version);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> *<span class="title">input_dev_id_attrs</span>[] = &#123;</span></span><br><span class="line">	&amp;dev_attr_bustype.attr,</span><br><span class="line">	&amp;dev_attr_vendor.attr,</span><br><span class="line">	&amp;dev_attr_product.attr,</span><br><span class="line">	&amp;dev_attr_version.attr,</span><br><span class="line">	<span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> <span class="title">input_dev_id_attr_group</span> = &#123;</span></span><br><span class="line">	.name	= <span class="string">"id"</span>,</span><br><span class="line">	.attrs	= input_dev_id_attrs,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_print_bitmap</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> buf_size, <span class="keyword">unsigned</span> <span class="keyword">long</span> *bitmap,</span></span></span><br><span class="line"><span class="function"><span class="params">			      <span class="keyword">int</span> <span class="built_in">max</span>, <span class="keyword">int</span> add_cr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">bool</span> skip_empty = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = BITS_TO_LONGS(<span class="built_in">max</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		len += input_bits_to_string(buf + len, <span class="built_in">max</span>(buf_size - len, <span class="number">0</span>),</span><br><span class="line">					    bitmap[i], skip_empty);</span><br><span class="line">		<span class="keyword">if</span> (len) &#123;</span><br><span class="line">			skip_empty = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">				len += <span class="built_in">snprintf</span>(buf + len, <span class="built_in">max</span>(buf_size - len, <span class="number">0</span>), <span class="string">" "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If no output was produced print a single 0.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">		len = <span class="built_in">snprintf</span>(buf, buf_size, <span class="string">"%d"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (add_cr)</span><br><span class="line">		len += <span class="built_in">snprintf</span>(buf + len, <span class="built_in">max</span>(buf_size - len, <span class="number">0</span>), <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INPUT_DEV_CAP_ATTR(ev, bm)					\</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">ssize_t</span> input_dev_show_cap_#<span class="meta">#bm(struct device *dev,		\</span></span><br><span class="line">				       <span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span> *<span class="title">attr</span>,	\</span></span><br><span class="line"><span class="class">				       <span class="title">char</span> *<span class="title">buf</span>)			\</span></span><br><span class="line"><span class="class">&#123;</span>									\</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">input_dev</span> = <span class="title">to_input_dev</span>(<span class="title">dev</span>);</span>		\</span><br><span class="line">	<span class="keyword">int</span> len = input_print_bitmap(buf, PAGE_SIZE,			\</span><br><span class="line">				     input_dev-&gt;bm##<span class="built_in">bit</span>, ev##_MAX,	\</span><br><span class="line">				     <span class="literal">true</span>);				\</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">min_t</span>(<span class="keyword">int</span>, len, PAGE_SIZE);				\</span><br><span class="line">&#125;									\</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEVICE_ATTR</span><span class="params">(bm, S_IRUGO, input_dev_show_cap_##bm, <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">INPUT_DEV_CAP_ATTR</span><span class="params">(EV, ev)</span></span>;</span><br><span class="line">INPUT_DEV_CAP_ATTR(KEY, key);</span><br><span class="line">INPUT_DEV_CAP_ATTR(REL, rel);</span><br><span class="line">INPUT_DEV_CAP_ATTR(ABS, <span class="built_in">abs</span>);</span><br><span class="line">INPUT_DEV_CAP_ATTR(MSC, msc);</span><br><span class="line">INPUT_DEV_CAP_ATTR(LED, led);</span><br><span class="line">INPUT_DEV_CAP_ATTR(SND, snd);</span><br><span class="line">INPUT_DEV_CAP_ATTR(FF, ff);</span><br><span class="line">INPUT_DEV_CAP_ATTR(SW, sw);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> *<span class="title">input_dev_caps_attrs</span>[] = &#123;</span></span><br><span class="line">	&amp;dev_attr_ev.attr,</span><br><span class="line">	&amp;dev_attr_key.attr,</span><br><span class="line">	&amp;dev_attr_rel.attr,</span><br><span class="line">	&amp;dev_attr_abs.attr,</span><br><span class="line">	&amp;dev_attr_msc.attr,</span><br><span class="line">	&amp;dev_attr_led.attr,</span><br><span class="line">	&amp;dev_attr_snd.attr,</span><br><span class="line">	&amp;dev_attr_ff.attr,</span><br><span class="line">	&amp;dev_attr_sw.attr,</span><br><span class="line">	<span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> <span class="title">input_dev_caps_attr_group</span> = &#123;</span></span><br><span class="line">	.name	= <span class="string">"capabilities"</span>,</span><br><span class="line">	.attrs	= input_dev_caps_attrs,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> *<span class="title">input_dev_attr_groups</span>[] = &#123;</span></span><br><span class="line">	&amp;input_dev_attr_group,</span><br><span class="line">	&amp;input_dev_id_attr_group,</span><br><span class="line">	&amp;input_dev_caps_attr_group,</span><br><span class="line">	<span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">input_dev_release</span><span class="params">(struct device *device)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span> = <span class="title">to_input_dev</span>(<span class="title">device</span>);</span></span><br><span class="line"></span><br><span class="line">	input_ff_destroy(dev);</span><br><span class="line">	input_mt_destroy_slots(dev);</span><br><span class="line">	kfree(dev-&gt;absinfo);</span><br><span class="line">	kfree(dev-&gt;vals);</span><br><span class="line">	kfree(dev);</span><br><span class="line"></span><br><span class="line">	module_put(THIS_MODULE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Input uevent interface - loading event handlers based on</span></span><br><span class="line"><span class="comment"> * device bitfields.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_add_uevent_bm_var</span><span class="params">(struct kobj_uevent_env *env,</span></span></span><br><span class="line"><span class="function"><span class="params">				   <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">unsigned</span> <span class="keyword">long</span> *bitmap, <span class="keyword">int</span> <span class="built_in">max</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (add_uevent_var(env, <span class="string">"%s"</span>, name))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	len = input_print_bitmap(&amp;env-&gt;buf[env-&gt;buflen - <span class="number">1</span>],</span><br><span class="line">				 <span class="keyword">sizeof</span>(env-&gt;buf) - env-&gt;buflen,</span><br><span class="line">				 bitmap, <span class="built_in">max</span>, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (len &gt;= (<span class="keyword">sizeof</span>(env-&gt;buf) - env-&gt;buflen))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	env-&gt;buflen += len;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_add_uevent_modalias_var</span><span class="params">(struct kobj_uevent_env *env,</span></span></span><br><span class="line"><span class="function"><span class="params">					 struct input_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (add_uevent_var(env, <span class="string">"MODALIAS="</span>))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	len = input_print_modalias(&amp;env-&gt;buf[env-&gt;buflen - <span class="number">1</span>],</span><br><span class="line">				   <span class="keyword">sizeof</span>(env-&gt;buf) - env-&gt;buflen,</span><br><span class="line">				   dev, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (len &gt;= (<span class="keyword">sizeof</span>(env-&gt;buf) - env-&gt;buflen))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	env-&gt;buflen += len;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INPUT_ADD_HOTPLUG_VAR(fmt, val...)				\</span></span><br><span class="line">	<span class="keyword">do</span> &#123;								\</span><br><span class="line">		<span class="keyword">int</span> err = add_uevent_var(env, fmt, val);		\</span><br><span class="line">		<span class="keyword">if</span> (err)						\</span><br><span class="line">			<span class="keyword">return</span> err;					\</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INPUT_ADD_HOTPLUG_BM_VAR(name, bm, max)				\</span></span><br><span class="line">	<span class="keyword">do</span> &#123;								\</span><br><span class="line">		<span class="keyword">int</span> err = input_add_uevent_bm_var(env, name, bm, <span class="built_in">max</span>);	\</span><br><span class="line">		<span class="keyword">if</span> (err)						\</span><br><span class="line">			<span class="keyword">return</span> err;					\</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INPUT_ADD_HOTPLUG_MODALIAS_VAR(dev)				\</span></span><br><span class="line">	<span class="keyword">do</span> &#123;								\</span><br><span class="line">		<span class="keyword">int</span> err = input_add_uevent_modalias_var(env, dev);	\</span><br><span class="line">		<span class="keyword">if</span> (err)						\</span><br><span class="line">			<span class="keyword">return</span> err;					\</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_dev_uevent</span><span class="params">(struct device *device, struct kobj_uevent_env *env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span> = <span class="title">to_input_dev</span>(<span class="title">device</span>);</span></span><br><span class="line"></span><br><span class="line">	INPUT_ADD_HOTPLUG_VAR(<span class="string">"PRODUCT=%x/%x/%x/%x"</span>,</span><br><span class="line">				dev-&gt;id.bustype, dev-&gt;id.vendor,</span><br><span class="line">				dev-&gt;id.product, dev-&gt;id.version);</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;name)</span><br><span class="line">		INPUT_ADD_HOTPLUG_VAR(<span class="string">"NAME=\"%s\""</span>, dev-&gt;name);</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;phys)</span><br><span class="line">		INPUT_ADD_HOTPLUG_VAR(<span class="string">"PHYS=\"%s\""</span>, dev-&gt;phys);</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;uniq)</span><br><span class="line">		INPUT_ADD_HOTPLUG_VAR(<span class="string">"UNIQ=\"%s\""</span>, dev-&gt;uniq);</span><br><span class="line"></span><br><span class="line">	INPUT_ADD_HOTPLUG_BM_VAR(<span class="string">"PROP="</span>, dev-&gt;propbit, INPUT_PROP_MAX);</span><br><span class="line"></span><br><span class="line">	INPUT_ADD_HOTPLUG_BM_VAR(<span class="string">"EV="</span>, dev-&gt;evbit, EV_MAX);</span><br><span class="line">	<span class="keyword">if</span> (test_bit(EV_KEY, dev-&gt;evbit))</span><br><span class="line">		INPUT_ADD_HOTPLUG_BM_VAR(<span class="string">"KEY="</span>, dev-&gt;keybit, KEY_MAX);</span><br><span class="line">	<span class="keyword">if</span> (test_bit(EV_REL, dev-&gt;evbit))</span><br><span class="line">		INPUT_ADD_HOTPLUG_BM_VAR(<span class="string">"REL="</span>, dev-&gt;relbit, REL_MAX);</span><br><span class="line">	<span class="keyword">if</span> (test_bit(EV_ABS, dev-&gt;evbit))</span><br><span class="line">		INPUT_ADD_HOTPLUG_BM_VAR(<span class="string">"ABS="</span>, dev-&gt;absbit, ABS_MAX);</span><br><span class="line">	<span class="keyword">if</span> (test_bit(EV_MSC, dev-&gt;evbit))</span><br><span class="line">		INPUT_ADD_HOTPLUG_BM_VAR(<span class="string">"MSC="</span>, dev-&gt;mscbit, MSC_MAX);</span><br><span class="line">	<span class="keyword">if</span> (test_bit(EV_LED, dev-&gt;evbit))</span><br><span class="line">		INPUT_ADD_HOTPLUG_BM_VAR(<span class="string">"LED="</span>, dev-&gt;ledbit, LED_MAX);</span><br><span class="line">	<span class="keyword">if</span> (test_bit(EV_SND, dev-&gt;evbit))</span><br><span class="line">		INPUT_ADD_HOTPLUG_BM_VAR(<span class="string">"SND="</span>, dev-&gt;sndbit, SND_MAX);</span><br><span class="line">	<span class="keyword">if</span> (test_bit(EV_FF, dev-&gt;evbit))</span><br><span class="line">		INPUT_ADD_HOTPLUG_BM_VAR(<span class="string">"FF="</span>, dev-&gt;ffbit, FF_MAX);</span><br><span class="line">	<span class="keyword">if</span> (test_bit(EV_SW, dev-&gt;evbit))</span><br><span class="line">		INPUT_ADD_HOTPLUG_BM_VAR(<span class="string">"SW="</span>, dev-&gt;swbit, SW_MAX);</span><br><span class="line"></span><br><span class="line">	INPUT_ADD_HOTPLUG_MODALIAS_VAR(dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INPUT_DO_TOGGLE(dev, type, bits, on)				\</span></span><br><span class="line">	<span class="keyword">do</span> &#123;								\</span><br><span class="line">		<span class="keyword">int</span> i;							\</span><br><span class="line">		<span class="keyword">bool</span> active;						\</span><br><span class="line">									\</span><br><span class="line">		<span class="keyword">if</span> (!test_bit(EV_##type, dev-&gt;evbit))			\</span><br><span class="line">			<span class="keyword">break</span>;						\</span><br><span class="line">									\</span><br><span class="line">		for_each_set_bit(i, dev-&gt;bits##<span class="built_in">bit</span>, type##_CNT) &#123;	\</span><br><span class="line">			active = test_bit(i, dev-&gt;bits);		\</span><br><span class="line">			<span class="keyword">if</span> (!active &amp;&amp; !on)				\</span><br><span class="line">				<span class="keyword">continue</span>;				\</span><br><span class="line">									\</span><br><span class="line">			dev-&gt;event(dev, EV_##type, i, on ? active : <span class="number">0</span>);	\</span><br><span class="line">		&#125;							\</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">input_dev_toggle</span><span class="params">(struct input_dev *dev, <span class="keyword">bool</span> activate)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;event)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	INPUT_DO_TOGGLE(dev, LED, led, activate);</span><br><span class="line">	INPUT_DO_TOGGLE(dev, SND, snd, activate);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (activate &amp;&amp; test_bit(EV_REP, dev-&gt;evbit)) &#123;</span><br><span class="line">		dev-&gt;event(dev, EV_REP, REP_PERIOD, dev-&gt;rep[REP_PERIOD]);</span><br><span class="line">		dev-&gt;event(dev, EV_REP, REP_DELAY, dev-&gt;rep[REP_DELAY]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_reset_device() - reset/restore the state of input device</span></span><br><span class="line"><span class="comment"> * @dev: input device whose state needs to be reset</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function tries to reset the state of an opened input device and</span></span><br><span class="line"><span class="comment"> * bring internal state and state if the hardware in sync with each other.</span></span><br><span class="line"><span class="comment"> * We mark all keys as released, restore LED state, repeat rate, etc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_reset_device</span><span class="params">(struct input_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;dev-&gt;mutex);</span><br><span class="line">	spin_lock_irqsave(&amp;dev-&gt;event_lock, flags);</span><br><span class="line"></span><br><span class="line">	input_dev_toggle(dev, <span class="literal">true</span>);</span><br><span class="line">	input_dev_release_keys(dev);</span><br><span class="line"></span><br><span class="line">	spin_unlock_irqrestore(&amp;dev-&gt;event_lock, flags);</span><br><span class="line">	mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_reset_device);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PM_SLEEP</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_dev_suspend</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">input_dev</span> = <span class="title">to_input_dev</span>(<span class="title">dev</span>);</span></span><br><span class="line"></span><br><span class="line">	spin_lock_irq(&amp;input_dev-&gt;event_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Keys that are pressed now are unlikely to be</span></span><br><span class="line"><span class="comment">	 * still pressed when we resume.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	input_dev_release_keys(input_dev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Turn off LEDs and sounds, if any are active. */</span></span><br><span class="line">	input_dev_toggle(input_dev, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">	spin_unlock_irq(&amp;input_dev-&gt;event_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_dev_resume</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">input_dev</span> = <span class="title">to_input_dev</span>(<span class="title">dev</span>);</span></span><br><span class="line"></span><br><span class="line">	spin_lock_irq(&amp;input_dev-&gt;event_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Restore state of LEDs and sounds, if any were active. */</span></span><br><span class="line">	input_dev_toggle(input_dev, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">	spin_unlock_irq(&amp;input_dev-&gt;event_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_dev_freeze</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">input_dev</span> = <span class="title">to_input_dev</span>(<span class="title">dev</span>);</span></span><br><span class="line"></span><br><span class="line">	spin_lock_irq(&amp;input_dev-&gt;event_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Keys that are pressed now are unlikely to be</span></span><br><span class="line"><span class="comment">	 * still pressed when we resume.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	input_dev_release_keys(input_dev);</span><br><span class="line"></span><br><span class="line">	spin_unlock_irq(&amp;input_dev-&gt;event_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_dev_poweroff</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">input_dev</span> = <span class="title">to_input_dev</span>(<span class="title">dev</span>);</span></span><br><span class="line"></span><br><span class="line">	spin_lock_irq(&amp;input_dev-&gt;event_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Turn off LEDs and sounds, if any are active. */</span></span><br><span class="line">	input_dev_toggle(input_dev, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">	spin_unlock_irq(&amp;input_dev-&gt;event_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> <span class="title">input_dev_pm_ops</span> = &#123;</span></span><br><span class="line">	.suspend	= input_dev_suspend,</span><br><span class="line">	.resume		= input_dev_resume,</span><br><span class="line">	.freeze		= input_dev_freeze,</span><br><span class="line">	.poweroff	= input_dev_poweroff,</span><br><span class="line">	.restore	= input_dev_resume,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_PM */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_type</span> <span class="title">input_dev_type</span> = &#123;</span></span><br><span class="line">	.groups		= input_dev_attr_groups,</span><br><span class="line">	.<span class="built_in">release</span>	= input_dev_release,</span><br><span class="line">	.uevent		= input_dev_uevent,</span><br><span class="line">#ifdef CONFIG_PM_SLEEP</span><br><span class="line">	.pm		= &amp;input_dev_pm_ops,</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">input_devnode</span><span class="params">(struct device *dev, <span class="keyword">umode_t</span> *mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> kasprintf(GFP_KERNEL, <span class="string">"input/%s"</span>, dev_name(dev));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class</span> <span class="title">input_class</span> = &#123;</span></span><br><span class="line">	.name		= <span class="string">"input"</span>,</span><br><span class="line">	.devnode	= input_devnode,</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL_GPL(input_class);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_allocate_device - allocate memory for new input device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns prepared struct input_dev or %NULL.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> Use input_free_device() to free devices that have not been</span></span><br><span class="line"><span class="comment"> * registered; input_unregister_device() should be used for already</span></span><br><span class="line"><span class="comment"> * registered devices.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct input_dev *<span class="title">input_allocate_device</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">atomic_t</span> input_no = ATOMIC_INIT(<span class="number">-1</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	dev = kzalloc(<span class="keyword">sizeof</span>(*dev), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (dev) &#123;</span><br><span class="line">		dev-&gt;dev.type = &amp;input_dev_type;</span><br><span class="line">		dev-&gt;dev<span class="class">.<span class="keyword">class</span> = &amp;<span class="title">input_class</span>;</span></span><br><span class="line">		device_initialize(&amp;dev-&gt;dev);</span><br><span class="line">		mutex_init(&amp;dev-&gt;mutex);</span><br><span class="line">		spin_lock_init(&amp;dev-&gt;event_lock);</span><br><span class="line">		init_timer(&amp;dev-&gt;timer);</span><br><span class="line">		INIT_LIST_HEAD(&amp;dev-&gt;h_list);</span><br><span class="line">		INIT_LIST_HEAD(&amp;dev-&gt;node);</span><br><span class="line"></span><br><span class="line">		dev_set_name(&amp;dev-&gt;dev, <span class="string">"input%lu"</span>,</span><br><span class="line">			     (<span class="keyword">unsigned</span> <span class="keyword">long</span>)atomic_inc_return(&amp;input_no));</span><br><span class="line"></span><br><span class="line">		__module_get(THIS_MODULE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dev;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_allocate_device);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_devres</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">input</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">devm_input_device_match</span><span class="params">(struct device *dev, <span class="keyword">void</span> *res, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_devres</span> *<span class="title">devres</span> = <span class="title">res</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> devres-&gt;input == data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">devm_input_device_release</span><span class="params">(struct device *dev, <span class="keyword">void</span> *res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_devres</span> *<span class="title">devres</span> = <span class="title">res</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">input</span> = <span class="title">devres</span>-&gt;<span class="title">input</span>;</span></span><br><span class="line"></span><br><span class="line">	dev_dbg(dev, <span class="string">"%s: dropping reference to %s\n"</span>,</span><br><span class="line">		__func__, dev_name(&amp;input-&gt;dev));</span><br><span class="line">	input_put_device(input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * devm_input_allocate_device - allocate managed input device</span></span><br><span class="line"><span class="comment"> * @dev: device owning the input device being created</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns prepared struct input_dev or %NULL.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Managed input devices do not need to be explicitly unregistered or</span></span><br><span class="line"><span class="comment"> * freed as it will be done automatically when owner device unbinds from</span></span><br><span class="line"><span class="comment"> * its driver (or binding fails). Once managed input device is allocated,</span></span><br><span class="line"><span class="comment"> * it is ready to be set up and registered in the same fashion as regular</span></span><br><span class="line"><span class="comment"> * input device. There are no special devm_input_device_[un]register()</span></span><br><span class="line"><span class="comment"> * variants, regular ones work with both managed and unmanaged devices,</span></span><br><span class="line"><span class="comment"> * should you need them. In most cases however, managed input device need</span></span><br><span class="line"><span class="comment"> * not be explicitly unregistered or freed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> the owner device is set up as parent of input device and users</span></span><br><span class="line"><span class="comment"> * should not override it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct input_dev *<span class="title">devm_input_allocate_device</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">input</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_devres</span> *<span class="title">devres</span>;</span></span><br><span class="line"></span><br><span class="line">	devres = devres_alloc(devm_input_device_release,</span><br><span class="line">			      <span class="keyword">sizeof</span>(*devres), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!devres)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	input = input_allocate_device();</span><br><span class="line">	<span class="keyword">if</span> (!input) &#123;</span><br><span class="line">		devres_free(devres);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	input-&gt;dev.parent = dev;</span><br><span class="line">	input-&gt;devres_managed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	devres-&gt;input = input;</span><br><span class="line">	devres_add(dev, devres);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> input;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(devm_input_allocate_device);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_free_device - free memory occupied by input_dev structure</span></span><br><span class="line"><span class="comment"> * @dev: input device to free</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function should only be used if input_register_device()</span></span><br><span class="line"><span class="comment"> * was not called yet or if it failed. Once device was registered</span></span><br><span class="line"><span class="comment"> * use input_unregister_device() and memory will be freed once last</span></span><br><span class="line"><span class="comment"> * reference to the device is dropped.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Device should be allocated by input_allocate_device().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> If there are references to the input device then memory</span></span><br><span class="line"><span class="comment"> * will not be freed until last reference is dropped.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_free_device</span><span class="params">(struct input_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dev) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dev-&gt;devres_managed)</span><br><span class="line">			WARN_ON(devres_destroy(dev-&gt;dev.parent,</span><br><span class="line">						devm_input_device_release,</span><br><span class="line">						devm_input_device_match,</span><br><span class="line">						dev));</span><br><span class="line">		input_put_device(dev);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_free_device);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_set_capability - mark device as capable of a certain event</span></span><br><span class="line"><span class="comment"> * @dev: device that is capable of emitting or accepting event</span></span><br><span class="line"><span class="comment"> * @type: type of the event (EV_KEY, EV_REL, etc...)</span></span><br><span class="line"><span class="comment"> * @code: event code</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * In addition to setting up corresponding bit in appropriate capability</span></span><br><span class="line"><span class="comment"> * bitmap the function also adjusts dev-&gt;evbit.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_set_capability</span><span class="params">(struct input_dev *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (type) &#123;</span><br><span class="line">	<span class="keyword">case</span> EV_KEY:</span><br><span class="line">		__set_bit(code, dev-&gt;keybit);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_REL:</span><br><span class="line">		__set_bit(code, dev-&gt;relbit);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_ABS:</span><br><span class="line">		input_alloc_absinfo(dev);</span><br><span class="line">		<span class="keyword">if</span> (!dev-&gt;absinfo)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		__set_bit(code, dev-&gt;absbit);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_MSC:</span><br><span class="line">		__set_bit(code, dev-&gt;mscbit);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_SW:</span><br><span class="line">		__set_bit(code, dev-&gt;swbit);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_LED:</span><br><span class="line">		__set_bit(code, dev-&gt;ledbit);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_SND:</span><br><span class="line">		__set_bit(code, dev-&gt;sndbit);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_FF:</span><br><span class="line">		__set_bit(code, dev-&gt;ffbit);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_PWR:</span><br><span class="line">		<span class="comment">/* do nothing */</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		pr_err(<span class="string">"input_set_capability: unknown type %u (code %u)\n"</span>,</span><br><span class="line">		       type, code);</span><br><span class="line">		dump_stack();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	__set_bit(type, dev-&gt;evbit);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_set_capability);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">input_estimate_events_per_packet</span><span class="params">(struct input_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> mt_slots;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> events;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;mt) &#123;</span><br><span class="line">		mt_slots = dev-&gt;mt-&gt;num_slots;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (test_bit(ABS_MT_TRACKING_ID, dev-&gt;absbit)) &#123;</span><br><span class="line">		mt_slots = dev-&gt;absinfo[ABS_MT_TRACKING_ID].maximum -</span><br><span class="line">			   dev-&gt;absinfo[ABS_MT_TRACKING_ID].minimum + <span class="number">1</span>,</span><br><span class="line">		mt_slots = clamp(mt_slots, <span class="number">2</span>, <span class="number">32</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (test_bit(ABS_MT_POSITION_X, dev-&gt;absbit)) &#123;</span><br><span class="line">		mt_slots = <span class="number">2</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		mt_slots = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	events = mt_slots + <span class="number">1</span>; <span class="comment">/* count SYN_MT_REPORT and SYN_REPORT */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (test_bit(EV_ABS, dev-&gt;evbit))</span><br><span class="line">		for_each_set_bit(i, dev-&gt;absbit, ABS_CNT)</span><br><span class="line">			events += input_is_mt_axis(i) ? mt_slots : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (test_bit(EV_REL, dev-&gt;evbit))</span><br><span class="line">		events += bitmap_weight(dev-&gt;relbit, REL_CNT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make room for KEY and MSC events */</span></span><br><span class="line">	events += <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> events;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INPUT_CLEANSE_BITMASK(dev, type, bits)				\</span></span><br><span class="line">	<span class="keyword">do</span> &#123;								\</span><br><span class="line">		<span class="keyword">if</span> (!test_bit(EV_##type, dev-&gt;evbit))			\</span><br><span class="line">			<span class="built_in">memset</span>(dev-&gt;bits##<span class="built_in">bit</span>, <span class="number">0</span>,			\</span><br><span class="line">				<span class="keyword">sizeof</span>(dev-&gt;bits##<span class="built_in">bit</span>));		\</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">input_cleanse_bitmasks</span><span class="params">(struct input_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	INPUT_CLEANSE_BITMASK(dev, KEY, key);</span><br><span class="line">	INPUT_CLEANSE_BITMASK(dev, REL, rel);</span><br><span class="line">	INPUT_CLEANSE_BITMASK(dev, ABS, <span class="built_in">abs</span>);</span><br><span class="line">	INPUT_CLEANSE_BITMASK(dev, MSC, msc);</span><br><span class="line">	INPUT_CLEANSE_BITMASK(dev, LED, led);</span><br><span class="line">	INPUT_CLEANSE_BITMASK(dev, SND, snd);</span><br><span class="line">	INPUT_CLEANSE_BITMASK(dev, FF, ff);</span><br><span class="line">	INPUT_CLEANSE_BITMASK(dev, SW, sw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __input_unregister_device(struct input_dev *dev)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> *<span class="title">handle</span>, *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">	input_disconnect_device(dev);</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;input_mutex);</span><br><span class="line"></span><br><span class="line">	list_for_each_entry_safe(handle, next, &amp;dev-&gt;h_list, d_node)</span><br><span class="line">		handle-&gt;handler-&gt;<span class="built_in">disconnect</span>(handle);</span><br><span class="line">	WARN_ON(!list_empty(&amp;dev-&gt;h_list));</span><br><span class="line"></span><br><span class="line">	del_timer_sync(&amp;dev-&gt;timer);</span><br><span class="line">	list_del_init(&amp;dev-&gt;node);</span><br><span class="line"></span><br><span class="line">	input_wakeup_procfs_readers();</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;input_mutex);</span><br><span class="line"></span><br><span class="line">	device_del(&amp;dev-&gt;dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">devm_input_device_unregister</span><span class="params">(struct device *dev, <span class="keyword">void</span> *res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_devres</span> *<span class="title">devres</span> = <span class="title">res</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">input</span> = <span class="title">devres</span>-&gt;<span class="title">input</span>;</span></span><br><span class="line"></span><br><span class="line">	dev_dbg(dev, <span class="string">"%s: unregistering device %s\n"</span>,</span><br><span class="line">		__func__, dev_name(&amp;input-&gt;dev));</span><br><span class="line">	__input_unregister_device(input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_enable_softrepeat - enable software autorepeat</span></span><br><span class="line"><span class="comment"> * @dev: input device</span></span><br><span class="line"><span class="comment"> * @delay: repeat delay</span></span><br><span class="line"><span class="comment"> * @period: repeat period</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Enable software autorepeat on the input device.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_enable_softrepeat</span><span class="params">(struct input_dev *dev, <span class="keyword">int</span> <span class="built_in">delay</span>, <span class="keyword">int</span> period)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dev-&gt;timer.data = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) dev;</span><br><span class="line">	dev-&gt;timer.function = input_repeat_key;</span><br><span class="line">	dev-&gt;rep[REP_DELAY] = <span class="built_in">delay</span>;</span><br><span class="line">	dev-&gt;rep[REP_PERIOD] = period;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_enable_softrepeat);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_register_device - register device with input core</span></span><br><span class="line"><span class="comment"> * @dev: device to be registered</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function registers device with input core. The device must be</span></span><br><span class="line"><span class="comment"> * allocated with input_allocate_device() and all it's capabilities</span></span><br><span class="line"><span class="comment"> * set up before registering.</span></span><br><span class="line"><span class="comment"> * If function fails the device must be freed with input_free_device().</span></span><br><span class="line"><span class="comment"> * Once device has been successfully registered it can be unregistered</span></span><br><span class="line"><span class="comment"> * with input_unregister_device(); input_free_device() should not be</span></span><br><span class="line"><span class="comment"> * called in this case.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that this function is also used to register managed input devices</span></span><br><span class="line"><span class="comment"> * (ones allocated with devm_input_allocate_device()). Such managed input</span></span><br><span class="line"><span class="comment"> * devices need not be explicitly unregistered or freed, their tear down</span></span><br><span class="line"><span class="comment"> * is controlled by the devres infrastructure. It is also worth noting</span></span><br><span class="line"><span class="comment"> * that tear down of managed input devices is internally a 2-step process:</span></span><br><span class="line"><span class="comment"> * registered managed input device is first unregistered, but stays in</span></span><br><span class="line"><span class="comment"> * memory and can still handle input_event() calls (although events will</span></span><br><span class="line"><span class="comment"> * not be delivered anywhere). The freeing of managed input device will</span></span><br><span class="line"><span class="comment"> * happen later, when devres stack is unwound to the point where device</span></span><br><span class="line"><span class="comment"> * allocation was made.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_register_device</span><span class="params">(struct input_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_devres</span> *<span class="title">devres</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> packet_size;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *path;</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (test_bit(EV_ABS, dev-&gt;evbit) &amp;&amp; !dev-&gt;absinfo) &#123;</span><br><span class="line">		dev_err(&amp;dev-&gt;dev,</span><br><span class="line">			<span class="string">"Absolute device without dev-&gt;absinfo, refusing to register\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;devres_managed) &#123;</span><br><span class="line">		devres = devres_alloc(devm_input_device_unregister,</span><br><span class="line">				      <span class="keyword">sizeof</span>(*devres), GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!devres)</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">		devres-&gt;input = dev;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Every input device generates EV_SYN/SYN_REPORT events. */</span></span><br><span class="line">	__set_bit(EV_SYN, dev-&gt;evbit);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* KEY_RESERVED is not supposed to be transmitted to userspace. */</span></span><br><span class="line">	__clear_bit(KEY_RESERVED, dev-&gt;keybit);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make sure that bitmasks not mentioned in dev-&gt;evbit are clean. */</span></span><br><span class="line">	input_cleanse_bitmasks(dev);</span><br><span class="line"></span><br><span class="line">	packet_size = input_estimate_events_per_packet(dev);</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;hint_events_per_packet &lt; packet_size)</span><br><span class="line">		dev-&gt;hint_events_per_packet = packet_size;</span><br><span class="line"></span><br><span class="line">	dev-&gt;max_vals = dev-&gt;hint_events_per_packet + <span class="number">2</span>;</span><br><span class="line">	dev-&gt;vals = kcalloc(dev-&gt;max_vals, <span class="keyword">sizeof</span>(*dev-&gt;vals), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;vals) &#123;</span><br><span class="line">		error = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> err_devres_free;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If delay and period are pre-set by the driver, then autorepeating</span></span><br><span class="line"><span class="comment">	 * is handled by the driver itself and we don't do it in input.c.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;rep[REP_DELAY] &amp;&amp; !dev-&gt;rep[REP_PERIOD])</span><br><span class="line">		input_enable_softrepeat(dev, <span class="number">250</span>, <span class="number">33</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;getkeycode)</span><br><span class="line">		dev-&gt;getkeycode = input_default_getkeycode;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;setkeycode)</span><br><span class="line">		dev-&gt;setkeycode = input_default_setkeycode;</span><br><span class="line"></span><br><span class="line">	error = device_add(&amp;dev-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> err_free_vals;</span><br><span class="line"></span><br><span class="line">	path = kobject_get_path(&amp;dev-&gt;dev.kobj, GFP_KERNEL);</span><br><span class="line">	pr_info(<span class="string">"%s as %s\n"</span>,</span><br><span class="line">		dev-&gt;name ? dev-&gt;name : <span class="string">"Unspecified device"</span>,</span><br><span class="line">		path ? path : <span class="string">"N/A"</span>);</span><br><span class="line">	kfree(path);</span><br><span class="line"></span><br><span class="line">	error = mutex_lock_interruptible(&amp;input_mutex);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> err_device_del;</span><br><span class="line"></span><br><span class="line">	list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在此处建立联系</span></span><br><span class="line">	list_for_each_entry(handler, &amp;input_handler_list, node)</span><br><span class="line">		input_attach_handler(dev, handler);</span><br><span class="line"></span><br><span class="line">	input_wakeup_procfs_readers();</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;input_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;devres_managed) &#123;</span><br><span class="line">		dev_dbg(dev-&gt;dev.parent, <span class="string">"%s: registering %s with devres.\n"</span>,</span><br><span class="line">			__func__, dev_name(&amp;dev-&gt;dev));</span><br><span class="line">		devres_add(dev-&gt;dev.parent, devres);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_device_del:</span><br><span class="line">	device_del(&amp;dev-&gt;dev);</span><br><span class="line">err_free_vals:</span><br><span class="line">	kfree(dev-&gt;vals);</span><br><span class="line">	dev-&gt;vals = <span class="literal">NULL</span>;</span><br><span class="line">err_devres_free:</span><br><span class="line">	devres_free(devres);</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_register_device);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_unregister_device - unregister previously registered device</span></span><br><span class="line"><span class="comment"> * @dev: device to be unregistered</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function unregisters an input device. Once device is unregistered</span></span><br><span class="line"><span class="comment"> * the caller should not try to access it as it may get freed at any moment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_unregister_device</span><span class="params">(struct input_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;devres_managed) &#123;</span><br><span class="line">		WARN_ON(devres_destroy(dev-&gt;dev.parent,</span><br><span class="line">					devm_input_device_unregister,</span><br><span class="line">					devm_input_device_match,</span><br><span class="line">					dev));</span><br><span class="line">		__input_unregister_device(dev);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We do not do input_put_device() here because it will be done</span></span><br><span class="line"><span class="comment">		 * when 2nd devres fires up.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		__input_unregister_device(dev);</span><br><span class="line">		input_put_device(dev);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_unregister_device);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_register_handler - register a new input handler</span></span><br><span class="line"><span class="comment"> * @handler: handler to be registered</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function registers a new input handler (interface) for input</span></span><br><span class="line"><span class="comment"> * devices in the system and attaches it to all input devices that</span></span><br><span class="line"><span class="comment"> * are compatible with the handler.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//在</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_register_handler</span><span class="params">(struct input_handler *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">	error = mutex_lock_interruptible(&amp;input_mutex);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;handler-&gt;h_list);</span><br><span class="line"></span><br><span class="line">	list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list);</span><br><span class="line"></span><br><span class="line">	list_for_each_entry(dev, &amp;input_dev_list, node)</span><br><span class="line">		input_attach_handler(dev, handler);</span><br><span class="line"></span><br><span class="line">	input_wakeup_procfs_readers();</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;input_mutex);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_register_handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_unregister_handler - unregisters an input handler</span></span><br><span class="line"><span class="comment"> * @handler: handler to be unregistered</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function disconnects a handler from its input devices and</span></span><br><span class="line"><span class="comment"> * removes it from lists of known handlers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_unregister_handler</span><span class="params">(struct input_handler *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> *<span class="title">handle</span>, *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;input_mutex);</span><br><span class="line"></span><br><span class="line">	list_for_each_entry_safe(handle, next, &amp;handler-&gt;h_list, h_node)</span><br><span class="line">		handler-&gt;<span class="built_in">disconnect</span>(handle);</span><br><span class="line">	WARN_ON(!list_empty(&amp;handler-&gt;h_list));</span><br><span class="line"></span><br><span class="line">	list_del_init(&amp;handler-&gt;node);</span><br><span class="line"></span><br><span class="line">	input_wakeup_procfs_readers();</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;input_mutex);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_unregister_handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_handler_for_each_handle - handle iterator</span></span><br><span class="line"><span class="comment"> * @handler: input handler to iterate</span></span><br><span class="line"><span class="comment"> * @data: data for the callback</span></span><br><span class="line"><span class="comment"> * @fn: function to be called for each handle</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Iterate over @bus's list of devices, and call @fn for each, passing</span></span><br><span class="line"><span class="comment"> * it @data and stop when @fn returns a non-zero value. The function is</span></span><br><span class="line"><span class="comment"> * using RCU to traverse the list and therefore may be using in atomic</span></span><br><span class="line"><span class="comment"> * contexts. The @fn callback is invoked from RCU critical section and</span></span><br><span class="line"><span class="comment"> * thus must not sleep.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_handler_for_each_handle</span><span class="params">(struct input_handler *handler, <span class="keyword">void</span> *data,</span></span></span><br><span class="line"><span class="function"><span class="params">				  <span class="keyword">int</span> (*fn)(struct input_handle *, <span class="keyword">void</span> *))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> *<span class="title">handle</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line"></span><br><span class="line">	list_for_each_entry_rcu(handle, &amp;handler-&gt;h_list, h_node) &#123;</span><br><span class="line">		retval = fn(handle, data);</span><br><span class="line">		<span class="keyword">if</span> (retval)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_handler_for_each_handle);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_register_handle - register a new input handle</span></span><br><span class="line"><span class="comment"> * @handle: handle to register</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function puts a new input handle onto device's</span></span><br><span class="line"><span class="comment"> * and handler's lists so that events can flow through</span></span><br><span class="line"><span class="comment"> * it once it is opened using input_open_device().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is supposed to be called from handler's</span></span><br><span class="line"><span class="comment"> * connect() method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_register_handle</span><span class="params">(struct input_handle *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span> = <span class="title">handle</span>-&gt;<span class="title">handler</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span> = <span class="title">handle</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We take dev-&gt;mutex here to prevent race with</span></span><br><span class="line"><span class="comment">	 * input_release_device().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	error = mutex_lock_interruptible(&amp;dev-&gt;mutex);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Filters go to the head of the list, normal handlers</span></span><br><span class="line"><span class="comment">	 * to the tail.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (handler-&gt;filter)</span><br><span class="line">		list_add_rcu(&amp;handle-&gt;d_node, &amp;dev-&gt;h_list);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		list_add_tail_rcu(&amp;handle-&gt;d_node, &amp;dev-&gt;h_list);</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Since we are supposed to be called from -&gt;connect()</span></span><br><span class="line"><span class="comment">	 * which is mutually exclusive with -&gt;disconnect()</span></span><br><span class="line"><span class="comment">	 * we can't be racing with input_unregister_handle()</span></span><br><span class="line"><span class="comment">	 * and so separate lock is not needed here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	list_add_tail_rcu(&amp;handle-&gt;h_node, &amp;handler-&gt;h_list);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (handler-&gt;start)</span><br><span class="line">		handler-&gt;start(handle);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_register_handle);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_unregister_handle - unregister an input handle</span></span><br><span class="line"><span class="comment"> * @handle: handle to unregister</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function removes input handle from device's</span></span><br><span class="line"><span class="comment"> * and handler's lists.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is supposed to be called from handler's</span></span><br><span class="line"><span class="comment"> * disconnect() method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_unregister_handle</span><span class="params">(struct input_handle *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span> = <span class="title">handle</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	list_del_rcu(&amp;handle-&gt;h_node);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Take dev-&gt;mutex to prevent race with input_release_device().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mutex_lock(&amp;dev-&gt;mutex);</span><br><span class="line">	list_del_rcu(&amp;handle-&gt;d_node);</span><br><span class="line">	mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line"></span><br><span class="line">	synchronize_rcu();</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_unregister_handle);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_get_new_minor - allocates a new input minor number</span></span><br><span class="line"><span class="comment"> * @legacy_base: beginning or the legacy range to be searched</span></span><br><span class="line"><span class="comment"> * @legacy_num: size of legacy range</span></span><br><span class="line"><span class="comment"> * @allow_dynamic: whether we can also take ID from the dynamic range</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function allocates a new device minor for from input major namespace.</span></span><br><span class="line"><span class="comment"> * Caller can request legacy minor by specifying @legacy_base and @legacy_num</span></span><br><span class="line"><span class="comment"> * parameters and whether ID can be allocated from dynamic range if there are</span></span><br><span class="line"><span class="comment"> * no free IDs in legacy range.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_get_new_minor</span><span class="params">(<span class="keyword">int</span> legacy_base, <span class="keyword">unsigned</span> <span class="keyword">int</span> legacy_num,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">bool</span> allow_dynamic)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This function should be called from input handler's -&gt;connect()</span></span><br><span class="line"><span class="comment">	 * methods, which are serialized with input_mutex, so no additional</span></span><br><span class="line"><span class="comment">	 * locking is needed here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (legacy_base &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> minor = ida_simple_get(&amp;input_ida,</span><br><span class="line">					   legacy_base,</span><br><span class="line">					   legacy_base + legacy_num,</span><br><span class="line">					   GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (minor &gt;= <span class="number">0</span> || !allow_dynamic)</span><br><span class="line">			<span class="keyword">return</span> minor;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ida_simple_get(&amp;input_ida,</span><br><span class="line">			      INPUT_FIRST_DYNAMIC_DEV, INPUT_MAX_CHAR_DEVICES,</span><br><span class="line">			      GFP_KERNEL);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_get_new_minor);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_free_minor - release previously allocated minor</span></span><br><span class="line"><span class="comment"> * @minor: minor to be released</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function releases previously allocated input minor so that it can be</span></span><br><span class="line"><span class="comment"> * reused later.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_free_minor</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> minor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ida_simple_remove(&amp;input_ida, minor);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_free_minor);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册类以及input设备节点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">input_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	err = class_register(&amp;input_class);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		pr_err(<span class="string">"unable to register input_dev class\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = input_proc_init();</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> fail1;</span><br><span class="line"></span><br><span class="line">	err = register_chrdev_region(MKDEV(INPUT_MAJOR, <span class="number">0</span>),</span><br><span class="line">				     INPUT_MAX_CHAR_DEVICES, <span class="string">"input"</span>);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		pr_err(<span class="string">"unable to register char major %d"</span>, INPUT_MAJOR);</span><br><span class="line">		<span class="keyword">goto</span> fail2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> fail2:	input_proc_exit();</span><br><span class="line"> fail1:	class_unregister(&amp;input_class);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">input_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	input_proc_exit();</span><br><span class="line">	unregister_chrdev_region(MKDEV(INPUT_MAJOR, <span class="number">0</span>),</span><br><span class="line">				 INPUT_MAX_CHAR_DEVICES);</span><br><span class="line">	class_unregister(&amp;input_class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subsys_initcall(input_init);</span><br><span class="line">module_exit(input_exit);</span><br></pre></td></tr></table></figure>


<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>ARM&amp;Linux</category>
        <category>Linux驱动</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>输入子系统</tag>
        <tag>InputCore</tag>
      </tags>
  </entry>
  <entry>
    <title>USB系列-0-基础概念</title>
    <url>/2017/08/06/ARM&amp;Linux/Linux%E9%A9%B1%E5%8A%A8/USB/USB%E7%B3%BB%E5%88%97-0-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">_______  ______</span><br><span class="line">|<span class="string">\     /</span>|<span class="string">(  ____ \(  ___ \</span></span><br><span class="line">|<span class="string"> )   ( </span>||<span class="string"> (    \/</span>|<span class="string"> (   ) )</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>||<span class="string"> (_____ </span>|<span class="string"> (__/ /</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string">(_____  )</span>|<span class="string">  __ (</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string">      ) </span>||<span class="string"> (  \ \</span></span><br><span class="line">|<span class="string"> (___) </span>|<span class="string">/\____) </span>||<span class="string"> )___) )</span></span><br><span class="line"><span class="string">(_______)\_______)</span>|<span class="string">/ \___/</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="1-USB特性"><a href="#1-USB特性" class="headerlink" title="1.USB特性"></a>1.USB特性</h1><ul>
<li>不同设备类型，统一接口</li>
<li>支持热插拔</li>
<li>灵活的供电方式</li>
<li>多级速率支持</li>
</ul>
<h1 id="2-分类"><a href="#2-分类" class="headerlink" title="2.分类"></a>2.分类</h1><ul>
<li>OHCI主要为非PC系统上以及带有SiShe ALi芯片组的PC主板上的USB芯片</li>
<li>UHCI大多为Intel和Via主板上的USB控制器芯片。UHCI的硬件电路比OHCI简单，成本第，但驱动复杂。但他们都是由USB1.1规格的。</li>
<li>EHCI是有Intel等几个厂商研发，兼容OHCI UHCI 遵循USB2.0规范</li>
</ul>
<h1 id="3-层次"><a href="#3-层次" class="headerlink" title="3.层次"></a>3.层次</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设备  ：设备即我们所理解的设备，如一个键盘是一个设备，一个U盘是一个设备</span><br><span class="line">配置  ：配置是功能的集合，如一个USB耳麦能录音和播放，那么就可以存在三种配置</span><br><span class="line">接口  ：如上，就分为录音接口，播放接口</span><br><span class="line">端点  ：比如播放接口会存在两个端点，一个是左声道，一个是右声道</span><br></pre></td></tr></table></figure>
<ul>
<li>端点是通信的基本单位，并且方向是确定的</li>
<li>管道代表着端点与端点之间通信的能力<h1 id="4-传输单位"><a href="#4-传输单位" class="headerlink" title="4.传输单位"></a>4.传输单位</h1></li>
<li>事务：事务一般由令牌包、数据包（可选）、握手包组成。<ul>
<li>令牌包：用来启动一个事务，总是由主机发送。</li>
<li>数据包：可以从主机到设备，也可以由设备到主机，方向由令牌包决定。</li>
<li>握手包：通常情况，数据的接收者发送握手包（ACK或者NAK）。</li>
</ul>
</li>
</ul>
<p>事务一般由令牌包、数据包（可选）、握手包组成。</p>
<ul>
<li>USB协议规定了四种传输类型：控制传输、批量传输、同步传输、中断传输<ul>
<li>控制传输：控制传输事负责向USB设置一些控制信息，传送这种事务的管道是控制管道。控制管道在USB设备中是必须的。控制传送也分为三个阶段，即令牌阶段、数据传送阶段、握手阶段。</li>
<li>中断传输：中断事物的数据量很小，一般用于通知Host某个事件的来临，例如USB鼠标，鼠标移动或者鼠标单击等操作都会通过中断管道来向Host传送事件。也分3个阶段，令牌阶段、数据传输阶段、握手阶段。</li>
<li>同步传输：这是种能保证传输的同步性的事务。如在USB摄像头中传输视频数据的时候会采用这种事务，这种事务能保证每秒有固定的传输量，与Bulk传输不同的是他允许有一定的误码率。同步传输事务只有两个阶段，令牌阶段、数据阶段，因为不关心数据的正确性，所以没有握手阶段。</li>
<li>批量传输：用来传输大量数据，确保没有数据丢失，但不保证在特定时间内完场，U盘使用的就是批量传输。<h1 id="5-命名"><a href="#5-命名" class="headerlink" title="5.命名"></a>5.命名</h1></li>
</ul>
</li>
<li>sysfs USB命名</li>
</ul>
<p>2-1:1.0 设备-端口：配置.接口</p>
<p>第二个设备的第一个端口，使用配置0 的接口1</p>
<h1 id="6-驱动架构"><a href="#6-驱动架构" class="headerlink" title="6.驱动架构"></a>6.驱动架构</h1><p>USB Core</p>
<p>USB Core提供一些核心算法，为别的设备驱动程序提供服务，提供一个用于访问和控制USB硬件的接口，而不用考虑系统当前是那种主机控制器，</p>
<p>USB Core、USB主机控制器 USB设备驱动三者的关系如下：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">Block层 ： Net层 ： Char层 ： ---</span><br><span class="line">-------------------------------</span><br><span class="line"><span class="code">  USB设备驱动程序</span></span><br><span class="line">-------------------------------</span><br><span class="line"><span class="code">  USB Core</span></span><br><span class="line">-------------------------------</span><br><span class="line"><span class="code">  USB主机控制器(HCD)</span></span><br><span class="line">-------------------------------</span><br><span class="line"><span class="code">  硬件</span></span><br></pre></td></tr></table></figure>
<p>HCD提供主机控制器硬件的抽象，隐藏硬件的细节，HCD只对 USB Core负责。这也就意味着我们写USB驱动，是在调用USB Core接口的基础上进行的。</p>
<p>我们接下来的源码分析就从HCD开始。</p>
<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>ARM&amp;Linux</category>
        <category>Linux驱动</category>
        <category>USB</category>
      </categories>
      <tags>
        <tag>USB</tag>
        <tag>基础概念</tag>
      </tags>
  </entry>
  <entry>
    <title>USB系列-1-基本结构体</title>
    <url>/2017/08/09/ARM&amp;Linux/Linux%E9%A9%B1%E5%8A%A8/USB/USB%E7%B3%BB%E5%88%97-1-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<p>介绍USB设备结构体和设备描述符结构体。</p>
<a id="more"></a>

<h1 id="1-USB设备结构体"><a href="#1-USB设备结构体" class="headerlink" title="1. USB设备结构体"></a>1. USB设备结构体</h1><p>usb_device位于<code>/linux/include/usb.h</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct usb_device - kernel's representation of a USB device</span></span><br><span class="line"><span class="comment"> * @devnum: device number; address on a USB bus</span></span><br><span class="line"><span class="comment"> * @devpath: device ID string for use in messages (e.g., /port/...)</span></span><br><span class="line"><span class="comment"> * @route: tree topology hex string for use with xHCI</span></span><br><span class="line"><span class="comment"> * @state: device state: configured, not attached, etc.</span></span><br><span class="line"><span class="comment"> * @speed: device speed: high/full/low (or error)</span></span><br><span class="line"><span class="comment"> * @tt: Transaction Translator info; used with low/full speed dev, highspeed hub</span></span><br><span class="line"><span class="comment"> * @ttport: device port on that tt hub</span></span><br><span class="line"><span class="comment"> * @toggle: one bit for each endpoint, with ([0] = IN, [1] = OUT) endpoints</span></span><br><span class="line"><span class="comment"> * @parent: our hub, unless we're the root</span></span><br><span class="line"><span class="comment"> * @bus: bus we're part of</span></span><br><span class="line"><span class="comment"> * @ep0: endpoint 0 data (default control pipe)</span></span><br><span class="line"><span class="comment"> * @dev: generic device interface</span></span><br><span class="line"><span class="comment"> * @descriptor: USB device descriptor</span></span><br><span class="line"><span class="comment"> * @bos: USB device BOS descriptor set</span></span><br><span class="line"><span class="comment"> * @config: all of the device's configs</span></span><br><span class="line"><span class="comment"> * @actconfig: the active configuration</span></span><br><span class="line"><span class="comment"> * @ep_in: array of IN endpoints</span></span><br><span class="line"><span class="comment"> * @ep_out: array of OUT endpoints</span></span><br><span class="line"><span class="comment"> * @rawdescriptors: raw descriptors for each config</span></span><br><span class="line"><span class="comment"> * @bus_mA: Current available from the bus</span></span><br><span class="line"><span class="comment"> * @portnum: parent port number (origin 1)</span></span><br><span class="line"><span class="comment"> * @level: number of USB hub ancestors</span></span><br><span class="line"><span class="comment"> * @can_submit: URBs may be submitted</span></span><br><span class="line"><span class="comment"> * @persist_enabled:  USB_PERSIST enabled for this device</span></span><br><span class="line"><span class="comment"> * @have_langid: whether string_langid is valid</span></span><br><span class="line"><span class="comment"> * @authorized: policy has said we can use it;</span></span><br><span class="line"><span class="comment"> *	(user space) policy determines if we authorize this device to be</span></span><br><span class="line"><span class="comment"> *	used or not. By default, wired USB devices are authorized.</span></span><br><span class="line"><span class="comment"> *	WUSB devices are not, until we authorize them from user space.</span></span><br><span class="line"><span class="comment"> *	FIXME -- complete doc</span></span><br><span class="line"><span class="comment"> * @authenticated: Crypto authentication passed</span></span><br><span class="line"><span class="comment"> * @wusb: device is Wireless USB</span></span><br><span class="line"><span class="comment"> * @lpm_capable: device supports LPM</span></span><br><span class="line"><span class="comment"> * @usb2_hw_lpm_capable: device can perform USB2 hardware LPM</span></span><br><span class="line"><span class="comment"> * @usb2_hw_lpm_besl_capable: device can perform USB2 hardware BESL LPM</span></span><br><span class="line"><span class="comment"> * @usb2_hw_lpm_enabled: USB2 hardware LPM is enabled</span></span><br><span class="line"><span class="comment"> * @usb2_hw_lpm_allowed: Userspace allows USB 2.0 LPM to be enabled</span></span><br><span class="line"><span class="comment"> * @usb3_lpm_u1_enabled: USB3 hardware U1 LPM enabled</span></span><br><span class="line"><span class="comment"> * @usb3_lpm_u2_enabled: USB3 hardware U2 LPM enabled</span></span><br><span class="line"><span class="comment"> * @string_langid: language ID for strings</span></span><br><span class="line"><span class="comment"> * @product: iProduct string, if present (static)</span></span><br><span class="line"><span class="comment"> * @manufacturer: iManufacturer string, if present (static)</span></span><br><span class="line"><span class="comment"> * @serial: iSerialNumber string, if present (static)</span></span><br><span class="line"><span class="comment"> * @filelist: usbfs files that are open to this device</span></span><br><span class="line"><span class="comment"> * @maxchild: number of ports if hub</span></span><br><span class="line"><span class="comment"> * @quirks: quirks of the whole device</span></span><br><span class="line"><span class="comment"> * @urbnum: number of URBs submitted for the whole device</span></span><br><span class="line"><span class="comment"> * @active_duration: total time device is not suspended</span></span><br><span class="line"><span class="comment"> * @connect_time: time device was first connected</span></span><br><span class="line"><span class="comment"> * @do_remote_wakeup:  remote wakeup should be enabled</span></span><br><span class="line"><span class="comment"> * @reset_resume: needs reset instead of resume</span></span><br><span class="line"><span class="comment"> * @port_is_suspended: the upstream port is suspended (L2 or U3)</span></span><br><span class="line"><span class="comment"> * @wusb_dev: if this is a Wireless USB device, link to the WUSB</span></span><br><span class="line"><span class="comment"> *	specific data for the device.</span></span><br><span class="line"><span class="comment"> * @slot_id: Slot ID assigned by xHCI</span></span><br><span class="line"><span class="comment"> * @removable: Device can be physically removed from this port</span></span><br><span class="line"><span class="comment"> * @l1_params: best effor service latency for USB2 L1 LPM state, and L1 timeout.</span></span><br><span class="line"><span class="comment"> * @u1_params: exit latencies for USB3 U1 LPM state, and hub-initiated timeout.</span></span><br><span class="line"><span class="comment"> * @u2_params: exit latencies for USB3 U2 LPM state, and hub-initiated timeout.</span></span><br><span class="line"><span class="comment"> * @lpm_disable_count: Ref count used by usb_disable_lpm() and usb_enable_lpm()</span></span><br><span class="line"><span class="comment"> *	to keep track of the number of functions that require USB 3.0 Link Power</span></span><br><span class="line"><span class="comment"> *	Management to be disabled for this usb_device.  This count should only</span></span><br><span class="line"><span class="comment"> *	be manipulated by those functions, with the bandwidth_mutex is held.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Notes:</span></span><br><span class="line"><span class="comment"> * Usbcore drivers should not set usbdev-&gt;state directly.  Instead use</span></span><br><span class="line"><span class="comment"> * usb_set_device_state().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_device</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span>		devnum;			<span class="comment">//设备号，还记得上一篇USB命名"设备号-端口号：配置.接口"命名方式，每插入一个新设备，USBCore会为其设置一个设备号</span></span><br><span class="line">	<span class="keyword">char</span>	devpath[<span class="number">16</span>]; <span class="comment">//该设备在SysFS中的路径，一般为"/sys/devices/pci0000:00/0000:00:12.2/_usb_1"</span></span><br><span class="line">	u32		route;</span><br><span class="line">	<span class="keyword">enum</span> usb_device_state	state;	<span class="comment">//该设备的状态，如刚插上时为Attached</span></span><br><span class="line">	<span class="keyword">enum</span> usb_device_speed	speed;	<span class="comment">//速度级别 high full low</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_tt</span>	*<span class="title">tt</span>;</span>			<span class="comment">//我们知道高速USB之前还存在全速和低速USB,那么高速USB设备怎么兼容其他</span></span><br><span class="line">	<span class="keyword">int</span>		ttport;					<span class="comment">//低速设备，通过使用TT(Transaction Translator)--高速USB中的转换电路</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> toggle[<span class="number">2</span>];			<span class="comment">//对于中断传输、批量传输、和控制传输，传输数据时，需要DATA0和DATA1交</span></span><br><span class="line">									<span class="comment">//替进行，toggle就是标识0端点的IN 和 OUT的DATAx的状态</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_device</span> *<span class="title">parent</span>;</span>		<span class="comment">//父hub,如果是roothub，就是NULL</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_bus</span> *<span class="title">bus</span>;</span>			<span class="comment">//设备所在的总线</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_host_endpoint</span> <span class="title">ep0</span>;</span>	<span class="comment">//端点0被特殊对待，在结构体中静态存在</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>				<span class="comment">//嵌入到usb_device中的device</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_device_descriptor</span> <span class="title">descriptor</span>;</span>	<span class="comment">//设备描述符，描述该设备信息，后面会分析</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_host_bos</span> *<span class="title">bos</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_host_config</span> *<span class="title">config</span>;</span>				<span class="comment">//所有的配置信息列表</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_host_config</span> *<span class="title">actconfig</span>;</span>			<span class="comment">//当前活跃的信息</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_host_endpoint</span> *<span class="title">ep_in</span>[16];</span>		<span class="comment">//该设备的输入端点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_host_endpoint</span> *<span class="title">ep_out</span>[16];</span>		<span class="comment">//输出端点</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> **rawdescriptors;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> short bus_mA;						<span class="comment">//能够从总线得到的电流值</span></span><br><span class="line">	u8 portnum;</span><br><span class="line">	u8 level;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> can_submit:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> persist_enabled:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> have_langid:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> authorized:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> authenticated:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> wusb:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> lpm_capable:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> usb2_hw_lpm_capable:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> usb2_hw_lpm_besl_capable:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> usb2_hw_lpm_enabled:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> usb2_hw_lpm_allowed:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> usb3_lpm_u1_enabled:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> usb3_lpm_u2_enabled:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> string_langid;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* static strings from the device */</span></span><br><span class="line">	<span class="keyword">char</span> *product;</span><br><span class="line">	<span class="keyword">char</span> *manufacturer;</span><br><span class="line">	<span class="keyword">char</span> *serial;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">filelist</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> maxchild;</span><br><span class="line"></span><br><span class="line">	u32 quirks;</span><br><span class="line">	<span class="keyword">atomic_t</span> urbnum;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> active_duration;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PM</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> connect_time;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> do_remote_wakeup:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> reset_resume:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> port_is_suspended:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wusb_dev</span> *<span class="title">wusb_dev</span>;</span></span><br><span class="line">	<span class="keyword">int</span> slot_id;</span><br><span class="line">	<span class="keyword">enum</span> usb_device_removable removable;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb2_lpm_parameters</span> <span class="title">l1_params</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb3_lpm_parameters</span> <span class="title">u1_params</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb3_lpm_parameters</span> <span class="title">u2_params</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> lpm_disable_count;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	to_usb_device(d) container_of(d, struct usb_device, dev)</span></span><br></pre></td></tr></table></figure>

<h1 id="2-USB设备描述符结构体"><a href="#2-USB设备描述符结构体" class="headerlink" title="2 USB设备描述符结构体"></a>2 USB设备描述符结构体</h1><p>usb_device_descriptor位于``</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USB_DT_DEVICE: Device descriptor */</span></span><br><span class="line">struct usb_device_descriptor &#123;</span><br><span class="line">	<span class="variable">__u8</span>  bLength;			<span class="comment">//该设备描述符的长度</span></span><br><span class="line">	<span class="variable">__u8</span>  bDescriptorType;	<span class="comment">// USB_DT_DEVICE = 0x01</span></span><br><span class="line"></span><br><span class="line">	<span class="variable">__le16</span> bcdUSB;			<span class="comment">//版本号</span></span><br><span class="line">	<span class="variable">__u8</span>  bDeviceClass;		<span class="comment">//</span></span><br><span class="line">	<span class="variable">__u8</span>  bDeviceSubClass;</span><br><span class="line">	<span class="variable">__u8</span>  bDeviceProtocol;</span><br><span class="line">	<span class="variable">__u8</span>  bMaxPacketSize0;	<span class="comment">//端点0一次可以处理的最大字节数</span></span><br><span class="line">	<span class="variable">__le16</span> idVendor;		<span class="comment">//厂商号</span></span><br><span class="line">	<span class="variable">__le16</span> idProduct;		<span class="comment">//产品号</span></span><br><span class="line">	<span class="variable">__le16</span> bcdDevice;		<span class="comment">//版本号</span></span><br><span class="line">	<span class="variable">__u8</span>  iManufacturer;	<span class="comment">//分别对应上面的索引值 index</span></span><br><span class="line">	<span class="variable">__u8</span>  iProduct;</span><br><span class="line">	<span class="variable">__u8</span>  iSerialNumber;</span><br><span class="line">	<span class="variable">__u8</span>  bNumConfigurations;	<span class="comment">//设备在当前速度级别下支持的配置数量</span></span><br><span class="line">&#125; <span class="variable">__attribute__</span> ((packed));</span><br></pre></td></tr></table></figure>


<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>ARM&amp;Linux</category>
        <category>Linux驱动</category>
        <category>USB</category>
      </categories>
      <tags>
        <tag>USB</tag>
        <tag>基本结构体</tag>
      </tags>
  </entry>
  <entry>
    <title>USB系列-2-DNW源码</title>
    <url>/2017/08/17/ARM&amp;Linux/Linux%E9%A9%B1%E5%8A%A8/USB/USB%E7%B3%BB%E5%88%97-2-DNW%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<p>对DNW驱动源码进行简要分析。</p>
<a id="more"></a>

<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/usb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECBULK_MAJOR	102</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECBULK_MINOR	0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRIVER_NAME	<span class="meta-string">"secbulk"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BULKOUT_BUFFER_SIZE	512</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">secbulk_dev</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_device</span> *<span class="title">udev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">io_mutex</span>;</span></span><br><span class="line">	<span class="keyword">char</span>*	bulkout_buffer;</span><br><span class="line">	__u8	bulk_out_endpointAddr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_class_driver</span> <span class="title">secbulk_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_device_id</span> <span class="title">secbulk_table</span>[]= &#123;</span></span><br><span class="line">	&#123; USB_DEVICE(<span class="number">0x04e8</span>, <span class="number">0x1234</span>)&#125;,		<span class="comment">//c</span></span><br><span class="line">	&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_driver</span> <span class="title">secbulk_driver</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">secbulk_disconnect</span><span class="params">(struct usb_interface *interface)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">secbulk_dev</span> *<span class="title">dev</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	printk(KERN_INFO <span class="string">"secbulk:secbulk disconnected!\n"</span>);</span><br><span class="line">	dev = usb_get_intfdata(interface);</span><br><span class="line">	<span class="keyword">if</span>( <span class="literal">NULL</span> != dev )</span><br><span class="line">		kfree(dev);</span><br><span class="line">	usb_deregister_dev(interface, &amp;secbulk_class);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">secbulk_read</span><span class="params">(struct file *file, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> len, <span class="keyword">loff_t</span> *loff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> -EPERM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">secbulk_write</span><span class="params">(struct file *file, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> len, <span class="keyword">loff_t</span> *loff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span> to_write;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">secbulk_dev</span> *<span class="title">dev</span> = <span class="title">file</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="keyword">int</span> actual_length;</span><br><span class="line">	<span class="keyword">size_t</span> total_writed;</span><br><span class="line"></span><br><span class="line">	total_writed = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		to_write = <span class="built_in">min</span>(len, BULKOUT_BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(copy_from_user(dev-&gt;bulkout_buffer, buf+total_writed, to_write))	<span class="comment">//得到用户空间数据</span></span><br><span class="line">		&#123;</span><br><span class="line">			printk(KERN_ERR <span class="string">"secbulk:copy_from_user failed!\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ret = usb_bulk_msg(dev-&gt;udev, usb_sndbulkpipe(dev-&gt;udev, dev-&gt;bulk_out_endpointAddr),	<span class="comment">//构造批量传输信息，传输给usbCore处理</span></span><br><span class="line">				dev-&gt;bulkout_buffer,</span><br><span class="line">				to_write,</span><br><span class="line">				&amp;actual_length,</span><br><span class="line">				<span class="number">3</span>*HZ);</span><br><span class="line">		<span class="keyword">if</span>(ret || actual_length!=to_write)</span><br><span class="line">		&#123;</span><br><span class="line">			printk(KERN_ERR <span class="string">"secbulk:usb_bulk_msg failed!\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		&#125;</span><br><span class="line">		len -= to_write;</span><br><span class="line">		total_writed += to_write;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> total_writed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">secbulk_open</span><span class="params">(struct inode *node, struct file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_interface</span> *<span class="title">interface</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">secbulk_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	interface = usb_find_interface(&amp;secbulk_driver, iminor(node));</span><br><span class="line">	<span class="keyword">if</span>(!interface)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">	dev = usb_get_intfdata(interface);</span><br><span class="line">	dev-&gt;bulkout_buffer = kzalloc(BULKOUT_BUFFER_SIZE, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span>(!(dev-&gt;bulkout_buffer))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	<span class="keyword">if</span>(!mutex_trylock(&amp;dev-&gt;io_mutex))</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line">	file-&gt;private_data = dev;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">secbulk_release</span><span class="params">(struct inode *node, struct file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">secbulk_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	dev = (struct secbulk_dev*)(file-&gt;private_data);</span><br><span class="line">	kfree(dev-&gt;bulkout_buffer);</span><br><span class="line">	mutex_unlock(&amp;dev-&gt;io_mutex);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">secbulk_fops</span> = &#123;</span></span><br><span class="line">	.owner 	=	THIS_MODULE,</span><br><span class="line">	.<span class="built_in">read</span> 	=	secbulk_read,</span><br><span class="line">	.<span class="built_in">write</span>	=	secbulk_write,</span><br><span class="line">	.<span class="built_in">open</span>   =	secbulk_open,</span><br><span class="line">	.<span class="built_in">release</span>=	secbulk_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_class_driver</span> <span class="title">secbulk_class</span> = &#123;</span></span><br><span class="line">	.name = 	<span class="string">"secbulk%d"</span>,</span><br><span class="line">	.fops =		&amp;secbulk_fops,</span><br><span class="line">	.minor_base=	<span class="number">100</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">secbulk_probe</span><span class="params">(struct usb_interface *interface, <span class="keyword">const</span> struct usb_device_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">secbulk_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_host_interface</span> *<span class="title">iface_desc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_endpoint_descriptor</span> *<span class="title">endpoint</span>;</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	printk(KERN_INFO <span class="string">"secbulk:secbulk probing...\n"</span>);</span><br><span class="line"></span><br><span class="line">	dev = kzalloc(<span class="keyword">sizeof</span>(*dev), GFP_KERNEL);		<span class="comment">//分配一个指针空间，只是为了索引内核的空间</span></span><br><span class="line">	<span class="keyword">if</span>(!dev)</span><br><span class="line">	&#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	iface_desc = interface-&gt;cur_altsetting;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; iface_desc-&gt;desc.bNumEndpoints; i++) <span class="comment">//从USBCore传入的借口中得到得到输出端点</span></span><br><span class="line">	&#123;</span><br><span class="line">		endpoint = &amp;(iface_desc-&gt;endpoint[i].desc);</span><br><span class="line">		<span class="keyword">if</span>(!dev-&gt;bulk_out_endpointAddr</span><br><span class="line">		&amp;&amp; usb_endpoint_is_bulk_out(endpoint))</span><br><span class="line">		&#123;</span><br><span class="line">			printk(KERN_INFO <span class="string">"secbulk:bulk out endpoint found!\n"</span>);</span><br><span class="line">			dev-&gt;bulk_out_endpointAddr = endpoint-&gt;bEndpointAddress;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!(dev-&gt;bulk_out_endpointAddr))</span><br><span class="line">	&#123;</span><br><span class="line">		ret = -EBUSY;</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = usb_register_dev(interface, &amp;secbulk_class);	<span class="comment">//将usb驱动注册成字符设备驱动提供给用户程序</span></span><br><span class="line">	<span class="keyword">if</span>(ret)</span><br><span class="line">	&#123;</span><br><span class="line">		printk(KERN_ERR <span class="string">"secbulk: usb_register_dev failed!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	dev-&gt;udev = usb_get_dev(interface_to_usbdev(interface));</span><br><span class="line"></span><br><span class="line">	usb_set_intfdata(interface, dev);</span><br><span class="line"></span><br><span class="line">	mutex_init(&amp;dev-&gt;io_mutex);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">error:</span><br><span class="line">	<span class="keyword">if</span>(!dev)</span><br><span class="line">		kfree(dev);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_driver</span> <span class="title">secbulk_driver</span>= &#123;</span></span><br><span class="line">	.name=		<span class="string">"secbulk"</span>,</span><br><span class="line">	.probe=		secbulk_probe,</span><br><span class="line">	.<span class="built_in">disconnect</span>=	secbulk_disconnect,</span><br><span class="line">	.id_table=	secbulk_table,</span><br><span class="line">	.supports_autosuspend=<span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">secbulk_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> result;</span><br><span class="line">	printk(KERN_INFO <span class="string">"secbulk:secbulk loaded\n"</span>);</span><br><span class="line">	result = usb_register(&amp;secbulk_driver);		<span class="comment">//1 注册 secbulk_driver, 此处我们就注册了usb_driver，当插入USB后，</span></span><br><span class="line">												<span class="comment">//会调用add_dev,然后将ID号与驱动支持的id进行对比，如果对比通过，就会调用probe</span></span><br><span class="line">	<span class="keyword">if</span>(result)</span><br><span class="line">	&#123;	printk(KERN_ERR <span class="string">"secbulk:usb_register failed: %d"</span>, result);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">secbulk_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	usb_deregister(&amp;secbulk_driver);</span><br><span class="line">	printk(KERN_INFO <span class="string">"secbulk:secbulk unloaded\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(secbulk_init);</span><br><span class="line">module_exit(secbulk_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure>


<p>版权声明：本文为博主原创文章，转载需声明为转载内容并添加原文地址。</p>
<p>原文地址：<a href="https://coderdock.com">https://coderdock.com</a></p>
]]></content>
      <categories>
        <category>ARM&amp;Linux</category>
        <category>Linux驱动</category>
        <category>USB</category>
      </categories>
      <tags>
        <tag>UBS</tag>
        <tag>DNW</tag>
      </tags>
  </entry>
</search>

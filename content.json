{"meta":{"title":"CoderDock","subtitle":"Try Hard to be a Better Programmer","description":"一直在努力的去做一个更好的程序员，为了父母、为了小鑫鑫，更为了自己","author":"Dock","url":"http://coderdock.com"},"pages":[{"title":"All categories","date":"2014-12-22T04:39:04.000Z","updated":"2017-11-25T11:06:09.429Z","comments":true,"path":"categories/index.html","permalink":"http://coderdock.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-11-25T10:55:56.000Z","updated":"2017-11-25T10:56:35.436Z","comments":true,"path":"tags/index.html","permalink":"http://coderdock.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"通信协议-UART-Verilog实现","slug":"通信协议-UART-Verilog实现","date":"2017-12-25T21:03:34.000Z","updated":"2017-12-25T21:07:25.109Z","comments":true,"path":"2017/12/26/通信协议-UART-Verilog实现/","link":"","permalink":"http://coderdock.com/2017/12/26/通信协议-UART-Verilog实现/","excerpt":"&emsp;&emsp;本篇通过使用Verilog实现UART的读写。","text":"&emsp;&emsp;本篇通过使用Verilog实现UART的读写。 RX模块 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394module my_uart_rx( clk,rst_n, rs232_rx,rx_data,rx_int, clk_bps,bps_start );input clk; // 50MHz主时钟input rst_n; //低电平复位信号input rs232_rx; // RS232接收数据信号input clk_bps; // clk_bps的高电平为接收或者发送数据位的中间采样点output bps_start; //接收到数据后，波特率时钟启动信号置位output[7:0] rx_data; //接收数据寄存器，保存直至下一个数据来到output rx_int; //接收数据中断信号,接收到数据期间始终为高电平//----------------------------------------------------------------reg rs232_rx0,rs232_rx1,rs232_rx2,rs232_rx3; //接收数据寄存器，滤波用wire neg_rs232_rx; //表示数据线接收到下降沿always @ (posedge clk or negedge rst_n) begin if(!rst_n) begin rs232_rx0 &lt;= 1&apos;b0; rs232_rx1 &lt;= 1&apos;b0; rs232_rx2 &lt;= 1&apos;b0; rs232_rx3 &lt;= 1&apos;b0; end else begin rs232_rx0 &lt;= rs232_rx; rs232_rx1 &lt;= rs232_rx0; rs232_rx2 &lt;= rs232_rx1; rs232_rx3 &lt;= rs232_rx2; endend //下面的下降沿检测可以滤掉&lt;20ns-40ns的毛刺(包括高脉冲和低脉冲毛刺)， //这里就是用资源换稳定（前提是我们对时间要求不是那么苛刻，因为输入信号打了好几拍） //（当然我们的有效低脉冲信号肯定是远远大于40ns的）assign neg_rs232_rx = rs232_rx3 &amp; rs232_rx2 &amp; ~rs232_rx1 &amp; ~rs232_rx0; //接收到下降沿后neg_rs232_rx置高一个时钟周期//----------------------------------------------------------------reg bps_start_r;reg[3:0] num; //移位次数reg rx_int; //接收数据中断信号,接收到数据期间始终为高电平always @ (posedge clk or negedge rst_n) if(!rst_n) begin bps_start_r &lt;= 1&apos;bz; rx_int &lt;= 1&apos;b0; end else if(neg_rs232_rx) begin //接收到串口接收线rs232_rx的下降沿标志信号 bps_start_r &lt;= 1&apos;b1; //启动串口准备数据接收 rx_int &lt;= 1&apos;b1; //接收数据中断信号使能 end else if(num==4&apos;d12) begin //接收完有用数据信息 bps_start_r &lt;= 1&apos;b0; //数据接收完毕，释放波特率启动信号 rx_int &lt;= 1&apos;b0; //接收数据中断信号关闭 endassign bps_start = bps_start_r;//----------------------------------------------------------------reg[7:0] rx_data_r; //串口接收数据寄存器，保存直至下一个数据来到//----------------------------------------------------------------reg[7:0] rx_temp_data; //当前接收数据寄存器always @ (posedge clk or negedge rst_n) if(!rst_n) begin rx_temp_data &lt;= 8&apos;d0; num &lt;= 4&apos;d0; rx_data_r &lt;= 8&apos;d0; end else if(rx_int) begin //接收数据处理 if(clk_bps) begin //读取并保存数据,接收数据为一个起始位，8bit数据，1或2个结束位 num &lt;= num+1&apos;b1; case (num) 4&apos;d1: rx_temp_data[0] &lt;= rs232_rx; //锁存第0bit 4&apos;d2: rx_temp_data[1] &lt;= rs232_rx; //锁存第1bit 4&apos;d3: rx_temp_data[2] &lt;= rs232_rx; //锁存第2bit 4&apos;d4: rx_temp_data[3] &lt;= rs232_rx; //锁存第3bit 4&apos;d5: rx_temp_data[4] &lt;= rs232_rx; //锁存第4bit 4&apos;d6: rx_temp_data[5] &lt;= rs232_rx; //锁存第5bit 4&apos;d7: rx_temp_data[6] &lt;= rs232_rx; //锁存第6bit 4&apos;d8: rx_temp_data[7] &lt;= rs232_rx; //锁存第7bit default: ; endcase end else if(num == 4&apos;d12) begin //我们的标准接收模式下只有1+8+1(2)=11bit的有效数据 num &lt;= 4&apos;d0; //接收到STOP位后结束,num清零 rx_data_r &lt;= rx_temp_data; //把数据锁存到数据寄存器rx_data中 end endassign rx_data = rx_data_r;endmodule TX模块 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091module my_uart_tx( clk,rst_n, rx_data,rx_int,rs232_tx, clk_bps,bps_start );input clk; // 50MHz主时钟input rst_n; //低电平复位信号input clk_bps; // clk_bps_r高电平为接收数据位的中间采样点,同时也作为发送数据的数据改变点input[7:0] rx_data; //接收数据寄存器input rx_int; //接收数据中断信号,接收到数据期间始终为高电平,在该模块中利用它的下降沿来启动串口发送数据output rs232_tx; // RS232发送数据信号output bps_start; //接收或者要发送数据，波特率时钟启动信号置位//---------------------------------------------------------reg rx_int0,rx_int1,rx_int2; //rx_int信号寄存器，捕捉下降沿滤波用wire neg_rx_int; // rx_int下降沿标志位always @ (posedge clk or negedge rst_n) begin if(!rst_n) begin rx_int0 &lt;= 1&apos;b0; rx_int1 &lt;= 1&apos;b0; rx_int2 &lt;= 1&apos;b0; end else begin rx_int0 &lt;= rx_int; rx_int1 &lt;= rx_int0; rx_int2 &lt;= rx_int1; endendassign neg_rx_int = ~rx_int1 &amp; rx_int2; //捕捉到下降沿后，neg_rx_int拉高保持一个主时钟周期//---------------------------------------------------------reg[7:0] tx_data; //待发送数据的寄存器//---------------------------------------------------------reg bps_start_r;reg tx_en; //发送数据使能信号，高有效reg[3:0] num;always @ (posedge clk or negedge rst_n) begin if(!rst_n) begin bps_start_r &lt;= 1&apos;bz; tx_en &lt;= 1&apos;b0; tx_data &lt;= 8&apos;d0; end else if(neg_rx_int) begin //接收数据完毕，准备把接收到的数据发回去 bps_start_r &lt;= 1&apos;b1; tx_data &lt;= rx_data; //把接收到的数据存入发送数据寄存器 tx_en &lt;= 1&apos;b1; //进入发送数据状态中 end else if(num==4&apos;d11) begin //数据发送完成，复位 bps_start_r &lt;= 1&apos;b0; tx_en &lt;= 1&apos;b0; endendassign bps_start = bps_start_r;//---------------------------------------------------------reg rs232_tx_r;always @ (posedge clk or negedge rst_n) begin if(!rst_n) begin num &lt;= 4&apos;d0; rs232_tx_r &lt;= 1&apos;b1; end else if(tx_en) begin if(clk_bps) begin num &lt;= num+1&apos;b1; case (num) 4&apos;d0: rs232_tx_r &lt;= 1&apos;b0; //发送起始位 4&apos;d1: rs232_tx_r &lt;= tx_data[0]; //发送bit0 4&apos;d2: rs232_tx_r &lt;= tx_data[1]; //发送bit1 4&apos;d3: rs232_tx_r &lt;= tx_data[2]; //发送bit2 4&apos;d4: rs232_tx_r &lt;= tx_data[3]; //发送bit3 4&apos;d5: rs232_tx_r &lt;= tx_data[4]; //发送bit4 4&apos;d6: rs232_tx_r &lt;= tx_data[5]; //发送bit5 4&apos;d7: rs232_tx_r &lt;= tx_data[6]; //发送bit6 4&apos;d8: rs232_tx_r &lt;= tx_data[7]; //发送bit7 4&apos;d9: rs232_tx_r &lt;= 1&apos;b1; //发送结束位 default: rs232_tx_r &lt;= 1&apos;b1; endcase end else if(num==4&apos;d11) num &lt;= 4&apos;d0; //复位 endendassign rs232_tx = rs232_tx_r;endmodule","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://coderdock.com/categories/基础知识/"},{"name":"UART","slug":"基础知识/UART","permalink":"http://coderdock.com/categories/基础知识/UART/"}],"tags":[{"name":"UART","slug":"UART","permalink":"http://coderdock.com/tags/UART/"},{"name":"Verilog实现","slug":"Verilog实现","permalink":"http://coderdock.com/tags/Verilog实现/"}]},{"title":"通信协议-IIC Verilog HDL实现","slug":"通信协议-IIC-Verilog-HDL实现","date":"2017-12-25T14:00:07.000Z","updated":"2017-12-25T07:28:20.320Z","comments":true,"path":"2017/12/25/通信协议-IIC-Verilog-HDL实现/","link":"","permalink":"http://coderdock.com/2017/12/25/通信协议-IIC-Verilog-HDL实现/","excerpt":"&emsp;&emsp;该程序使用Verilog通过状态机实现IIC读写AT24C02。","text":"&emsp;&emsp;该程序使用Verilog通过状态机实现IIC读写AT24C02。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406module iic_com( clk, rst_n, sw1, sw2, // SW1写入AT240C2 scl, sda, //时钟 数据 dis_data //输出变量用数码管显示);input clk;input rst_n;input sw1,sw2;output scl;inout sda;output [7:0] dis_data;reg sw1_r, sw2_r;reg[19:0] cnt_20ms;always @ (posedge clk or negedge rst_n) if(!rst_n) cnt_20ms &lt;= 20&apos;d0; else cnt_20ms &lt;= cnt_20ms + 1&apos;b1; //不断计数always @(posedge clk or negedge rst_n) if(!rst_n) begin sw1_r &lt;= 1&apos;b1; sw2_r &lt;= 1&apos;b1; end else if(cnt_20ms == 20&apos;hfffff) begin sw1_r &lt;= sw1; //20ms进行一次锁存 sw2_r &lt;= sw2; end//以下的程序将输入时钟进行分频，并且应用于SCL输出上reg[2:0] cnt; // cnt=0:scl上升沿，cnt=1:scl高电平中间，cnt=2:scl下降沿，cnt=3:scl低电平中间reg[8:0] cnt_delay; //500循环计数，产生iic所需要的时钟reg scl_r; //时钟脉冲寄存器always @ (posedge clk or negedge rst_n) if(!rst_n) cnt_delay &lt;= 9&apos;d0; else if(cnt_delay == 9&apos;d499) cnt_delay &lt;= 9&apos;d0; //计数到10us为scl的周期，即100KHz else cnt_delay &lt;= cnt_delay+1&apos;b1; //时钟计数always @ (posedge clk or negedge rst_n) begin if(!rst_n) cnt &lt;= 3&apos;d5; else begin case (cnt_delay) 9&apos;d124: cnt &lt;= 3&apos;d1; //cnt=1:scl高电平中间,用于数据采样 9&apos;d249: cnt &lt;= 3&apos;d2; //cnt=2:scl下降沿 9&apos;d374: cnt &lt;= 3&apos;d3; //cnt=3:scl低电平中间,用于数据变化 9&apos;d499: cnt &lt;= 3&apos;d0; //cnt=0:scl上升沿 default: cnt &lt;= 3&apos;d5; endcase endend`define SCL_POS (cnt == 3&apos;d0)`define SCL_HIG (cnt == 3&apos;d1)`define SCL_NEG (cnt == 3&apos;d2)`define SCL_LOW (cnt == 3&apos;d3)always @(posedge clk or negedge rst_n) if(!rst_n) scl_r &lt;= 1&apos;b0; else if(cnt == 3&apos;d0) scl_r &lt;= 1&apos;b1; //scl信号设置为高 else if(cnt == 3&apos;d2) scl_r &lt;= 1&apos;b0; //scl信号设置为低 assign scl = scl_r; //模块对外输出SCL信号//具体对24C02的具体操作`define DEVICE_READ 8&apos;b1010_0001`define DEVICE_WRITE 8&apos;b1010_0000`define WRITE_DATA 8&apos;b0001_0001`define BYTE_ADDR 8&apos;b0000_0011reg[7:0] db_r; //在IIC上传送的数据寄存器reg[7:0] read_data; //读出的EEPROM的数据//读写时序parameter IDLE = 4&apos;d0;parameter START1 = 4&apos;d1;parameter ADD1 = 4&apos;d2;parameter ACK1 = 4&apos;d3;parameter ADD2 = 4&apos;d4;parameter ACK2 = 4&apos;d5;parameter START2 = 4&apos;d6;parameter ADD3 = 4&apos;d7;parameter ACK3 = 4&apos;d8;parameter DATA = 4&apos;d9;parameter ACK4 = 4&apos;d10;parameter STOP1 = 4&apos;d11;parameter STOP2 = 4&apos;d12;reg[3:0] cstate; //状态寄存器reg sda_r; //输出数据寄存器 reg sda_link; //输出数据sda信号inout方向控制位 1 输入 0 输出reg[3:0] num;always@(posedge clk or negedge rst_n)begin if(!rst_n) begin cstate &lt;= IDLE; sda_r &lt;= 1&apos;b1; sda_link &lt;= 1&apos;b0; num &lt;= 4&apos;d0; read_data &lt;= 8&apos;b0000_0000; end else case(cstate) IDLE: begin sda_link &lt;= 1&apos;b1; sda_r &lt;= 1&apos;b1; if(!sw1_r || sw2_r) begin db_r &lt;= `DEVICE_WRITE; cstate &lt;= START1; end else cstate &lt;= IDLE; end START1: //先给出开始信号 begin if(`SCL_HIG) begin sda_link &lt;= 1&apos;b1; //设置sda为output sda_r &lt;= 1&apos;b0; //拉低sda,产生起始信号 cstate &lt;= ADD1; //进入下一阶段 num &lt;= 4&apos;d0; end else cstate &lt;= START1; //等待达到 SCL高电平中间 end ADD1: begin if(`SCL_LOW) //低电平变换数据 begin if(num == 4&apos;d8) begin num &lt;= 4&apos;d0; sda_r &lt;= 1&apos;b1; sda_link &lt;= 1&apos;b0; //sda设置为高阻态（input） cstate &lt;= ACK1; end else begin cstate &lt;= ADD1; num &lt;= num + 1&apos;b1; case(num) 4&apos;d0: sda_r &lt;= db_r[7]; 4&apos;d1: sda_r &lt;= db_r[6]; 4&apos;d2: sda_r &lt;= db_r[5]; 4&apos;d3: sda_r &lt;= db_r[4]; 4&apos;d4: sda_r &lt;= db_r[3]; 4&apos;d5: sda_r &lt;= db_r[2]; 4&apos;d6: sda_r &lt;= db_r[1]; 4&apos;d7: sda_r &lt;= db_r[0]; default: ; endcase end end else cstate &lt;= ADD1; end ACK1: begin if(`SCL_NEG) //该器件不考虑应答，直接认为已经响应，接下来传输写入的地址 begin cstate &lt;= ADD2; db_r &lt;= `BYTE_ADDR; end else cstate &lt;= ACK1; end ADD2: //写入数据的地址 begin if(`SCL_LOW) begin if(num == 4&apos;d8) begin num &lt;= 4&apos;d0; sda_r &lt;= 1&apos;b1; sda_link &lt;= 1&apos;b0; //设置为高阻态，为解说应答做准备 cstate &lt;= ACK2; end else begin sda_link &lt;= 1&apos;b1; num &lt;= num + 1&apos;b1; case(num) 4&apos;d0: sda_r &lt;= db_r[7]; 4&apos;d1: sda_r &lt;= db_r[6]; 4&apos;d2: sda_r &lt;= db_r[5]; 4&apos;d3: sda_r &lt;= db_r[4]; 4&apos;d4: sda_r &lt;= db_r[3]; 4&apos;d5: sda_r &lt;= db_r[2]; 4&apos;d6: sda_r &lt;= db_r[1]; 4&apos;d7: sda_r &lt;= db_r[0]; default: ; endcase cstate &lt;= ADD2; end end else cstate &lt;= ADD2; end ACK2: begin if(`SCL_NEG) begin if(!sw1_r) //根据按键判断是读还是写 begin cstate &lt;= DATA; db_r &lt;= `WRITE_DATA; end else if(!sw2_r) begin db_r &lt;= `DEVICE_READ; cstate &lt;= START2; end end else cstate &lt;= START2; end START2: begin if(`SCL_LOW) begin sda_link &lt;= 1&apos;b1; sda_r &lt;= 1&apos;b1; cstate &lt;= START2; end else if(`SCL_HIG) begin sda_r &lt;= 1&apos;b0; cstate &lt;= ADD3; end else cstate &lt;= START2; end ADD3: //写入要读的地址 begin if(`SCL_LOW) begin if(num == 4&apos;d8) begin num &lt;= 4&apos;d0; sda_r &lt;= 1&apos;b1; sda_link &lt;= 1&apos;b0; cstate &lt;= ACK3; end else begin case(num) 4&apos;d0: sda_r &lt;= db_r[7]; 4&apos;d1: sda_r &lt;= db_r[6]; 4&apos;d2: sda_r &lt;= db_r[5]; 4&apos;d3: sda_r &lt;= db_r[4]; 4&apos;d4: sda_r &lt;= db_r[3]; 4&apos;d5: sda_r &lt;= db_r[2]; 4&apos;d6: sda_r &lt;= db_r[1]; 4&apos;d7: sda_r &lt;= db_r[0]; default: ; endcase cstate &lt;= ADD3; end end else cstate &lt;= ADD3; end ACK3: begin if(`SCL_NEG) begin cstate &lt;= DATA; sda_link &lt;= 1&apos;b0; end else cstate &lt;= ACK3; end DATA: begin if(!sw2_r) //读操作 begin if(num &lt;= 4&apos;d7) begin cstate &lt;= DATA; if(`SCL_HIG) begin num &lt;= num + 1&apos;b1; case(num) 4&apos;d0: read_data[7] &lt;= sda; //依次在高电平保存数据 4&apos;d1: read_data[6] &lt;= sda; 4&apos;d2: read_data[5] &lt;= sda; 4&apos;d3: read_data[4] &lt;= sda; 4&apos;d4: read_data[3] &lt;= sda; 4&apos;d5: read_data[2] &lt;= sda; 4&apos;d6: read_data[1] &lt;= sda; 4&apos;d7: read_data[0] &lt;= sda; default: ; endcase end end else if((`SCL_LOW) &amp;&amp; (num == 4&apos;d8)) begin num &lt;= 4&apos;d0; cstate &lt;= ACK4; end else cstate &lt;= DATA; end else if(!sw1_r) //写操作 begin sda_link &lt;= 1&apos;b1; if(num &lt;= 4&apos;d7) begin cstate &lt;= DATA; if(`SCL_LOW) begin sda_link &lt;= 1&apos;b1; num &lt;= num + 1&apos;b1; case(num) 4&apos;d0: sda_r &lt;= db_r[7]; 4&apos;d1: sda_r &lt;= db_r[6]; 4&apos;d2: sda_r &lt;= db_r[5]; 4&apos;d3: sda_r &lt;= db_r[4]; 4&apos;d4: sda_r &lt;= db_r[3]; 4&apos;d5: sda_r &lt;= db_r[2]; 4&apos;d6: sda_r &lt;= db_r[1]; 4&apos;d7: sda_r &lt;= db_r[0]; default: ; endcase end end else if((`SCL_LOW) &amp;&amp; (num == 4&apos;d8)) begin num &lt;= 4&apos;d0; sda_r &lt;= 1&apos;b1; sda_link &lt;= 1&apos;b0; cstate &lt;= ACK4; end else cstate &lt;= ACK4; end end ACK4: begin if(`SCL_NEG) begin cstate &lt;= STOP1; end else cstate &lt;= ACK4; end STOP1: begin if(`SCL_LOW) begin sda_link &lt;= 1&apos;b1; sda_r &lt;= 1&apos;b0; cstate &lt;= STOP1; end else if(`SCL_HIG) begin sda_r &lt;= 1&apos;b1; cstate &lt;= STOP2; end else cstate &lt;= STOP1; end STOP2: begin if(`SCL_LOW) sda_r &lt;= 1&apos;b1; else if(cnt_20ms == 20&apos;hffff0) cstate &lt;= IDLE; else cstate &lt;= STOP2; end default: cstate &lt;= IDLE; endcaseendassign sda = sda_link ? sda_r:1&apos;bz;assign dis_data = read_data;endmodule","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://coderdock.com/categories/基础知识/"}],"tags":[{"name":"IIC","slug":"IIC","permalink":"http://coderdock.com/tags/IIC/"},{"name":"Verilog HDL","slug":"Verilog-HDL","permalink":"http://coderdock.com/tags/Verilog-HDL/"},{"name":"IIC实现","slug":"IIC实现","permalink":"http://coderdock.com/tags/IIC实现/"}]},{"title":"通信协议-IIC","slug":"通信协议-IIC","date":"2017-12-24T09:39:56.000Z","updated":"2017-12-24T09:46:10.267Z","comments":true,"path":"2017/12/24/通信协议-IIC/","link":"","permalink":"http://coderdock.com/2017/12/24/通信协议-IIC/","excerpt":"&emsp;&emsp;IIC协议在Dock看来是最简单易懂的协议之一。本文介绍IIC协议的基础要点。","text":"&emsp;&emsp;IIC协议在Dock看来是最简单易懂的协议之一。本文介绍IIC协议的基础要点。 1.IIC基础要点 在时钟的高电平周期内，SDA线上的数据必须保持稳定，数据线仅可以在时钟SCL为低电平时改变。 起始条件：当SCL为高电平的时候，SDA线上由高到低的跳变被定义为起始条件 结束条件：当SCL为高电平的时候，SDA线上由低到高的跳变被定义为停止条件 每当主机向从机发送完一个字节的数据，主机总是需要等待从机给出一个应答信号，以确认从机是否成功接收到了数据，从机应答主机所需要的时钟仍是主机提供的，应答出现在每一次主机完成8个数据位传输后紧跟着的时钟周期，低电平0表示应答，1表示非应答。 2 IIC的C实现 初始时SDA、SCL都处于高电平 1234567void Init()&#123; SCL = 1; delay(); SDA = 1; delay();&#125; 起始信号 SDA在SCL为高电平时产生下降沿： 12345678void StartUp&#123; SCL = 1; SDA = 1; delay(); SDA = 0; delay();&#125; 结束信号 SDA在SCL为高电平时产生上升沿： 12345678void End()&#123; SCL = 1; SDA = 0; delay(); SDA = 1; delay();&#125; 字节发送函数 SCL为低时SDA变为有效数据，SCL为高时，采集数据 123456789101112void Transfer(int8_t i8Send)&#123; int32_t nIndex = 0; for(nIndex = 7; nIndex &gt;= 0; nIndex++) &#123; SCL = 0; SDA = (i8Send &gt;&gt; nIndex) &amp; 0x01; //MSB方式进行发送 delay(); SCL = 1; //变为高电平，SLAVE短进行数据锁存 delay(); &#125;&#125; 判断回复报文 Slave端主动拉低SDA 123456789101112int8_t CheckAck()&#123; delay(); if(SDA == 0) &#123; return 1; &#125; else &#123; return 0; &#125;&#125;","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://coderdock.com/categories/基础知识/"},{"name":"IIC","slug":"基础知识/IIC","permalink":"http://coderdock.com/categories/基础知识/IIC/"}],"tags":[]},{"title":"通信协议-SPI","slug":"通信协议-SPI","date":"2017-12-24T07:57:46.000Z","updated":"2017-12-24T07:57:46.931Z","comments":true,"path":"2017/12/24/通信协议-SPI/","link":"","permalink":"http://coderdock.com/2017/12/24/通信协议-SPI/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"通信协议-UART","slug":"通信协议-UART","date":"2017-12-24T07:57:25.000Z","updated":"2017-12-25T15:19:44.283Z","comments":true,"path":"2017/12/24/通信协议-UART/","link":"","permalink":"http://coderdock.com/2017/12/24/通信协议-UART/","excerpt":"&emsp;&emsp;UART协议也是一种很简单易懂的通信协议。 &emsp;&emsp;通用异步收发传输器(Universal Asynchronous Receiver/Transmitter)，通常称作 UART，是一种异步收发传输器。将数据由串行通信与并行通信间作传输转换，作为并行输入成为串行输出的芯片 UART 是一种通用串行数据总线，用于异步通信。该总线双向通信，可以实现全双工传输和接收。","text":"&emsp;&emsp;UART协议也是一种很简单易懂的通信协议。 &emsp;&emsp;通用异步收发传输器(Universal Asynchronous Receiver/Transmitter)，通常称作 UART，是一种异步收发传输器。将数据由串行通信与并行通信间作传输转换，作为并行输入成为串行输出的芯片 UART 是一种通用串行数据总线，用于异步通信。该总线双向通信，可以实现全双工传输和接收。 1.协议要点 起始位：先发出一个逻辑”0”的信号，表示传输字符的开始。 数据位：紧接着起始位之后。数据位的个数可以是4、5、6、7、8等，构成一个字符。通常采用 ASCII 码。从最低位开始传送，靠时钟定位。 奇偶校验位：数据位加上这一位后，使得“1”的位数应为偶数(偶校验)或奇数(奇校验)，以此来校验数据传送的正确性。 停止位：它是一个字符数据的结束标志。可以是1位、1.5位、2位的高电平。由于数据是在传输线上定时的，并且每一个设备有其自己的时钟，很可能在通信中两台设备间出现了小小的不同步。因此停止位不仅仅是表示传输的结束，并且提供计算机校正时钟同步的机会。适用于停止位的位数越多，不同时钟同步的容忍程度越大。但是数据传输率同时也越慢。 空闲位：处于逻辑“1”状态，表示当前线路上没有数据传送 2.波特率&emsp;&emsp;波特率及1秒钟能传输的Bit数。如9600波特率及指一个脉冲的时间为 1/9600 S。","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://coderdock.com/categories/基础知识/"},{"name":"UART","slug":"基础知识/UART","permalink":"http://coderdock.com/categories/基础知识/UART/"}],"tags":[{"name":"通信协议","slug":"通信协议","permalink":"http://coderdock.com/tags/通信协议/"},{"name":"UART","slug":"UART","permalink":"http://coderdock.com/tags/UART/"}]},{"title":"ARM指令之必知必会","slug":"ARM指令之必知必会","date":"2017-12-24T07:53:33.000Z","updated":"2017-12-24T07:53:33.640Z","comments":true,"path":"2017/12/24/ARM指令之必知必会/","link":"","permalink":"http://coderdock.com/2017/12/24/ARM指令之必知必会/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"我的Makefilee模板","slug":"我的Makefilee模板","date":"2017-12-24T07:52:42.000Z","updated":"2017-12-24T07:52:42.613Z","comments":true,"path":"2017/12/24/我的Makefilee模板/","link":"","permalink":"http://coderdock.com/2017/12/24/我的Makefilee模板/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"ViVado 找不到设备","slug":"ViVado-找不到设备","date":"2017-06-28T02:00:45.000Z","updated":"2017-12-24T09:46:52.807Z","comments":true,"path":"2017/06/28/ViVado-找不到设备/","link":"","permalink":"http://coderdock.com/2017/06/28/ViVado-找不到设备/","excerpt":"Vivado 在Linux上找不到设备是因为jtag驱动没安装， 情况如下：","text":"Vivado 在Linux上找不到设备是因为jtag驱动没安装， 情况如下：而在Linux上需要以下几条命令进行安装：12345sudo -scd /opt/Xilinx/Vivado/2017.1/data/xicom/cable_drivers/lin64/cp -a install_script/ /opt/cd /opt./install_script/install_drivers/install_drivers 官方回复见此处：1https://www.xilinx.com/support/answers/54381.html","categories":[{"name":"日常记录","slug":"日常记录","permalink":"http://coderdock.com/categories/日常记录/"},{"name":"工具","slug":"日常记录/工具","permalink":"http://coderdock.com/categories/日常记录/工具/"}],"tags":[{"name":"Vivado","slug":"Vivado","permalink":"http://coderdock.com/tags/Vivado/"}]},{"title":"打造自己的VIM编辑器","slug":"Dock工具-打造自己的VIM编辑器","date":"2017-02-25T07:25:27.000Z","updated":"2017-12-24T04:23:16.245Z","comments":true,"path":"2017/02/25/Dock工具-打造自己的VIM编辑器/","link":"","permalink":"http://coderdock.com/2017/02/25/Dock工具-打造自己的VIM编辑器/","excerpt":"作为一个经常在Linux下开发的程序员，怎么能没有自己高逼格的VIM编辑器呢？在这片教程中会一步步的搭建起自己的高逼格VIM！","text":"作为一个经常在Linux下开发的程序员，怎么能没有自己高逼格的VIM编辑器呢？在这片教程中会一步步的搭建起自己的高逼格VIM！ 1. 主题&emsp;&emsp;刀客喜欢的主题有两个：molokai 、Solarized 1.1 molokai&emsp;&emsp;molokai的特点是色彩艳丽，设置为暗色背景很适合程序员开发。并且网上的教程都是使用Bundle进行安装，但刀客尝试后发现自己无法正常安装。还是一步步的从GIt进行安装更靠谱点。 git clone git@github.com:tomasr/molokai.git 将colors 文件夹的molokai.vim 拷贝到~/.vim/colors 在~/.vimrc中添加如下语句： 123colorscheme molokaiset t_Co=256set background=dark 噔噔噔噔！打开vim编辑器是不是变得很炫酷了？ 1.2 Solarized&emsp;&emsp;Solarized主题是使用最广泛的vim主题。但刀客还是更喜欢molokai一点。 git clone git@github.com/altercation/vim-colors-solarized 将colors 文件夹的molokai.vim 拷贝到~/.vim/colors 在~/.vimrc中添加如下语句： 123syntax enableset background=darkcolorscheme solarized 快快地打开你的vim编辑器看一下吧。 2. VIM 安装 作为一个程序员怎么能够不会使用源码这么高（苦）大（逼）的软件安装方式呢？好吧！是因为我要安装YCM(YouCompleteMe)代码自动不全工具需要Python的支持，但通过命令行安装的VIM一般不支持Python。 2.1 卸载VIM&emsp;&emsp;如果你的电脑上安装着vim,你需要完全卸载之前的VIM,方法很简单也很粗暴：12345sudo apt-get remove vimsudo apt-get remove vim-runtimesudo apt-get remove vim -tinysudo apt-get remove vim-commonsudo apt-get remove vim-docsudo apt-get remove vim-script 保证把vim卸载的渣渣都不剩。 2.2 安装&emsp;&emsp;先安装一下依赖吧，很简单,反正也不多：123sudo apt-get install libncurses5-dev libgnome2-dev libgnomeui-dev libgtk2.0-dev libatk1.0-dev libbonoboui2-dev libcairo2-dev libx11-dev libxpm-dev libxt-dev python-dev python3-dev ruby-dev liblua5.1-dev libperl-dev git &emsp;&emsp;然后下载vim,之后进行配置、编译、安装，三板斧嘛，开始：12345678910111213141516cd ~git clone https://github.com/vim/vim.gitcd vim./configure --with-features=huge \\ --enable-multibyte \\ --enable-rubyinterp=yes \\ --enable-pythoninterp=yes \\ --with-python-config-dir=/usr/lib/python2.7/config-x86_64-linux-gnu \\ --enable-python3interp=yes \\ --with-python3-config-dir=/usr/lib/python3.5/config-3.5m-x86_64_linux-gnu \\ --enable-perlinterp=yes \\ --enable-luainterp=yes \\ --enable-gui=gtk2 --enable-cscope --prefix=/usrmake VIMRUNTIMEDIR=/usr/share/vim/vim80cd ~/vimsudo make install 齐活！ 3.安装YCM&emsp;&emsp;VIM被称为编辑器之神，而YCM则是vim中最难装的插件，简直就是神的脚后跟。在网上搜索YCM的安装，基本都是使用Bundle安装，可是我试了好几次还是安装不上。算了还是苦逼地从源码安装吧。 &emsp;&emsp;经过刀客我的尝试，终于从源码安装上了YCM! 3.1 下载YCM&emsp;&emsp;首先将YCM从git下载到本地，我选了 ~/.vim/bundle/。因为之前通过Bundle安装没有成功，正好有这么一个文件夹，没有的自己见一个就是了。。。。 1234# 下载 （在 `～/.vim/bundle` 目录下）git clone --recursive git@github.com/Valloric/YouCompleteMe.git# 检查完整性（在 `～/.vim/bundle/YouCompleteMe` 目录下）git submodule update --init --recursive 这样就开始编译安装了是么？ NO No NO!,我们还需要安装依赖呢12#sudo apt-get install llvm-5.0 clang-5.0 libclang-5.0-dev libboost-all-dev 我统一选择了5.0版本，你要根据自己的软件源里的版本进行安装哦。 3.3 编译安装在家目录下新建一个安装目录，然后进行执行一下命令：12345mkdir ~/.ycm_buildcd ~/.ycm_buildcmake -G &quot;Unix Makefiles&quot; -DUSE_SYSTEM_BOOST=ON -DUSE_SYSTEM_LIBCLANG=ON . ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cppcmake -G &quot;Unix Makefiles&quot; -DUSE_SYSTEM_BOOST=ON -DEXTERNAL_LIBCLANG_PATH=/usr/lib/x86_64-linux-gnu/libclang-5.0.so . ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cppcmake --build . --target ycm_core --config Release 将配置文件拷贝到 ~/.vim1cp ~/.vim/bundle/YouCompleteMe/third_party/ycmd/examples/.ycm_extra_conf.py ~/.vim/ 最后在 ~/.vimrc中添加以下语句：12let g:ycm_server_python_interpreter=&apos;/usr/bin/python&apos;let g:ycm_global_ycm_extra_conf=&apos;~/.vim/.ycm_extra_conf.py&apos; 打开你的编辑器看一下吧！ 4.安装ctags和taglist&emsp;&emsp;众所周知，在Linux阅读大型源码是一件比较困难的事情，我们可以使用SourceInsigh或者UnderStand，但是总有一种被强奸的感觉，因为这样做不Linux啊。 &emsp;&emsp;总的来说，ctags负责将源码中的各个变量生成各个标签，我们可以随时查看调用位置。而taglist基于ctags提供了结构化浏览的功能，我们可以查看一个结构体中有哪些变量等等。 4.1 安装ctags使用命令行：1sudo apt-get install ctags 或者从github上下载源码后，使用三板斧：1./configure &amp;&amp; make &amp;&amp; make install 在.vimrc中添加1map &lt;C-F12&gt; :!ctags -R --c++-kinds=+p --fields=+iaS --extra=+q .&lt;CR&gt; 我们就可以进入代码根目录后，打开Vim，按下Ctrl-F12快捷键自动生成tags文件。命令执行完后，会在源代码目录生成tags文件。Vim默认会自动读取当前目录下的tags文件，所以不需要修改~/.vimrc文件。 此时，我们已经具有定义跳转的功能了。有两组快捷键是最常用的。12Ctrl-] 跳转到光标所在符号的定义。Ctrl-t 回到上次跳转前的位置。 更多功能通过命令man ctags或在Vim命令行下运行help ctags查询。 4.2 安装Taglist从下方网址下载talist包，解压打~/.vim，注意的是如果之前已经存在了doc或者plugin文件夹，我们只需要将对应文件放置到对应文件夹即可。 然后在 .vimrc中添加如下两句：12let Tlist_Show_One_File=1 let Tlist_Exit_OnlyWindow=1 5 安装NERDTree&emsp;&emsp;我们使用VIM进行大型源码编程的时候总是无法看到目录结构，这是一件比较苦恼的事情，那么我们就可以使用NERDTree来解决。方法很简单：1git clone https://github.com/scrooloose/nerdtree.git ~/ 然后将目录中的文件放置到对应的文件夹即可。进入 vims使用命令 NERDTreeToggle看看目录结构出来了没有。我们也可以在.vimrc中设置快捷键1map &lt;F6&gt; :NERDTreeToggle&lt;CR&gt; 这样就可以使用 F6打开或者关闭目录结构了。","categories":[{"name":"编程工具","slug":"编程工具","permalink":"http://coderdock.com/categories/编程工具/"}],"tags":[{"name":"编程工具","slug":"编程工具","permalink":"http://coderdock.com/tags/编程工具/"}]},{"title":"交叉编译之必知必会","slug":"交叉编译之必知必会","date":"2017-02-25T04:25:39.000Z","updated":"2017-12-24T09:47:15.207Z","comments":true,"path":"2017/02/25/交叉编译之必知必会/","link":"","permalink":"http://coderdock.com/2017/02/25/交叉编译之必知必会/","excerpt":"&emsp;&emsp;做嵌入式开发，最熟悉的莫过于交叉编译了。在这篇文章中，记录自己经常使用到的相关知识，以共查阅。","text":"&emsp;&emsp;做嵌入式开发，最熟悉的莫过于交叉编译了。在这篇文章中，记录自己经常使用到的相关知识，以共查阅。 1. 编译器&emsp;&emsp;嵌入式开发和桌面应用的一个很大不同就是：我们必须自己准备配置所需的工具环境。并不像Windows开发那样装一个VS就一切OK了，这其中最重要的就是编译器的准备。 在Ubuntu上我一般是使用sudo apt-get install arm-linux-gnu命令进行交叉编译工具的安装。但大多数时候这是行不通的。因为arm架构或者特定ARM芯片的特性（如是否支持浮点运算），导致后期使用时故障频出。 使用开发板提供商或芯片提供商提供的开发套件，这些往往对某些特性做了优化，是最能契合我们的芯片开发的一种方式。 去Linaro下载对应架构的编译程序，这些开发环境适用性很好，在没能找到官方提供的套件的时候，这是一个很好的选择。 &emsp;&emsp;当然，下载安装完成后需要将可执行文件的路径加到系统的 PATH路径中 2.交叉编译器选项2.1 编译步骤&emsp;&emsp;编译程序分为4个步骤： 1.预处理，生成预编译文件（.文件）： Gcc –E hello.c –o hello.i 2.编译，生成汇编代码（.s文件）： Gcc –S hello.i –o hello.s 3.汇编，生成目标文件（.o文件）： Gcc –c hello.s –o hello.o 4.链接，生成可执行文件： Gcc hello.o –o hello 记住这三个选项只要记住键盘左上角的按键 ESC即可，是不是很简单 2.2 警告选项&emsp;&emsp;在默认情况下，警告选项是默认不打开的，后来Dock在开发的实践过程中，返现使用-Wall选项可以事先发现很多简单错误，为后期免去很多麻烦： 判断语句 if(a = b) 缺少 default分支 类型不匹配对比int a = 0; long b = 2; if(a == b) 其他Dock还未遇到的 &emsp;&emsp;就是这三个简单的错误，曾经让Dock花费很多时间去调试。错误应该消灭在萌芽。 2.3 包含链接选项&emsp;&emsp;Gcc编译器默认是会自动寻找包含编译环境中的头文件和链接库，但是在使用自己的头文件和链接库时，需要自己手动指定。 -I[path-to-include_file] 使用 -I 指定头文件的路径 -L[path-to-lib] 使用-L 指定库文件的路径 -lxx.so 使用-l 选项指定要链接的库文件，默认 l代替lib文件，如链接libmath.so要使用 -lmath -nostartfiles 不链接启动文件，即暂时不链接main函数 -nostdlib 不链接标准库文件，在裸机程序中比较常用，如uboot中就会使用到这个选项，因为链接标准库的话，程序就会变得很大。 -static 静态链接，这样就不会使用动态库，但后边有时需要制定 libxx.a静态库文件，同时文件体积会变得很大 2.4 objcpy objdump&emsp;&emsp;虽然说能够编译出程序并且能够运行就已经够了，但是这两个程序使我们做嵌入式程序所不能忽视的。 2.4.1 ELF格式 ELF(Executable and Linking Format)是unix-like系统下的一种文件格式，它是一种对象文件的格式，用于定义不同类型的对象文件(Object files)中都放了什么东西、以及都以什么样的格式去放这些东西。即是在程序的头部加上了一段信息： 1234567891011121314151617181920ELF Header: Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 Data: 2&apos;s complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: EXEC (Executable file) Machine: Advanced Micro Devices X86-64 Version: 0x1 Entry point address: 0x42dfe0 Start of program headers: 64 (bytes into file) Start of section headers: 67460488 (bytes into file) Flags: 0x0 Size of this header: 64 (bytes) Size of program headers: 56 (bytes) Number of program headers: 8 Size of section headers: 64 (bytes) Number of section headers: 40 Section header string table index: 37 对应的结构体为：12345678910111213141516typedef struct&#123; unsigned char e_ident[EI_NIDENT]; /* 魔数和相关信息 */ Elf32_Half e_type; /* 目标文件类型 */ Elf32_Half e_machine; /* 硬件体系 */ Elf32_Word e_version; /* 目标文件版本 */ Elf32_Addr e_entry; /* 程序进入点 */ Elf32_Off e_phoff; /* 程序头部偏移量 */ Elf32_Off e_shoff; /* 节头部偏移量 */ Elf32_Word e_flags; /* 处理器特定标志 */ Elf32_Half e_ehsize; /* ELF头部长度 */ Elf32_Half e_phentsize; /* 程序头部中一个条目的长度 */ Elf32_Half e_phnum; /* 程序头部条目个数 */ Elf32_Half e_shentsize; /* 节头部中一个条目的长度 */ Elf32_Half e_shnum; /* 节头部条目个数 */ Elf32_Half e_shstrndx; &emsp;&emsp;但是在uboot等环境中，是无法识别这些信息的。裸机程序总是从头一条一条指令的进行执行。所以在有些情况下我们需要去掉这些信息。那就用到了objcopy命令： objcopy用于将object的部分获全部内容拷贝到另一个object，从而可以实现格式的变换。 如 arm-linux-gnu-objcopy -O binary boot.elf boot.bin就常用来将elf转换为RAW格式，从而在裸机上运行。 2.4.2 objdump&emsp;&emsp;objdumpb即是常用的反汇编程序，Dock常用的两条命令为： arm--linux-objdump -d boot.elf将 elf反汇编 arm--linux-objdump -d -b binary -m arm boot.bin 将 bin反汇编","categories":[{"name":"日常知识","slug":"日常知识","permalink":"http://coderdock.com/categories/日常知识/"},{"name":"工具","slug":"日常知识/工具","permalink":"http://coderdock.com/categories/日常知识/工具/"}],"tags":[{"name":"交叉编译","slug":"交叉编译","permalink":"http://coderdock.com/tags/交叉编译/"},{"name":"arm-linux","slug":"arm-linux","permalink":"http://coderdock.com/tags/arm-linux/"}]},{"title":"ARM要分清","slug":"ARM要分清","date":"2016-12-24T03:06:52.000Z","updated":"2017-12-24T09:45:05.380Z","comments":true,"path":"2016/12/24/ARM要分清/","link":"","permalink":"http://coderdock.com/2016/12/24/ARM要分清/","excerpt":"&emsp;&emsp;总是有人在说，我是搞ARM的，到底是说的ARM架构还是ARM系列，这点要搞清楚！","text":"&emsp;&emsp;总是有人在说，我是搞ARM的，到底是说的ARM架构还是ARM系列，这点要搞清楚！&emsp;&emsp;在Dock看来，ARM有两个概念，ARM架构、ARM系列,不同的架构，不同的系列在性能、功耗、尤其是价格方面有着很大的不同。 1. ARM公司&emsp;&emsp;ARM(Advanced RISC Machine)公司作为半导体行业最为著名的公司，你不能不知道。详情看度娘ARM。下面我们重点说架构和系列两个概念。 2. ARM架构&emsp;&emsp;ARM架构指的就是这颗芯片内核所用的指令集的版本。C++语言还有C++10、C++11版本之说，更何况内核呢？ &emsp;&emsp;最为显著的就是总线宽度。”Thumb指令集”为16位，”ARM指令集”为32位,以及”ISA指令集”为64位。这也就从根本上区分了每一个ARM内核有所不同。当然ARM还有很多很多不同的拓展功能，如Java加速器-Jazelle、TrustZone技术、SIMD等，这些不同的组合就组成了不同的ARM架构。 2.1 ARMv4 ARMv5 ARMv6 ARMv7&emsp;&emsp;这是市面上最老的ARM架构版本了。只支持32位地址空间，ARM7系列的一些芯片用到了这个指令集。 &emsp;&emsp;ARMv5相较于v4架构增加了DSP指令优化。 &emsp;&emsp;ARMv6 在存储系统、异常处理等方面做了很多改进，最为重要的是增加了对多媒体处理的支持。 &emsp;&emsp;ARMv7增加了NEON GPU多媒体处理支持，将DSP和媒体处理能力提高了近四倍，并且支持改良的浮点运算。满足下一代3D图形应用的需求，也就是从v7开始，ARMv7架构的处理器芯片开始应用于智能终端设备。 2.2 ARMv8&emsp;&emsp;2011年11月，ARM公司发布了新一代处理器架构ARMv8的部分技术细节。这是ARM公司的首款支持64位指令集的处理器架构。但其支持AArch32 AArch64两套指令集，为的就是向前兼容32位的应用。 2.3 拓展&emsp;&emsp;有时候我们又能看到ARMv5TEJ等词汇，这又是什么意思，后面的每一个字母代表一种拓展功能。如 T-Thumb指令集、E-增强型DSP指令 J-Java加速器。 3. ARM系列&emsp;&emsp;在相同的指令集下，搭配不同的部件就可以组成不同的功能的处理器。比如有无内存管理，有无调试功能等。 3.1 ARM7-11&emsp;&emsp;ARM7 - ARM11是比较老的一些处理器器了。其主要的分别大致如下： ARM7是低功耗的32位处理器，主要特点是没有MMU(内存管理)，如果有人给你说他用ARM7跑系统，你就可以呵呵了。 相较于ARM7,增加了MMU和Cache,指令集执行效率相比于ARM7有很大提高，最高可达300MIPS。 ARM11,基于ARMv6指令集架构，在实时性和浮点处理方面有很大提高。 3.2 ARM-Cortex&emsp;&emsp;在ARM11以后，ARM就不再以数字进行ARM处理器系列进行区分，而是使用Cortex进行命名。主要区分为一下三个系列： Cortex-A 和 Cortex-A50 系列 - 面向开放式操作系统的高性能处理器。 Cortex-R 系列- 面向实时应用的卓越性能。 Cortex-M 系列 - 面向具有确定性的微控制器应用的成本功耗敏感型解决方案。 &emsp;&emsp;ARM Cortex-A 内核基于ARMv7-A架构，基本上都可以支持ARM、Thumb-2、Thumb指令集、Java加速扩展的Jazelle技术、ThustZone的安全扩展、针对浮点FPU的VFP硬件扩展、DSP &amp; SIMD 扩展、并行多数据SIMD的NEON多媒体处理器扩展、主流的嵌入式OS（Linux、Android、Windows Mobile、Windows Phone、Symbian）、以及支持分支预测branch prediction。但各处理器在VFP/NEON的类型、半精度浮点（16-bit half precision floating-point）的支持、多核MPCore、流水线pipeline、单MHz处理性能、L1/L2 cache控制器、乱序执行、指令dual-issue并发等方面有略有不同。 &emsp;&emsp;Cortex-R系列的内核接触不多，主要用于实时控制领域。我所知道的在Xilinx的MPSOC芯片中就使用了两颗R-5内核作为对A-9内核的实时增强。 &emsp;&emsp;Cortex-M处理器家族更多的集中在低性能端，但是这些处理器相比于许多微控制器使用的传统处理器性能仍然很强大。例如，Cortex-M4和Cortex-M7处理器应用在许多高性能的微控制器产品中，最大的时钟频率可以达到400Mhz。如我们最熟悉的Stm32就是基于Cortex-M系列处理器。","categories":[{"name":"日常知识","slug":"日常知识","permalink":"http://coderdock.com/categories/日常知识/"},{"name":"ARM","slug":"日常知识/ARM","permalink":"http://coderdock.com/categories/日常知识/ARM/"}],"tags":[{"name":"ARM","slug":"ARM","permalink":"http://coderdock.com/tags/ARM/"},{"name":"ARM架构","slug":"ARM架构","permalink":"http://coderdock.com/tags/ARM架构/"},{"name":"ARM系列","slug":"ARM系列","permalink":"http://coderdock.com/tags/ARM系列/"}]},{"title":"Hello CoderDock","slug":"Hello-CoderDock","date":"2016-10-26T14:28:13.000Z","updated":"2017-12-24T04:22:47.876Z","comments":true,"path":"2016/10/26/Hello-CoderDock/","link":"","permalink":"http://coderdock.com/2016/10/26/Hello-CoderDock/","excerpt":"","text":"Hi, I am Coder Dock!欢迎来到我的博客，我会在这里一点点记录自己成为一个技术大牛的历程（期待吧）。","categories":[{"name":"日常记录","slug":"日常记录","permalink":"http://coderdock.com/categories/日常记录/"}],"tags":[{"name":"日常","slug":"日常","permalink":"http://coderdock.com/tags/日常/"}]}]}
{"meta":{"title":"CoderDock","subtitle":"Try Hard to be a Better Programmer","description":"一直在努力的去做一个更好的程序员，为了父母、为了小鑫鑫，更为了自己","author":"Dock","url":"http://coderdock.com"},"pages":[{"title":"All categories","date":"2014-12-22T04:39:04.000Z","updated":"2017-11-25T11:06:09.429Z","comments":true,"path":"categories/index.html","permalink":"http://coderdock.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-11-25T10:55:56.000Z","updated":"2017-11-25T10:56:35.436Z","comments":true,"path":"tags/index.html","permalink":"http://coderdock.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"通信协议-SPI","slug":"通信协议-SPI","date":"2017-12-24T07:57:46.000Z","updated":"2017-12-24T07:57:46.931Z","comments":true,"path":"2017/12/24/通信协议-SPI/","link":"","permalink":"http://coderdock.com/2017/12/24/通信协议-SPI/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"通信协议-UART","slug":"通信协议-UART","date":"2017-12-24T07:57:25.000Z","updated":"2017-12-24T07:57:25.154Z","comments":true,"path":"2017/12/24/通信协议-UART/","link":"","permalink":"http://coderdock.com/2017/12/24/通信协议-UART/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"ARM指令之必知必会","slug":"ARM指令之必知必会","date":"2017-12-24T07:53:33.000Z","updated":"2017-12-24T07:53:33.640Z","comments":true,"path":"2017/12/24/ARM指令之必知必会/","link":"","permalink":"http://coderdock.com/2017/12/24/ARM指令之必知必会/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"我的Makefilee模板","slug":"我的Makefilee模板","date":"2017-12-24T07:52:42.000Z","updated":"2017-12-24T07:52:42.613Z","comments":true,"path":"2017/12/24/我的Makefilee模板/","link":"","permalink":"http://coderdock.com/2017/12/24/我的Makefilee模板/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"ViVado 找不到设备","slug":"ViVado-找不到设备","date":"2017-06-28T02:00:45.000Z","updated":"2017-12-24T04:23:03.774Z","comments":true,"path":"2017/06/28/ViVado-找不到设备/","link":"","permalink":"http://coderdock.com/2017/06/28/ViVado-找不到设备/","excerpt":"Vivado 在Linux上找不到设备是因为jtag驱动没安装， 情况如下：","text":"Vivado 在Linux上找不到设备是因为jtag驱动没安装， 情况如下：而在Linux上需要以下几条命令进行安装：12345sudo -scd /opt/Xilinx/Vivado/2017.1/data/xicom/cable_drivers/lin64/cp -a install_script/ /opt/cd /opt./install_script/install_drivers/install_drivers 官方回复见此处：1https://www.xilinx.com/support/answers/54381.html","categories":[{"name":"日常记录","slug":"日常记录","permalink":"http://coderdock.com/categories/日常记录/"}],"tags":[{"name":"Vivado","slug":"Vivado","permalink":"http://coderdock.com/tags/Vivado/"}]},{"title":"打造自己的VIM编辑器","slug":"Dock工具-打造自己的VIM编辑器","date":"2017-02-25T07:25:27.000Z","updated":"2017-12-24T04:23:16.245Z","comments":true,"path":"2017/02/25/Dock工具-打造自己的VIM编辑器/","link":"","permalink":"http://coderdock.com/2017/02/25/Dock工具-打造自己的VIM编辑器/","excerpt":"作为一个经常在Linux下开发的程序员，怎么能没有自己高逼格的VIM编辑器呢？在这片教程中会一步步的搭建起自己的高逼格VIM！","text":"作为一个经常在Linux下开发的程序员，怎么能没有自己高逼格的VIM编辑器呢？在这片教程中会一步步的搭建起自己的高逼格VIM！ 1. 主题&emsp;&emsp;刀客喜欢的主题有两个：molokai 、Solarized 1.1 molokai&emsp;&emsp;molokai的特点是色彩艳丽，设置为暗色背景很适合程序员开发。并且网上的教程都是使用Bundle进行安装，但刀客尝试后发现自己无法正常安装。还是一步步的从GIt进行安装更靠谱点。 git clone git@github.com:tomasr/molokai.git 将colors 文件夹的molokai.vim 拷贝到~/.vim/colors 在~/.vimrc中添加如下语句： 123colorscheme molokaiset t_Co=256set background=dark 噔噔噔噔！打开vim编辑器是不是变得很炫酷了？ 1.2 Solarized&emsp;&emsp;Solarized主题是使用最广泛的vim主题。但刀客还是更喜欢molokai一点。 git clone git@github.com/altercation/vim-colors-solarized 将colors 文件夹的molokai.vim 拷贝到~/.vim/colors 在~/.vimrc中添加如下语句： 123syntax enableset background=darkcolorscheme solarized 快快地打开你的vim编辑器看一下吧。 2. VIM 安装 作为一个程序员怎么能够不会使用源码这么高（苦）大（逼）的软件安装方式呢？好吧！是因为我要安装YCM(YouCompleteMe)代码自动不全工具需要Python的支持，但通过命令行安装的VIM一般不支持Python。 2.1 卸载VIM&emsp;&emsp;如果你的电脑上安装着vim,你需要完全卸载之前的VIM,方法很简单也很粗暴：12345sudo apt-get remove vimsudo apt-get remove vim-runtimesudo apt-get remove vim -tinysudo apt-get remove vim-commonsudo apt-get remove vim-docsudo apt-get remove vim-script 保证把vim卸载的渣渣都不剩。 2.2 安装&emsp;&emsp;先安装一下依赖吧，很简单,反正也不多：123sudo apt-get install libncurses5-dev libgnome2-dev libgnomeui-dev libgtk2.0-dev libatk1.0-dev libbonoboui2-dev libcairo2-dev libx11-dev libxpm-dev libxt-dev python-dev python3-dev ruby-dev liblua5.1-dev libperl-dev git &emsp;&emsp;然后下载vim,之后进行配置、编译、安装，三板斧嘛，开始：12345678910111213141516cd ~git clone https://github.com/vim/vim.gitcd vim./configure --with-features=huge \\ --enable-multibyte \\ --enable-rubyinterp=yes \\ --enable-pythoninterp=yes \\ --with-python-config-dir=/usr/lib/python2.7/config-x86_64-linux-gnu \\ --enable-python3interp=yes \\ --with-python3-config-dir=/usr/lib/python3.5/config-3.5m-x86_64_linux-gnu \\ --enable-perlinterp=yes \\ --enable-luainterp=yes \\ --enable-gui=gtk2 --enable-cscope --prefix=/usrmake VIMRUNTIMEDIR=/usr/share/vim/vim80cd ~/vimsudo make install 齐活！ 3.安装YCM&emsp;&emsp;VIM被称为编辑器之神，而YCM则是vim中最难装的插件，简直就是神的脚后跟。在网上搜索YCM的安装，基本都是使用Bundle安装，可是我试了好几次还是安装不上。算了还是苦逼地从源码安装吧。 &emsp;&emsp;经过刀客我的尝试，终于从源码安装上了YCM! 3.1 下载YCM&emsp;&emsp;首先将YCM从git下载到本地，我选了 ~/.vim/bundle/。因为之前通过Bundle安装没有成功，正好有这么一个文件夹，没有的自己见一个就是了。。。。 1234# 下载 （在 `～/.vim/bundle` 目录下）git clone --recursive git@github.com/Valloric/YouCompleteMe.git# 检查完整性（在 `～/.vim/bundle/YouCompleteMe` 目录下）git submodule update --init --recursive 这样就开始编译安装了是么？ NO No NO!,我们还需要安装依赖呢12#sudo apt-get install llvm-5.0 clang-5.0 libclang-5.0-dev libboost-all-dev 我统一选择了5.0版本，你要根据自己的软件源里的版本进行安装哦。 3.3 编译安装在家目录下新建一个安装目录，然后进行执行一下命令：12345mkdir ~/.ycm_buildcd ~/.ycm_buildcmake -G &quot;Unix Makefiles&quot; -DUSE_SYSTEM_BOOST=ON -DUSE_SYSTEM_LIBCLANG=ON . ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cppcmake -G &quot;Unix Makefiles&quot; -DUSE_SYSTEM_BOOST=ON -DEXTERNAL_LIBCLANG_PATH=/usr/lib/x86_64-linux-gnu/libclang-5.0.so . ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cppcmake --build . --target ycm_core --config Release 将配置文件拷贝到 ~/.vim1cp ~/.vim/bundle/YouCompleteMe/third_party/ycmd/examples/.ycm_extra_conf.py ~/.vim/ 最后在 ~/.vimrc中添加以下语句：12let g:ycm_server_python_interpreter=&apos;/usr/bin/python&apos;let g:ycm_global_ycm_extra_conf=&apos;~/.vim/.ycm_extra_conf.py&apos; 打开你的编辑器看一下吧！ 4.安装ctags和taglist&emsp;&emsp;众所周知，在Linux阅读大型源码是一件比较困难的事情，我们可以使用SourceInsigh或者UnderStand，但是总有一种被强奸的感觉，因为这样做不Linux啊。 &emsp;&emsp;总的来说，ctags负责将源码中的各个变量生成各个标签，我们可以随时查看调用位置。而taglist基于ctags提供了结构化浏览的功能，我们可以查看一个结构体中有哪些变量等等。 4.1 安装ctags使用命令行：1sudo apt-get install ctags 或者从github上下载源码后，使用三板斧：1./configure &amp;&amp; make &amp;&amp; make install 在.vimrc中添加1map &lt;C-F12&gt; :!ctags -R --c++-kinds=+p --fields=+iaS --extra=+q .&lt;CR&gt; 我们就可以进入代码根目录后，打开Vim，按下Ctrl-F12快捷键自动生成tags文件。命令执行完后，会在源代码目录生成tags文件。Vim默认会自动读取当前目录下的tags文件，所以不需要修改~/.vimrc文件。 此时，我们已经具有定义跳转的功能了。有两组快捷键是最常用的。12Ctrl-] 跳转到光标所在符号的定义。Ctrl-t 回到上次跳转前的位置。 更多功能通过命令man ctags或在Vim命令行下运行help ctags查询。 4.2 安装Taglist从下方网址下载talist包，解压打~/.vim，注意的是如果之前已经存在了doc或者plugin文件夹，我们只需要将对应文件放置到对应文件夹即可。 然后在 .vimrc中添加如下两句：12let Tlist_Show_One_File=1 let Tlist_Exit_OnlyWindow=1 5 安装NERDTree&emsp;&emsp;我们使用VIM进行大型源码编程的时候总是无法看到目录结构，这是一件比较苦恼的事情，那么我们就可以使用NERDTree来解决。方法很简单：1git clone https://github.com/scrooloose/nerdtree.git ~/ 然后将目录中的文件放置到对应的文件夹即可。进入 vims使用命令 NERDTreeToggle看看目录结构出来了没有。我们也可以在.vimrc中设置快捷键1map &lt;F6&gt; :NERDTreeToggle&lt;CR&gt; 这样就可以使用 F6打开或者关闭目录结构了。","categories":[{"name":"编程工具","slug":"编程工具","permalink":"http://coderdock.com/categories/编程工具/"}],"tags":[{"name":"编程工具","slug":"编程工具","permalink":"http://coderdock.com/tags/编程工具/"}]},{"title":"交叉编译之必知必会","slug":"交叉编译之必知必会","date":"2017-02-25T04:25:39.000Z","updated":"2017-12-24T07:59:54.566Z","comments":true,"path":"2017/02/25/交叉编译之必知必会/","link":"","permalink":"http://coderdock.com/2017/02/25/交叉编译之必知必会/","excerpt":"&emsp;&emsp;做嵌入式开发，最熟悉的莫过于交叉编译了。在这篇文章中，记录自己经常使用到的相关知识，以共查阅。","text":"&emsp;&emsp;做嵌入式开发，最熟悉的莫过于交叉编译了。在这篇文章中，记录自己经常使用到的相关知识，以共查阅。 1. 编译器&emsp;&emsp;嵌入式开发和桌面应用的一个很大不同就是：我们必须自己准备配置所需的工具环境。并不像Windows开发那样装一个VS就一切OK了，这其中最重要的就是编译器的准备。 在Ubuntu上我一般是使用sudo apt-get install arm-linux-gnu命令进行交叉编译工具的安装。但大多数时候这是行不通的。因为arm架构或者特定ARM芯片的特性（如是否支持浮点运算），导致后期使用时故障频出。 使用开发板提供商或芯片提供商提供的开发套件，这些往往对某些特性做了优化，是最能契合我们的芯片开发的一种方式。 去Linaro下载对应架构的编译程序，这些开发环境适用性很好，在没能找到官方提供的套件的时候，这是一个很好的选择。 &emsp;&emsp;当然，下载安装完成后需要将可执行文件的路径加到系统的 PATH路径中 2.交叉编译器选项2.1 编译步骤&emsp;&emsp;编译程序分为4个步骤： 1.预处理，生成预编译文件（.文件）： Gcc –E hello.c –o hello.i 2.编译，生成汇编代码（.s文件）： Gcc –S hello.i –o hello.s 3.汇编，生成目标文件（.o文件）： Gcc –c hello.s –o hello.o 4.链接，生成可执行文件： Gcc hello.o –o hello 记住这三个选项只要记住键盘左上角的按键 ESC即可，是不是很简单 2.2 警告选项&emsp;&emsp;在默认情况下，警告选项是默认不打开的，后来Dock在开发的实践过程中，返现使用-Wall选项可以事先发现很多简单错误，为后期免去很多麻烦： 判断语句 if(a = b) 缺少 default分支 类型不匹配对比int a = 0; long b = 2; if(a == b) 其他Dock还未遇到的 &emsp;&emsp;就是这三个简单的错误，曾经让Dock花费很多时间去调试。错误应该消灭在萌芽。 2.3 包含链接选项&emsp;&emsp;Gcc编译器默认是会自动寻找包含编译环境中的头文件和链接库，但是在使用自己的头文件和链接库时，需要自己手动指定。 -I[path-to-include_file] 使用 -I 指定头文件的路径 -L[path-to-lib] 使用-L 指定库文件的路径 -lxx.so 使用-l 选项指定要链接的库文件，默认 l代替lib文件，如链接libmath.so要使用 -lmath -nostartfiles 不链接启动文件，即暂时不链接main函数 -nostdlib 不链接标准库文件，在裸机程序中比较常用，如uboot中就会使用到这个选项，因为链接标准库的话，程序就会变得很大。 -static 静态链接，这样就不会使用动态库，但后边有时需要制定 libxx.a静态库文件，同时文件体积会变得很大 2.4 objcpy objdump&emsp;&emsp;虽然说能够编译出程序并且能够运行就已经够了，但是这两个程序使我们做嵌入式程序所不能忽视的。 2.4.1 ELF格式 ELF(Executable and Linking Format)是unix-like系统下的一种文件格式，它是一种对象文件的格式，用于定义不同类型的对象文件(Object files)中都放了什么东西、以及都以什么样的格式去放这些东西。即是在程序的头部加上了一段信息： 1234567891011121314151617181920ELF Header: Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 Data: 2&apos;s complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: EXEC (Executable file) Machine: Advanced Micro Devices X86-64 Version: 0x1 Entry point address: 0x42dfe0 Start of program headers: 64 (bytes into file) Start of section headers: 67460488 (bytes into file) Flags: 0x0 Size of this header: 64 (bytes) Size of program headers: 56 (bytes) Number of program headers: 8 Size of section headers: 64 (bytes) Number of section headers: 40 Section header string table index: 37 对应的结构体为：12345678910111213141516typedef struct&#123; unsigned char e_ident[EI_NIDENT]; /* 魔数和相关信息 */ Elf32_Half e_type; /* 目标文件类型 */ Elf32_Half e_machine; /* 硬件体系 */ Elf32_Word e_version; /* 目标文件版本 */ Elf32_Addr e_entry; /* 程序进入点 */ Elf32_Off e_phoff; /* 程序头部偏移量 */ Elf32_Off e_shoff; /* 节头部偏移量 */ Elf32_Word e_flags; /* 处理器特定标志 */ Elf32_Half e_ehsize; /* ELF头部长度 */ Elf32_Half e_phentsize; /* 程序头部中一个条目的长度 */ Elf32_Half e_phnum; /* 程序头部条目个数 */ Elf32_Half e_shentsize; /* 节头部中一个条目的长度 */ Elf32_Half e_shnum; /* 节头部条目个数 */ Elf32_Half e_shstrndx; &emsp;&emsp;但是在uboot等环境中，是无法识别这些信息的。裸机程序总是从头一条一条指令的进行执行。所以在有些情况下我们需要去掉这些信息。那就用到了objcopy命令： objcopy用于将object的部分获全部内容拷贝到另一个object，从而可以实现格式的变换。 如 arm-linux-gnu-objcopy -O binary boot.elf boot.bin就常用来将elf转换为RAW格式，从而在裸机上运行。 2.4.2 objdump&emsp;&emsp;objdumpb即是常用的反汇编程序，Dock常用的两条命令为： arm--linux-objdump -d boot.elf将 elf反汇编 arm--linux-objdump -d -b binary -m arm boot.bin 将 bin反汇编","categories":[{"name":"日常知识","slug":"日常知识","permalink":"http://coderdock.com/categories/日常知识/"}],"tags":[{"name":"交叉编译, arm-linux","slug":"交叉编译-arm-linux","permalink":"http://coderdock.com/tags/交叉编译-arm-linux/"}]},{"title":"ARM要分清","slug":"ARM要分清","date":"2016-12-24T03:06:52.000Z","updated":"2017-12-24T04:21:16.985Z","comments":true,"path":"2016/12/24/ARM要分清/","link":"","permalink":"http://coderdock.com/2016/12/24/ARM要分清/","excerpt":"&emsp;&emsp;总是有人在说，我是搞ARM的，到底是说的ARM架构还是ARM系列，这点要搞清楚！","text":"&emsp;&emsp;总是有人在说，我是搞ARM的，到底是说的ARM架构还是ARM系列，这点要搞清楚！&emsp;&emsp;在Dock看来，ARM有两个概念，ARM架构、ARM系列,不同的架构，不同的系列在性能、功耗、尤其是价格方面有着很大的不同。 1. ARM公司&emsp;&emsp;ARM(Advanced RISC Machine)公司作为半导体行业最为著名的公司，你不能不知道。详情看度娘ARM。下面我们重点说架构和系列两个概念。 2. ARM架构&emsp;&emsp;ARM架构指的就是这颗芯片内核所用的指令集的版本。C++语言还有C++10、C++11版本之说，更何况内核呢？ &emsp;&emsp;最为显著的就是总线宽度。”Thumb指令集”为16位，”ARM指令集”为32位,以及”ISA指令集”为64位。这也就从根本上区分了每一个ARM内核有所不同。当然ARM还有很多很多不同的拓展功能，如Java加速器-Jazelle、TrustZone技术、SIMD等，这些不同的组合就组成了不同的ARM架构。 2.1 ARMv4 ARMv5 ARMv6 ARMv7&emsp;&emsp;这是市面上最老的ARM架构版本了。只支持32位地址空间，ARM7系列的一些芯片用到了这个指令集。 &emsp;&emsp;ARMv5相较于v4架构增加了DSP指令优化。 &emsp;&emsp;ARMv6 在存储系统、异常处理等方面做了很多改进，最为重要的是增加了对多媒体处理的支持。 &emsp;&emsp;ARMv7增加了NEON GPU多媒体处理支持，将DSP和媒体处理能力提高了近四倍，并且支持改良的浮点运算。满足下一代3D图形应用的需求，也就是从v7开始，ARMv7架构的处理器芯片开始应用于智能终端设备。 2.2 ARMv8&emsp;&emsp;2011年11月，ARM公司发布了新一代处理器架构ARMv8的部分技术细节。这是ARM公司的首款支持64位指令集的处理器架构。但其支持AArch32 AArch64两套指令集，为的就是向前兼容32位的应用。 2.3 拓展&emsp;&emsp;有时候我们又能看到ARMv5TEJ等词汇，这又是什么意思，后面的每一个字母代表一种拓展功能。如 T-Thumb指令集、E-增强型DSP指令 J-Java加速器。 3. ARM系列&emsp;&emsp;在相同的指令集下，搭配不同的部件就可以组成不同的功能的处理器。比如有无内存管理，有无调试功能等。 3.1 ARM7-11&emsp;&emsp;ARM7 - ARM11是比较老的一些处理器器了。其主要的分别大致如下： ARM7是低功耗的32位处理器，主要特点是没有MMU(内存管理)，如果有人给你说他用ARM7跑系统，你就可以呵呵了。 相较于ARM7,增加了MMU和Cache,指令集执行效率相比于ARM7有很大提高，最高可达300MIPS。 ARM11,基于ARMv6指令集架构，在实时性和浮点处理方面有很大提高。 3.2 ARM-Cortex&emsp;&emsp;在ARM11以后，ARM就不再以数字进行ARM处理器系列进行区分，而是使用Cortex进行命名。主要区分为一下三个系列： Cortex-A 和 Cortex-A50 系列 - 面向开放式操作系统的高性能处理器。 Cortex-R 系列- 面向实时应用的卓越性能。 Cortex-M 系列 - 面向具有确定性的微控制器应用的成本功耗敏感型解决方案。 &emsp;&emsp;ARM Cortex-A 内核基于ARMv7-A架构，基本上都可以支持ARM、Thumb-2、Thumb指令集、Java加速扩展的Jazelle技术、ThustZone的安全扩展、针对浮点FPU的VFP硬件扩展、DSP &amp; SIMD 扩展、并行多数据SIMD的NEON多媒体处理器扩展、主流的嵌入式OS（Linux、Android、Windows Mobile、Windows Phone、Symbian）、以及支持分支预测branch prediction。但各处理器在VFP/NEON的类型、半精度浮点（16-bit half precision floating-point）的支持、多核MPCore、流水线pipeline、单MHz处理性能、L1/L2 cache控制器、乱序执行、指令dual-issue并发等方面有略有不同。 &emsp;&emsp;Cortex-R系列的内核接触不多，主要用于实时控制领域。我所知道的在Xilinx的MPSOC芯片中就使用了两颗R-5内核作为对A-9内核的实时增强。 &emsp;&emsp;Cortex-M处理器家族更多的集中在低性能端，但是这些处理器相比于许多微控制器使用的传统处理器性能仍然很强大。例如，Cortex-M4和Cortex-M7处理器应用在许多高性能的微控制器产品中，最大的时钟频率可以达到400Mhz。如我们最熟悉的Stm32就是基于Cortex-M系列处理器。","categories":[{"name":"日常知识","slug":"日常知识","permalink":"http://coderdock.com/categories/日常知识/"}],"tags":[{"name":"ARM, ARM架构,ARM系列","slug":"ARM-ARM架构-ARM系列","permalink":"http://coderdock.com/tags/ARM-ARM架构-ARM系列/"}]},{"title":"Hello CoderDock","slug":"Hello-CoderDock","date":"2016-10-26T14:28:13.000Z","updated":"2017-12-24T04:22:47.876Z","comments":true,"path":"2016/10/26/Hello-CoderDock/","link":"","permalink":"http://coderdock.com/2016/10/26/Hello-CoderDock/","excerpt":"","text":"Hi, I am Coder Dock!欢迎来到我的博客，我会在这里一点点记录自己成为一个技术大牛的历程（期待吧）。","categories":[{"name":"日常记录","slug":"日常记录","permalink":"http://coderdock.com/categories/日常记录/"}],"tags":[{"name":"日常","slug":"日常","permalink":"http://coderdock.com/tags/日常/"}]}]}
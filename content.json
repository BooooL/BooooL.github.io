{"meta":{"title":"CoderDock","subtitle":"Try Hard to be a Better Programmer","description":"一直在努力的去做一个更好的程序员，为了父母、为了小鑫鑫，更为了自己","author":"Dock","url":"http://coderdock.com"},"pages":[{"title":"All categories","date":"2014-12-22T04:39:04.000Z","updated":"2017-11-25T11:06:09.429Z","comments":true,"path":"categories/index.html","permalink":"http://coderdock.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-11-25T10:55:56.000Z","updated":"2017-11-25T10:56:35.436Z","comments":true,"path":"tags/index.html","permalink":"http://coderdock.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"USB系列-2-DNW源码","slug":"USB/USB系列-2-DNW源码","date":"2017-08-17T07:42:47.000Z","updated":"2018-01-07T07:44:51.239Z","comments":true,"path":"2017/08/17/USB/USB系列-2-DNW源码/","link":"","permalink":"http://coderdock.com/2017/08/17/USB/USB系列-2-DNW源码/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207#include &lt;linux/kernel.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/usb.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/mutex.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/uaccess.h&gt;#define SECBULK_MAJOR 102#define SECBULK_MINOR 0#define DRIVER_NAME &quot;secbulk&quot;#define BULKOUT_BUFFER_SIZE 512struct secbulk_dev&#123; struct usb_device *udev; struct mutex io_mutex; char* bulkout_buffer; __u8 bulk_out_endpointAddr;&#125;;static struct usb_class_driver secbulk_class;static struct usb_device_id secbulk_table[]= &#123; &#123; USB_DEVICE(0x04e8, 0x1234)&#125;, //c &#123; &#125;&#125;;static struct usb_driver secbulk_driver;static void secbulk_disconnect(struct usb_interface *interface)&#123; struct secbulk_dev *dev = NULL; printk(KERN_INFO &quot;secbulk:secbulk disconnected!\\n&quot;); dev = usb_get_intfdata(interface); if( NULL != dev ) kfree(dev); usb_deregister_dev(interface, &amp;secbulk_class); return;&#125;static ssize_t secbulk_read(struct file *file, char __user *buf, size_t len, loff_t *loff)&#123; return -EPERM;&#125;static ssize_t secbulk_write(struct file *file, const char __user *buf, size_t len, loff_t *loff)&#123; size_t to_write; struct secbulk_dev *dev = file-&gt;private_data; int ret; int actual_length; size_t total_writed; total_writed = 0; while(len &gt; 0) &#123; to_write = min(len, BULKOUT_BUFFER_SIZE); if(copy_from_user(dev-&gt;bulkout_buffer, buf+total_writed, to_write)) //得到用户空间数据 &#123; printk(KERN_ERR &quot;secbulk:copy_from_user failed!\\n&quot;); return -EFAULT; &#125; ret = usb_bulk_msg(dev-&gt;udev, usb_sndbulkpipe(dev-&gt;udev, dev-&gt;bulk_out_endpointAddr), //构造批量传输信息，传输给usbCore处理 dev-&gt;bulkout_buffer, to_write, &amp;actual_length, 3*HZ); if(ret || actual_length!=to_write) &#123; printk(KERN_ERR &quot;secbulk:usb_bulk_msg failed!\\n&quot;); return -EFAULT; &#125; len -= to_write; total_writed += to_write; &#125; return total_writed;&#125;static int secbulk_open(struct inode *node, struct file *file)&#123; struct usb_interface *interface; struct secbulk_dev *dev; interface = usb_find_interface(&amp;secbulk_driver, iminor(node)); if(!interface) return -ENODEV; dev = usb_get_intfdata(interface); dev-&gt;bulkout_buffer = kzalloc(BULKOUT_BUFFER_SIZE, GFP_KERNEL); if(!(dev-&gt;bulkout_buffer)) return -ENOMEM; if(!mutex_trylock(&amp;dev-&gt;io_mutex)) return -EBUSY; file-&gt;private_data = dev; return 0;&#125;static int secbulk_release(struct inode *node, struct file *file)&#123; struct secbulk_dev *dev; dev = (struct secbulk_dev*)(file-&gt;private_data); kfree(dev-&gt;bulkout_buffer); mutex_unlock(&amp;dev-&gt;io_mutex); return 0;&#125;static struct file_operations secbulk_fops = &#123; .owner = THIS_MODULE, .read = secbulk_read, .write = secbulk_write, .open = secbulk_open, .release= secbulk_release,&#125;;static struct usb_class_driver secbulk_class = &#123; .name = &quot;secbulk%d&quot;, .fops = &amp;secbulk_fops, .minor_base= 100,&#125;;static int secbulk_probe(struct usb_interface *interface, const struct usb_device_id *id)&#123; int ret; struct secbulk_dev *dev; struct usb_host_interface *iface_desc; struct usb_endpoint_descriptor *endpoint; int i; printk(KERN_INFO &quot;secbulk:secbulk probing...\\n&quot;); dev = kzalloc(sizeof(*dev), GFP_KERNEL); //分配一个指针空间，只是为了索引内核的空间 if(!dev) &#123; ret = -ENOMEM; goto error; &#125; iface_desc = interface-&gt;cur_altsetting; for(i=0; i &lt; iface_desc-&gt;desc.bNumEndpoints; i++) //从USBCore传入的借口中得到得到输出端点 &#123; endpoint = &amp;(iface_desc-&gt;endpoint[i].desc); if(!dev-&gt;bulk_out_endpointAddr &amp;&amp; usb_endpoint_is_bulk_out(endpoint)) &#123; printk(KERN_INFO &quot;secbulk:bulk out endpoint found!\\n&quot;); dev-&gt;bulk_out_endpointAddr = endpoint-&gt;bEndpointAddress; break; &#125; &#125; if(!(dev-&gt;bulk_out_endpointAddr)) &#123; ret = -EBUSY; goto error; &#125; ret = usb_register_dev(interface, &amp;secbulk_class); //将usb驱动注册成字符设备驱动提供给用户程序 if(ret) &#123; printk(KERN_ERR &quot;secbulk: usb_register_dev failed!\\n&quot;); return ret; &#125; dev-&gt;udev = usb_get_dev(interface_to_usbdev(interface)); usb_set_intfdata(interface, dev); mutex_init(&amp;dev-&gt;io_mutex); return 0;error: if(!dev) kfree(dev); return ret;&#125;static struct usb_driver secbulk_driver= &#123; .name= &quot;secbulk&quot;, .probe= secbulk_probe, .disconnect= secbulk_disconnect, .id_table= secbulk_table, .supports_autosuspend=0,&#125;;static int __init secbulk_init(void)&#123; int result; printk(KERN_INFO &quot;secbulk:secbulk loaded\\n&quot;); result = usb_register(&amp;secbulk_driver); //1 注册 secbulk_driver, 此处我们就注册了usb_driver，当插入USB后， //会调用add_dev,然后将ID号与驱动支持的id进行对比，如果对比通过，就会调用probe if(result) &#123; printk(KERN_ERR &quot;secbulk:usb_register failed: %d&quot;, result); return result; &#125; return 0;&#125;static void __exit secbulk_exit(void)&#123; usb_deregister(&amp;secbulk_driver); printk(KERN_INFO &quot;secbulk:secbulk unloaded\\n&quot;);&#125;module_init(secbulk_init);module_exit(secbulk_exit);MODULE_LICENSE(&quot;GPL&quot;);","categories":[{"name":"USB系列","slug":"USB系列","permalink":"http://coderdock.com/categories/USB系列/"}],"tags":[{"name":"UBS","slug":"UBS","permalink":"http://coderdock.com/tags/UBS/"},{"name":"DNW","slug":"DNW","permalink":"http://coderdock.com/tags/DNW/"}]},{"title":"USB系列--1-基本结构体","slug":"USB/USB系列-1-基本结构体","date":"2017-08-09T01:09:53.000Z","updated":"2018-01-07T06:51:50.522Z","comments":true,"path":"2017/08/09/USB/USB系列-1-基本结构体/","link":"","permalink":"http://coderdock.com/2017/08/09/USB/USB系列-1-基本结构体/","excerpt":"","text":"1.USB设备结构体usb_device位于/linux/include/usb.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147/** * struct usb_device - kernel&apos;s representation of a USB device * @devnum: device number; address on a USB bus * @devpath: device ID string for use in messages (e.g., /port/...) * @route: tree topology hex string for use with xHCI * @state: device state: configured, not attached, etc. * @speed: device speed: high/full/low (or error) * @tt: Transaction Translator info; used with low/full speed dev, highspeed hub * @ttport: device port on that tt hub * @toggle: one bit for each endpoint, with ([0] = IN, [1] = OUT) endpoints * @parent: our hub, unless we&apos;re the root * @bus: bus we&apos;re part of * @ep0: endpoint 0 data (default control pipe) * @dev: generic device interface * @descriptor: USB device descriptor * @bos: USB device BOS descriptor set * @config: all of the device&apos;s configs * @actconfig: the active configuration * @ep_in: array of IN endpoints * @ep_out: array of OUT endpoints * @rawdescriptors: raw descriptors for each config * @bus_mA: Current available from the bus * @portnum: parent port number (origin 1) * @level: number of USB hub ancestors * @can_submit: URBs may be submitted * @persist_enabled: USB_PERSIST enabled for this device * @have_langid: whether string_langid is valid * @authorized: policy has said we can use it; * (user space) policy determines if we authorize this device to be * used or not. By default, wired USB devices are authorized. * WUSB devices are not, until we authorize them from user space. * FIXME -- complete doc * @authenticated: Crypto authentication passed * @wusb: device is Wireless USB * @lpm_capable: device supports LPM * @usb2_hw_lpm_capable: device can perform USB2 hardware LPM * @usb2_hw_lpm_besl_capable: device can perform USB2 hardware BESL LPM * @usb2_hw_lpm_enabled: USB2 hardware LPM is enabled * @usb2_hw_lpm_allowed: Userspace allows USB 2.0 LPM to be enabled * @usb3_lpm_u1_enabled: USB3 hardware U1 LPM enabled * @usb3_lpm_u2_enabled: USB3 hardware U2 LPM enabled * @string_langid: language ID for strings * @product: iProduct string, if present (static) * @manufacturer: iManufacturer string, if present (static) * @serial: iSerialNumber string, if present (static) * @filelist: usbfs files that are open to this device * @maxchild: number of ports if hub * @quirks: quirks of the whole device * @urbnum: number of URBs submitted for the whole device * @active_duration: total time device is not suspended * @connect_time: time device was first connected * @do_remote_wakeup: remote wakeup should be enabled * @reset_resume: needs reset instead of resume * @port_is_suspended: the upstream port is suspended (L2 or U3) * @wusb_dev: if this is a Wireless USB device, link to the WUSB * specific data for the device. * @slot_id: Slot ID assigned by xHCI * @removable: Device can be physically removed from this port * @l1_params: best effor service latency for USB2 L1 LPM state, and L1 timeout. * @u1_params: exit latencies for USB3 U1 LPM state, and hub-initiated timeout. * @u2_params: exit latencies for USB3 U2 LPM state, and hub-initiated timeout. * @lpm_disable_count: Ref count used by usb_disable_lpm() and usb_enable_lpm() * to keep track of the number of functions that require USB 3.0 Link Power * Management to be disabled for this usb_device. This count should only * be manipulated by those functions, with the bandwidth_mutex is held. * * Notes: * Usbcore drivers should not set usbdev-&gt;state directly. Instead use * usb_set_device_state(). */struct usb_device &#123; int devnum; //设备号，还记得上一篇USB命名&quot;设备号-端口号：配置.接口&quot;命名方式，每插入一个新设备，USBCore会为其设置一个设备号 char devpath[16]; //该设备在SysFS中的路径，一般为&quot;/sys/devices/pci0000:00/0000:00:12.2/_usb_1&quot; u32 route; enum usb_device_state state; //该设备的状态，如刚插上时为Attached enum usb_device_speed speed; //速度级别 high full low struct usb_tt *tt; //我们知道高速USB之前还存在全速和低速USB,那么高速USB设备怎么兼容其他 int ttport; //低速设备，通过使用TT(Transaction Translator)--高速USB中的转换电路 unsigned int toggle[2]; //对于中断传输、批量传输、和控制传输，传输数据时，需要DATA0和DATA1交 //替进行，toggle就是标识0端点的IN 和 OUT的DATAx的状态 struct usb_device *parent; //父hub,如果是roothub，就是NULL struct usb_bus *bus; //设备所在的总线 struct usb_host_endpoint ep0; //端点0被特殊对待，在结构体中静态存在 struct device dev; //嵌入到usb_device中的device struct usb_device_descriptor descriptor; //设备描述符，描述该设备信息，后面会分析 struct usb_host_bos *bos; struct usb_host_config *config; //所有的配置信息列表 struct usb_host_config *actconfig; //当前活跃的信息 struct usb_host_endpoint *ep_in[16]; //该设备的输入端点 struct usb_host_endpoint *ep_out[16]; //输出端点 char **rawdescriptors; unsigned short bus_mA; //能够从总线得到的电流值 u8 portnum; u8 level; unsigned can_submit:1; unsigned persist_enabled:1; unsigned have_langid:1; unsigned authorized:1; unsigned authenticated:1; unsigned wusb:1; unsigned lpm_capable:1; unsigned usb2_hw_lpm_capable:1; unsigned usb2_hw_lpm_besl_capable:1; unsigned usb2_hw_lpm_enabled:1; unsigned usb2_hw_lpm_allowed:1; unsigned usb3_lpm_u1_enabled:1; unsigned usb3_lpm_u2_enabled:1; int string_langid; /* static strings from the device */ char *product; char *manufacturer; char *serial; struct list_head filelist; int maxchild; u32 quirks; atomic_t urbnum; unsigned long active_duration;#ifdef CONFIG_PM unsigned long connect_time; unsigned do_remote_wakeup:1; unsigned reset_resume:1; unsigned port_is_suspended:1;#endif struct wusb_dev *wusb_dev; int slot_id; enum usb_device_removable removable; struct usb2_lpm_parameters l1_params; struct usb3_lpm_parameters u1_params; struct usb3_lpm_parameters u2_params; unsigned lpm_disable_count;&#125;;#define to_usb_device(d) container_of(d, struct usb_device, dev) 2 USB设备描述符结构体usb_device_descriptor位于``123456789101112131415161718/* USB_DT_DEVICE: Device descriptor */struct usb_device_descriptor &#123; __u8 bLength; //该设备描述符的长度 __u8 bDescriptorType; // USB_DT_DEVICE = 0x01 __le16 bcdUSB; //版本号 __u8 bDeviceClass; // __u8 bDeviceSubClass; __u8 bDeviceProtocol; __u8 bMaxPacketSize0; //端点0一次可以处理的最大字节数 __le16 idVendor; //厂商号 __le16 idProduct; //产品号 __le16 bcdDevice; //版本号 __u8 iManufacturer; //分别对应上面的索引值 index __u8 iProduct; __u8 iSerialNumber; __u8 bNumConfigurations; //设备在当前速度级别下支持的配置数量&#125; __attribute__ ((packed));","categories":[{"name":"USB系列","slug":"USB系列","permalink":"http://coderdock.com/categories/USB系列/"}],"tags":[{"name":"USB","slug":"USB","permalink":"http://coderdock.com/tags/USB/"},{"name":"基本结构体","slug":"基本结构体","permalink":"http://coderdock.com/tags/基本结构体/"}]},{"title":"USB系列-0-基础概念","slug":"USB/USB系列-0-基础概念","date":"2017-08-06T01:09:14.000Z","updated":"2018-01-07T06:59:30.799Z","comments":true,"path":"2017/08/06/USB/USB系列-0-基础概念/","link":"","permalink":"http://coderdock.com/2017/08/06/USB/USB系列-0-基础概念/","excerpt":"12345678_______ ______|\\ /|( ____ \\( ___ \\| ) ( || ( \\/| ( ) )| | | || (_____ | (__/ /| | | |(_____ )| __ (| | | | ) || ( \\ \\| (___) |/\\____) || )___) )(_______)\\_______)|/ \\___/","text":"12345678_______ ______|\\ /|( ____ \\( ___ \\| ) ( || ( \\/| ( ) )| | | || (_____ | (__/ /| | | |(_____ )| __ (| | | | ) || ( \\ \\| (___) |/\\____) || )___) )(_______)\\_______)|/ \\___/ 1.USB特性 不同设备类型，统一接口 支持热插拔 灵活的供电方式 多级速率支持 2.分类 OHCI主要为非PC系统上以及带有SiShe ALi芯片组的PC主板上的USB芯片 UHCI大多为Intel和Via主板上的USB控制器芯片。UHCI的硬件电路比OHCI简单，成本第，但驱动复杂。但他们都是由USB1.1规格的。 EHCI是有Intel等几个厂商研发，兼容OHCI UHCI 遵循USB2.0规范 3.层次1234设备 ：设备即我们所理解的设备，如一个键盘是一个设备，一个U盘是一个设备配置 ：配置是功能的集合，如一个USB耳麦能录音和播放，那么就可以存在三种配置接口 ：如上，就分为录音接口，播放接口端点 ：比如播放接口会存在两个端点，一个是左声道，一个是右声道 端点是通信的基本单位，并且方向是确定的 管道代表着端点与端点之间通信的能力4.传输单位*事务：事务一般由令牌包、数据包（可选）、握手包组成。 令牌包：用来启动一个事务，总是由主机发送。 数据包：可以从主机到设备，也可以由设备到主机，方向由令牌包决定。 握手包：通常情况，数据的接收者发送握手包（ACK或者NAK）。 事务一般由令牌包、数据包（可选）、握手包组成。 USB协议规定了四种传输类型：控制传输、批量传输、同步传输、中断传输 控制传输：控制传输事负责向USB设置一些控制信息，传送这种事务的管道是控制管道。控制管道在USB设备中是必须的。控制传送也分为三个阶段，即令牌阶段、数据传送阶段、握手阶段。 中断传输：中断事物的数据量很小，一般用于通知Host某个事件的来临，例如USB鼠标，鼠标移动或者鼠标单击等操作都会通过中断管道来向Host传送事件。也分3个阶段，令牌阶段、数据传输阶段、握手阶段。 同步传输：这是种能保证传输的同步性的事务。如在USB摄像头中传输视频数据的时候会采用这种事务，这种事务能保证每秒有固定的传输量，与Bulk传输不同的是他允许有一定的误码率。同步传输事务只有两个阶段，令牌阶段、数据阶段，因为不关心数据的正确性，所以没有握手阶段。 批量传输：用来传输大量数据，确保没有数据丢失，但不保证在特定时间内完场，U盘使用的就是批量传输。5.命名 sysfs USB命名 2-1:1.0 设备-端口：配置.接口 第二个设备的第一个端口，使用配置0 的接口1 6.驱动架构USB Core USB Core提供一些核心算法，为别的设备驱动程序提供服务，提供一个用于访问和控制USB硬件的接口，而不用考虑系统当前是那种主机控制器， USB Core、USB主机控制器 USB设备驱动三者的关系如下：123456789Block层 ： Net层 ： Char层 ： ---------------------------------- USB设备驱动程序------------------------------- USB Core------------------------------- USB主机控制器(HCD)------------------------------- 硬件 HCD提供主机控制器硬件的抽象，隐藏硬件的细节，HCD只对 USB Core负责。这也就意味着我们写USB驱动，是在调用USB Core接口的基础上进行的。 我们接下来的源码分析就从HCD开始。","categories":[{"name":"USB系列","slug":"USB系列","permalink":"http://coderdock.com/categories/USB系列/"}],"tags":[{"name":"基础概念","slug":"基础概念","permalink":"http://coderdock.com/tags/基础概念/"},{"name":"USB","slug":"USB","permalink":"http://coderdock.com/tags/USB/"}]},{"title":"图像处理基础","slug":"ImagePro/图像处理基础","date":"2017-08-01T06:27:05.000Z","updated":"2018-01-07T05:46:23.836Z","comments":true,"path":"2017/08/01/ImagePro/图像处理基础/","link":"","permalink":"http://coderdock.com/2017/08/01/ImagePro/图像处理基础/","excerpt":"","text":"1.图像处理流程 图像采集，这是进行图像处理的第一步。其中采样频率直接影响到采集图像的质量。 图像量化，是将采集到的数据进行量化处理，如一个像素点是使用MONO还是RGB进行表征。 图像处理, 得到图像后，需要尽快的进行处理，现在进行的图像处理主要有以下几点： 图像变换，有时进行较大图像处理时，会耗费很大的资源，那么往往采取将空间域的图像转换到转换域进行处理，不仅可以减少计算量，而且能够得到更有效的处理。（傅里叶变换、沃尔什变换、离散余弦变换） 图像编码压缩，目的是在尽量不失真的情况下减少图像的体积。常用的压缩 图像增强和复原，其目的是为了提高图像的质量，例如去除噪声、提高清晰度 图像分割，图像分割是将图像中有意义的部分提取出来，如提取边缘、区域等，这是进一步进行图像识别、分析和理解的基础。2.图像处理算法2.1傅里叶转换任何周期函数，都可以看作是不同振幅，不同相位正弦波的叠加。 &lt;/&gt; 连续傅里叶转换 连续傅里叶逆转换 2.2卷积卷积（Convolution）是一个常用的图像处理技术，可以改变像素强度，从而影响周围其他像素的强度。卷积的常用技术是创建滤镜，使用卷积技术，你可以获取一些流行的图像效果，比如模糊（blur）、锐化（sharpen）及边缘检测（edge detection），这些效果在Photo Booth、iPhoto和Aperture都有广泛使用。","categories":[{"name":"图像处理","slug":"图像处理","permalink":"http://coderdock.com/categories/图像处理/"}],"tags":[{"name":"图像处理","slug":"图像处理","permalink":"http://coderdock.com/tags/图像处理/"},{"name":"基础概念","slug":"基础概念","permalink":"http://coderdock.com/tags/基础概念/"}]},{"title":"ViVado 找不到设备","slug":"Zynq/ViVado-找不到设备","date":"2017-07-28T02:00:45.000Z","updated":"2018-01-03T00:06:51.986Z","comments":true,"path":"2017/07/28/Zynq/ViVado-找不到设备/","link":"","permalink":"http://coderdock.com/2017/07/28/Zynq/ViVado-找不到设备/","excerpt":"Vivado 在Linux上找不到设备是因为jtag驱动没安装， 情况如下：","text":"Vivado 在Linux上找不到设备是因为jtag驱动没安装， 情况如下：而在Linux上需要以下几条命令进行安装：12345sudo -scd /opt/Xilinx/Vivado/2017.1/data/xicom/cable_drivers/lin64/cp -a install_script/ /opt/cd /opt./install_script/install_drivers/install_drivers 官方回复见此处：1https://www.xilinx.com/support/answers/54381.html","categories":[{"name":"日常记录","slug":"日常记录","permalink":"http://coderdock.com/categories/日常记录/"},{"name":"工具","slug":"日常记录/工具","permalink":"http://coderdock.com/categories/日常记录/工具/"}],"tags":[{"name":"Vivado","slug":"Vivado","permalink":"http://coderdock.com/tags/Vivado/"}]},{"title":"Sysfs之我见","slug":"LinuxSource/Sysfs之我见","date":"2017-07-04T05:00:00.000Z","updated":"2018-01-03T00:10:03.485Z","comments":true,"path":"2017/07/04/LinuxSource/Sysfs之我见/","link":"","permalink":"http://coderdock.com/2017/07/04/LinuxSource/Sysfs之我见/","excerpt":"sysfs虚拟文件系统提供了一种比proc更理想的访问内核数据的途径。12345678_______ _______ _______ _______( ____ \\|\\ /|( ____ \\( ____ \\( ____ \\| ( \\/( \\ / )| ( \\/| ( \\/| ( \\/| (_____ \\ (_) / | (_____ | (__ | (_____(_____ ) \\ / (_____ )| __) (_____ ) ) | ) ( ) || ( ) |/\\____) | | | /\\____) || ) /\\____) |\\_______) \\_/ \\_______)|/ \\_______)","text":"sysfs虚拟文件系统提供了一种比proc更理想的访问内核数据的途径。12345678_______ _______ _______ _______( ____ \\|\\ /|( ____ \\( ____ \\( ____ \\| ( \\/( \\ / )| ( \\/| ( \\/| ( \\/| (_____ \\ (_) / | (_____ | (__ | (_____(_____ ) \\ / (_____ )| __) (_____ ) ) | ) ( ) || ( ) |/\\____) | | | /\\____) || ) /\\____) |\\_______) \\_/ \\_______)|/ \\_______) 1.sysfs的目录结构sysfs总是挂载在/sys文件夹上。在/sys目录下一般有block、bus、class、dev、devices、firmware、fs、kernel、module、power等目录。 /sys/devices: 这是内核对系统中所有设备的分层次表达模型，也是 /sys 文件系统管理设备的最重要的目录结构。 /sys/dev: 这个目录下维护一个按字符设备和块设备的主次号码(major:minor)链接到真实的设备(/sys/devices下)的符号链接文件。 /sys/bus: 这是内核设备按总线类型分层放置的目录结构， devices 中的所有设备都是连接于某种总线之下，在这里的每一种具体总线之下可以找到每一个具体设备的符号链接，它也是构成 Linux 统一设备模型的一部分。 /sys/class:这是按照设备功能分类的设备模型，如系统所有输入设备都会出现在 /sys/class/input 之下，而不论它们是以何种总线连接到系统。 /sys/block: 这里是系统中当前所有的块设备,具体链接到devices下的具体设备。 /sys/firmware:这里是系统加载固件机制的对用户空间的接口,如设备树的各个分层都位于这个文件夹下。 /sys/fs:这里按照设计是用于描述系统中所有文件系统，包括文件系统本身和按文件系统分类存放的已挂载点。如当前的Linux系统中存在ext4文件系统，该目录下就会存在ext4目录。 /sys/kernel:这里是内核所有可调整参数的位置，目前只有 uevent_helper, kexec_loaded, mm, 和新式的 slab 分配器等几项较新的设计在使用它，其它内核可调整参数仍然位于 sysctl (/proc/sys/kernel) 接口中。 /sys/module: 这里有系统中所有模块的信息，不论这些模块是以内联(inlined)方式编译到内核映像文件(vmlinuz)中还是编译为外部模块(ko文件)，都可能会出现在 /sys/module 中。 /sys/power: 这里是系统中电源选项，这个目录下有几个属性文件可以用于控制整个机器的电源状态，如可以向其中写入控制命令让机器关机、重启等。 2.udev使用2.1 udev工作过程:&emsp;&emsp;当内核检测到在系统中出现了新设备后（产生hotplug事件），内核会在sysfs文件系统中为该新设备生成一项新的记录，一般sysfs文件系统会被mount到/sys目录中。新记录是以一个或多个文件或目录的方式来表示。每个文件都包含有特定的信息。udev在系统中是以守护进程的方式udevd在运行。检测到新设备的出现，通过查找设备对应的sysfs中的记录得到设备的一些信息。udev会根据/etc/udev/udev.conf文件中的udev_rules指定的目录，逐个检查该目录下的文件，这个目录下的文件都是针对某类或某个设备应该施行什么措施的规则文件。udev读取文件是按照文件名的ASCII字母顺序来读取的，如果udev一旦找到了与新加入的设备匹配的规则，udev就会根据规则定义的措施对新设备进行配置。同时不再读后续的规则文件。 2.2 udev规则2.2.1 规则的所有操作符 “==”： 比较键、值，若等于，则该条件满足； “!=”： 比较键、值，若不等于，则该条件满足； “=”： 对一个键赋值； “+=”： 为一个表示多个条目的键赋值。 “:=”： 对一个键赋值，并拒绝之后所有对该键的改动。目的是防止后面的规则文件对该键赋值。 2.2.2 规则的匹配键 ACTION： 事件 (uevent) 的行为，例如：add( 添加设备 )、remove( 删除设备 )。 DEVPATH： 设备的 devpath 路径。 SUBSYSTEM： 设备的子系统名称，例如：sda 的子系统为 block。 BUS： 设备在 devpath 里的总线名称，例如：usb。 DRIVER： 设备在 devpath 里的设备驱动名称，例如：ide-cdrom。 ID： 设备在 devpath 里的识别号。 SYSFS{filename}： 设备的 devpath 路径下，设备的属性文件“filename”里的内容。例如：SYSFS{model}==“ST936701SS”表示：如果设备的型号为 ST936701SS，则该设备匹配该 匹配键。在一条规则中，可以设定最多五条 SYSFS 的 匹配键。 ENV{key}： 环境变量。在一条规则中，可以设定最多五条环境变量的 匹配键。 PROGRAM： 调用外部命令。 RESULT： 外部命令 PROGRAM 的返回结果。 2.2.3 重要赋值键 NAME： 在 /dev下产生的设备文件名。只有第一次对某个设备的 NAME 的赋值行为生效，之后匹配的规则再对该设备的 NAME 赋值行为将被忽略。如果没有任何规则对设备的 NAME 赋值，udev 将使用内核设备名称来产生设备文件。 SYMLINK： 为 /dev/下的设备文件产生符号链接。由于 udev 只能为某个设备产生一个设备文件，所以为了不覆盖系统默认的 udev 规则所产生的文件，推荐使用符号链接。 OWNER, GROUP, MODE： 为设备设定权限。 ENV{key}： 导入一个环境变量。 2.2.4 值和可调用的替换操作符 $kernel, %k： 设备的内核设备名称，例如：sda、cdrom。 $number, %n： 设备的内核号码，例如：sda3 的内核号码是 3。 $devpath, %p： 设备的 devpath路径。 $id, %b： 设备在 devpath里的 ID 号。 $sysfs{file}, %s{file}： 设备的 sysfs里 file 的内容。其实就是设备的属性值。 $env{key}, %E{key}： 一个环境变量的值。 $major, %M： 设备的 major 号。 $minor %m： 设备的 minor 号。 $result, %c： PROGRAM 返回的结果。 $parent, %P： 父设备的设备文件名。 $root, %r： udev_root的值，默认是 /dev/。 $tempnode, %N： 临时设备名。 %%： 符号 % 本身。 $$： 符号 $ 本身。 2.3 udev使用假设一个USB扫描仪每次插入Linux设备名称都会变，那么就可以使用：1234SYSFS&#123;idVendor&#125;==&quot;0686&quot;, \\SYSFS&#123;idProduct&#125;==&quot;400e&quot;, \\SYMLINK+=&quot;scanner&quot;, MODE=&quot;0664&quot;, \\group=&quot;scanner&quot; 前两行，确定了扫描仪的生产商和产品号，那么在每次重新插入的时候，都会创建一个/dev/scanner的符号连接，访问权限设置为0664。 修改U盘名称：1KERNEL==&quot;sdc4&quot;,SUBSYSTEMS==&quot;block&quot;, NAME+=&quot;kinstonusb&quot;,SYMLINK+=&quot;kinstonusb_link&quot; 比如你的sdc的优盘为金士顿的，但系统会识别成sdc4不易于识别，那么就可以对sdc建立一个kinstonusb_link链接。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://coderdock.com/categories/Linux/"},{"name":"我的见解","slug":"Linux/我的见解","permalink":"http://coderdock.com/categories/Linux/我的见解/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://coderdock.com/tags/Linux/"},{"name":"SysFs","slug":"SysFs","permalink":"http://coderdock.com/tags/SysFs/"}]},{"title":"虚拟开发板-字符设备驱动","slug":"VirtualBoard/虚拟开发板-字符设备驱动","date":"2017-06-29T04:14:12.000Z","updated":"2018-01-03T00:11:29.011Z","comments":true,"path":"2017/06/29/VirtualBoard/虚拟开发板-字符设备驱动/","link":"","permalink":"http://coderdock.com/2017/06/29/VirtualBoard/虚拟开发板-字符设备驱动/","excerpt":"_______ ______ _______1234567( ____ \\|\\ /|( ___ ) ( __ \\ ( ____ )|\\ /|| ( \\/| ) ( || ( ) | | ( \\ )| ( )|| ) ( || | | (___) || (___) | | | ) || (____)|| | | || | | ___ || ___ | | | | || __)( ( ) )| | | ( ) || ( ) | | | ) || (\\ ( \\ \\_/ /| (____/\\| ) ( || ) ( | | (__/ )| ) \\ \\__ \\ /(_______/|/ \\||/ \\| (______/ |/ \\__/ \\_/","text":"_______ ______ _______1234567( ____ \\|\\ /|( ___ ) ( __ \\ ( ____ )|\\ /|| ( \\/| ) ( || ( ) | | ( \\ )| ( )|| ) ( || | | (___) || (___) | | | ) || (____)|| | | || | | ___ || ___ | | | | || __)( ( ) )| | | ( ) || ( ) | | | ) || (\\ ( \\ \\_/ /| (____/\\| ) ( || ) ( | | (__/ )| ) \\ \\__ \\ /(_______/|/ \\||/ \\| (______/ |/ \\__/ \\_/ udev机制udev提供一个基于用户空间的动态设备节点管理和命名的解决方案。udev提供内核sysfs和tmpfs的支持，sysfs为udev提供设备入口和uevent通道，tmpfs为udev设备文件存放空间。 中断中断机制减少轮询所带来的CPU高占用率 PollPoll机制解决解决阻塞问题。 信号通知信号通知解决数据异步通知的问题 原子 信号量原子与信号量机制解决操作同步所带来的问题。 #驱动源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include &lt;linux/module.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;linux/device.h&gt;#include &lt;linux/io.h&gt;#include &lt;linux/irq.h&gt;#include &lt;linux/platform_device.h&gt;#include &lt;linux/input.h&gt;#include &lt;linux/gpio_keys.h&gt;#include &lt;linux/workqueue.h&gt;#include &lt;linux/gpio.h&gt;#include &lt;linux/irqreturn.h&gt;#include &lt;linux/irqnr.h&gt;#include &lt;linux/hardirq.h&gt;#include &lt;linux/irqflags.h&gt;#include &lt;linux/interrupt.h&gt;#include&lt;mach/gpio.h&gt;#include&lt;asm/io.h&gt;#include&quot;mach/../../mx28_pins.h&quot;#include &lt;mach/pinctrl.h&gt;#include &quot;mach/mx28.h&quot;#include &lt;linux/poll.h&gt;static struct class* first_cha_class;static struct device* first_cha_device;volatile unsigned long *gpfcon = NULL;volatile unsigned long *gpfdat = NULL;static struct fasync_struct* Key_fasync;#define GPIO_BUTTON_PIN MXS_PIN_TO_GPIO(PINID_SSP0_DATA4)int irq_no = 0;int press_id = 1;const char* irqname = &quot;BoKey&quot;;static DECLARE_WAIT_QUEUE_HEAD(btn_wait_queue);static volatile int event_press = 0;static int press_cnt = 0;atomic_t open_flag = ATOMIC_INIT(1);//atomic_read//atomic_inc//atomic_dec//atom_dec_and_teststatic ssize_t first_ch_read (struct file * pfile, char __user * puser, size_t cnt, loff_t * poff)&#123; printk(&quot;read\\n&quot;); wait_event_interruptible(btn_wait_queue, event_press); event_press = 0; copy_to_user(puser, (const void*)&amp;(press_cnt), 4); return 0;&#125;static ssize_t first_ch_write(struct file * pfile, const char __user * pusr, size_t cnt, loff_t * poff)&#123; int val; int count = 4; printk(&quot;write\\n&quot;); copy_from_user(&amp;val, pusr, count); printk(&quot;the val is %d\\n&quot;,val); return 0;&#125;static irqreturn_t key_handler(int irq, void *dev_id)&#123; press_cnt += 1; printk(&quot;K: key down %d\\n&quot;, press_cnt); event_press = 1; wake_up_interruptible(&amp;btn_wait_queue); kill_fasync(&amp;Key_fasync, SIGIO, POLL_IN); return 0;&#125;static int first_ch_open(struct inode * pnode, struct file * pfile)&#123; int err = 0; int iRet = 0; if(atomic_read(&amp;open_flag) != 1) &#123; atomic_dec(&amp;open_flag); return -EBUSY; &#125; printk(&quot;open\\n&quot;); gpio_free(GPIO_BUTTON_PIN); //先清除原先的复用功能 iRet = gpio_request(GPIO_BUTTON_PIN, &quot;irqtest&quot;); if (iRet != 0) &#123; printk(&quot;request gpio failed \\n&quot;); return -EBUSY; &#125; gpio_direction_input(GPIO_BUTTON_PIN); //设置输入功能 irq_no = gpio_to_irq(GPIO_BUTTON_PIN); //得到中断号 set_irq_type(irq_no, IRQF_TRIGGER_FALLING); //下降沿中断 err = request_irq(irq_no, key_handler, IRQF_TRIGGER_FALLING, irqname,(void*)&amp;press_id); printk(&quot;The err is %d\\n&quot;, err); return 0;&#125;static unsigned int first_ch_poll(struct file *fp, poll_table * wait)&#123; unsigned int mask = 0; poll_wait(fp, &amp;btn_wait_queue, wait); if(event_press) mask |= POLLIN | POLLRDNORM; return mask;&#125;static int first_ch_sync(int fd, struct file* filp, int on)&#123; printk(&quot;Async Set\\n&quot;); return fasync_helper(fd, filp, on, &amp;Key_fasync);&#125;static struct file_operations first_ch_fops = &#123; .owner = THIS_MODULE, .open = first_ch_open, .read = first_ch_read, .write = first_ch_write, .poll = first_ch_poll, .fasync = first_ch_sync,&#125;;int first_ch_init(void)&#123; int major = 0; major = register_chrdev(0, &quot;first_drv&quot;, &amp;first_ch_fops); //当输入为0时，由系统自动分配 printk(&quot;The major is %d\\n&quot;, major); first_cha_class = class_create(THIS_MODULE, &quot;first_drv&quot;); if(IS_ERR(first_cha_class)) &#123; printk(&quot;class create failed\\n&quot;); return -1; &#125; first_cha_device = device_create(first_cha_class, NULL, MKDEV(major, 0), NULL, &quot;first_cha&quot;); if(IS_ERR(first_cha_device)) &#123; printk(&quot;create device failed\\n&quot;); return -1; &#125; //gpfcon = (volatile unsigned long *)ioremap(0x56000000, 0x10); //gpfdat = gpfcon + 1; return 0;&#125;//函数操作集合void first_ch_exit(void)&#123; device_unregister(first_cha_device); class_destroy(first_cha_class); //iounmap(gpfcon); free_irq(irq_no,(void*)&amp;press_id); atomic_inc(&amp;open_flag);&#125;module_init(first_ch_init);module_exit(first_ch_exit);MODULE_LICENSE (&quot;GPL&quot;);//开源协议GPL 或者Dual BSDMODULE_AUTHOR (&quot;TOM&quot;);//作者MODULE_DESCRIPTION (&quot;MY_TEST&quot;);//描述此驱动 Makefile123456obj-m := first_cha.oKDIR := /home/bo/Documents/linux-2.6.35.3all: make -C $(KDIR) M=$(PWD) modules CROSS_COMPILE=arm-none-linux-gnueabi- ARCH=armclean: rm -f *.ko *.o *.mod.o *.mod.c *.symvers *.bak *.order 应用程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;stdio.h&gt;#include&lt;poll.h&gt;#include &lt;signal.h&gt;void My_SigFun(int nSigNum);int main()&#123; int fd; int val = 1; int nStatus = 0; int Oflags; struct pollfd pfd[1]; signal(SIGIO, My_SigFun); fd = open(&quot;/dev/first_cha&quot;, O_RDWR); if(fd &lt; 0) &#123; printf(&quot;open failed\\n&quot;); return -1; &#125; //将当前进程PID设置为fd文件所对应驱动程序将要发送SIGIO,SIGUSR信号进程PID fcntl(fd, F_SETOWN, getpid()); //获取fd的打开方式 Oflags = fcntl(fd, F_GETFL); //将fd的打开方式设置为FASYNC --- 即 支持异步通知 //该行代码执行会触发 驱动程序中 file_operations-&gt;fasync 函数 ------fasync函数调用fasync_helper初始化一个fasync_struct结构体，该结构体描述了将要发送信号的进程PID (fasync_struct-&gt;fa_file-&gt;f_owner-&gt;pid) fcntl(fd, F_SETFL, Oflags | FASYNC); write(fd, &amp;val, 4); pfd[0].fd = fd; pfd[0].events = POLLIN; while(1) &#123; nStatus = poll(pfd, 1, 5000); if(nStatus == 0) &#123; printf(&quot;timeout\\n&quot;); &#125; else &#123; read(fd, &amp;val); printf(&quot;A: cnt: %d\\n&quot;, val); &#125; &#125; return 0;&#125;void My_SigFun(int nSigNum) // kill -USR1 pid&#123; printf(&quot;Get Sig\\n&quot;);&#125;","categories":[{"name":"虚拟开发板","slug":"虚拟开发板","permalink":"http://coderdock.com/categories/虚拟开发板/"},{"name":"字符设备","slug":"虚拟开发板/字符设备","permalink":"http://coderdock.com/categories/虚拟开发板/字符设备/"}],"tags":[{"name":"虚拟开发板","slug":"虚拟开发板","permalink":"http://coderdock.com/tags/虚拟开发板/"},{"name":"字符设备","slug":"字符设备","permalink":"http://coderdock.com/tags/字符设备/"}]},{"title":"libevent系列-基本了解","slug":"libevent/libevent系列-基本了解","date":"2017-06-17T12:11:38.000Z","updated":"2018-01-06T12:16:21.687Z","comments":true,"path":"2017/06/17/libevent/libevent系列-基本了解/","link":"","permalink":"http://coderdock.com/2017/06/17/libevent/libevent系列-基本了解/","excerpt":"","text":"","categories":[{"name":"libevent系列","slug":"libevent系列","permalink":"http://coderdock.com/categories/libevent系列/"}],"tags":[{"name":"libevent","slug":"libevent","permalink":"http://coderdock.com/tags/libevent/"},{"name":"基础了解","slug":"基础了解","permalink":"http://coderdock.com/tags/基础了解/"}]},{"title":"Linux中断处理机制之我见","slug":"LinuxSource/Linux中断处理机制之我见","date":"2017-06-14T05:00:45.000Z","updated":"2018-01-03T00:06:56.537Z","comments":true,"path":"2017/06/14/LinuxSource/Linux中断处理机制之我见/","link":"","permalink":"http://coderdock.com/2017/06/14/LinuxSource/Linux中断处理机制之我见/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"list_head之必知必会","slug":"LinuxSource/list-head之必知必会","date":"2017-06-12T23:54:05.000Z","updated":"2018-01-03T00:06:56.551Z","comments":true,"path":"2017/06/13/LinuxSource/list-head之必知必会/","link":"","permalink":"http://coderdock.com/2017/06/13/LinuxSource/list-head之必知必会/","excerpt":"本章介绍list_head的相关知识。12345678 _ _________ _______ _________ _______ _______ ______( \\ \\__ __/( ____ \\\\__ __/ |\\ /|( ____ \\( ___ )( __ \\| ( ) ( | ( \\/ ) ( | ) ( || ( \\/| ( ) || ( \\ )| | | | | (_____ | | | (___) || (__ | (___) || | ) || | | | (_____ ) | | | ___ || __) | ___ || | | || | | | ) | | | | ( ) || ( | ( ) || | ) || (____/\\___) (___/\\____) | | | | ) ( || (____/\\| ) ( || (__/ )(_______/\\_______/\\_______) )_( |/ \\|(_______/|/ \\|(______/","text":"本章介绍list_head的相关知识。12345678 _ _________ _______ _________ _______ _______ ______( \\ \\__ __/( ____ \\\\__ __/ |\\ /|( ____ \\( ___ )( __ \\| ( ) ( | ( \\/ ) ( | ) ( || ( \\/| ( ) || ( \\ )| | | | | (_____ | | | (___) || (__ | (___) || | ) || | | | (_____ ) | | | ___ || __) | ___ || | | || | | | ) | | | | ( ) || ( | ( ) || | ) || (____/\\___) (___/\\____) | | | | ) ( || (____/\\| ) ( || (__/ )(_______/\\_______/\\_______) )_( |/ \\|(_______/|/ \\|(______/ 1.list_entry的作用123struct list_head &#123; struct list_head *next, *prev;&#125;; 没有数据区怎么使用，更多的时候是嵌入到其他结构体中使用。1234struct file_node&#123; char c; struct list_head node;&#125;; 当我们知道 list_head的地址时，就可以通过宏 list_entry获取父结构的地址：123456789#define list_entry(ptr,type,member)\\ container_of(ptr,type,member)#define container_of(ptr,type,member) ( &#123;\\ const typeof( ((type*)0)-&gt;member ) *__mptr=(ptr);\\ (type*)( (char*)__mptr - offsetof(type,member) );&#125; )#define offsetof(TYPE,MEMBER) ((size_t)&amp;((TYPE *)0)-&gt;MEMBER) 首先解释offsetof:123将实参代入 offset( struct file_node, node )( (size_t) &amp; ((struct file_node*)0）-&gt; node ) 这句的意思是将结构体file_node的指针转变为0，那么node的指针就是相对于0d地址的指针，即node在file_node中的偏移。 然后解释 container_of :该句有两句组成：首先第一句可以缩减为：_mtr = (ptr)即保存 ptr的指针。 第二句： _mptr - 该member相对于结构体的偏移，那么得到的不就是父结构体的指针了么。 所以 list_entry的作用就是得到父结构的起始地址。 2.LIST_HEAD()LIST_HEAD就是定义一个前向和后向都指向自己的list_head1234#define LIST_HEAD(name) \\struct list_head name = LIST_HEAD_INIT(name)#define LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125; INIT_LIST_HEAD就是指向初始化一个list_head指向实际的结构体12345static inline void INIT_LIST_HEAD(struct list_head *list)&#123; list-&gt;next = list; list-&gt;prev = list;&#125; 双向链表的插入操作 – list_add() 将new所代表的结构体插入head所管理的双向链表的头节点head之后: （即插入表头）1234567891011static inline void list_add(struct list_head *new, struct list_head *head)&#123; __list_add(new, head, head-&gt;next);&#125;static inline void __list_add( struct list_head *new, struct list_head *prev, struct list_head *next)&#123; next-&gt;prev = new; //之前后边的前向指向新的 new-&gt;next = next; //新的后向指向之前的后边 new-&gt;prev = prev; //新的前向指向之前的前向 prev-&gt;next = new; //之前的前边的后向指向新的&#125; 从list中删除结点——list_del()1234567891011static inline void list_del(struct list_head *entry)&#123; __list_del(entry-&gt;prev, entry-&gt;next); entry-&gt;next = LIST_POISON1; entry-&gt;prev = LIST_POISON2;&#125;static inline void __list_del(struct list_head * prev, struct list_head * next)&#123; next-&gt;prev = prev; prev-&gt;next = next;&#125; 判断链表是否为空（如果双向链表head为空则返回真，否则为假）——list_empty()1234static inline int list_empty(const struct list_head *head)&#123; return head-&gt;next == head;&#125; 3.list_for_each_entry1234567891011/** * list_for_each_entry - iterate over list of given type * @pos: the type * to use as a loop cursor. * @head: the head for your list. * @member: the name of the list_struct within the struct. */#define list_for_each_entry(pos, head, member) \\ for (pos = list_entry((head)-&gt;next, typeof(*pos), member); \\ prefetch(pos-&gt;member.next), &amp;pos-&gt;member != (head); \\ pos = list_entry(pos-&gt;member.next, typeof(*pos), member))","categories":[{"name":"Linux","slug":"Linux","permalink":"http://coderdock.com/categories/Linux/"},{"name":"输入子系统","slug":"Linux/输入子系统","permalink":"http://coderdock.com/categories/Linux/输入子系统/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://coderdock.com/tags/Linux/"},{"name":"list_head","slug":"list-head","permalink":"http://coderdock.com/tags/list-head/"}]},{"title":"通信协议-IIC Verilog HDL实现","slug":"Protocal/通信协议-IIC-Verilog-HDL实现","date":"2017-06-08T14:00:07.000Z","updated":"2018-01-03T00:06:56.388Z","comments":true,"path":"2017/06/08/Protocal/通信协议-IIC-Verilog-HDL实现/","link":"","permalink":"http://coderdock.com/2017/06/08/Protocal/通信协议-IIC-Verilog-HDL实现/","excerpt":"&emsp;&emsp;该程序使用Verilog通过状态机实现IIC读写AT24C02。","text":"&emsp;&emsp;该程序使用Verilog通过状态机实现IIC读写AT24C02。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406module iic_com( clk, rst_n, sw1, sw2, // SW1写入AT240C2 scl, sda, //时钟 数据 dis_data //输出变量用数码管显示);input clk;input rst_n;input sw1,sw2;output scl;inout sda;output [7:0] dis_data;reg sw1_r, sw2_r;reg[19:0] cnt_20ms;always @ (posedge clk or negedge rst_n) if(!rst_n) cnt_20ms &lt;= 20&apos;d0; else cnt_20ms &lt;= cnt_20ms + 1&apos;b1; //不断计数always @(posedge clk or negedge rst_n) if(!rst_n) begin sw1_r &lt;= 1&apos;b1; sw2_r &lt;= 1&apos;b1; end else if(cnt_20ms == 20&apos;hfffff) begin sw1_r &lt;= sw1; //20ms进行一次锁存 sw2_r &lt;= sw2; end//以下的程序将输入时钟进行分频，并且应用于SCL输出上reg[2:0] cnt; // cnt=0:scl上升沿，cnt=1:scl高电平中间，cnt=2:scl下降沿，cnt=3:scl低电平中间reg[8:0] cnt_delay; //500循环计数，产生iic所需要的时钟reg scl_r; //时钟脉冲寄存器always @ (posedge clk or negedge rst_n) if(!rst_n) cnt_delay &lt;= 9&apos;d0; else if(cnt_delay == 9&apos;d499) cnt_delay &lt;= 9&apos;d0; //计数到10us为scl的周期，即100KHz else cnt_delay &lt;= cnt_delay+1&apos;b1; //时钟计数always @ (posedge clk or negedge rst_n) begin if(!rst_n) cnt &lt;= 3&apos;d5; else begin case (cnt_delay) 9&apos;d124: cnt &lt;= 3&apos;d1; //cnt=1:scl高电平中间,用于数据采样 9&apos;d249: cnt &lt;= 3&apos;d2; //cnt=2:scl下降沿 9&apos;d374: cnt &lt;= 3&apos;d3; //cnt=3:scl低电平中间,用于数据变化 9&apos;d499: cnt &lt;= 3&apos;d0; //cnt=0:scl上升沿 default: cnt &lt;= 3&apos;d5; endcase endend`define SCL_POS (cnt == 3&apos;d0)`define SCL_HIG (cnt == 3&apos;d1)`define SCL_NEG (cnt == 3&apos;d2)`define SCL_LOW (cnt == 3&apos;d3)always @(posedge clk or negedge rst_n) if(!rst_n) scl_r &lt;= 1&apos;b0; else if(cnt == 3&apos;d0) scl_r &lt;= 1&apos;b1; //scl信号设置为高 else if(cnt == 3&apos;d2) scl_r &lt;= 1&apos;b0; //scl信号设置为低assign scl = scl_r; //模块对外输出SCL信号//具体对24C02的具体操作`define DEVICE_READ 8&apos;b1010_0001`define DEVICE_WRITE 8&apos;b1010_0000`define WRITE_DATA 8&apos;b0001_0001`define BYTE_ADDR 8&apos;b0000_0011reg[7:0] db_r; //在IIC上传送的数据寄存器reg[7:0] read_data; //读出的EEPROM的数据//读写时序parameter IDLE = 4&apos;d0;parameter START1 = 4&apos;d1;parameter ADD1 = 4&apos;d2;parameter ACK1 = 4&apos;d3;parameter ADD2 = 4&apos;d4;parameter ACK2 = 4&apos;d5;parameter START2 = 4&apos;d6;parameter ADD3 = 4&apos;d7;parameter ACK3 = 4&apos;d8;parameter DATA = 4&apos;d9;parameter ACK4 = 4&apos;d10;parameter STOP1 = 4&apos;d11;parameter STOP2 = 4&apos;d12;reg[3:0] cstate; //状态寄存器reg sda_r; //输出数据寄存器reg sda_link; //输出数据sda信号inout方向控制位 1 输入 0 输出reg[3:0] num;always@(posedge clk or negedge rst_n)begin if(!rst_n) begin cstate &lt;= IDLE; sda_r &lt;= 1&apos;b1; sda_link &lt;= 1&apos;b0; num &lt;= 4&apos;d0; read_data &lt;= 8&apos;b0000_0000; end else case(cstate) IDLE: begin sda_link &lt;= 1&apos;b1; sda_r &lt;= 1&apos;b1; if(!sw1_r || sw2_r) begin db_r &lt;= `DEVICE_WRITE; cstate &lt;= START1; end else cstate &lt;= IDLE; end START1: //先给出开始信号 begin if(`SCL_HIG) begin sda_link &lt;= 1&apos;b1; //设置sda为output sda_r &lt;= 1&apos;b0; //拉低sda,产生起始信号 cstate &lt;= ADD1; //进入下一阶段 num &lt;= 4&apos;d0; end else cstate &lt;= START1; //等待达到 SCL高电平中间 end ADD1: begin if(`SCL_LOW) //低电平变换数据 begin if(num == 4&apos;d8) begin num &lt;= 4&apos;d0; sda_r &lt;= 1&apos;b1; sda_link &lt;= 1&apos;b0; //sda设置为高阻态（input） cstate &lt;= ACK1; end else begin cstate &lt;= ADD1; num &lt;= num + 1&apos;b1; case(num) 4&apos;d0: sda_r &lt;= db_r[7]; 4&apos;d1: sda_r &lt;= db_r[6]; 4&apos;d2: sda_r &lt;= db_r[5]; 4&apos;d3: sda_r &lt;= db_r[4]; 4&apos;d4: sda_r &lt;= db_r[3]; 4&apos;d5: sda_r &lt;= db_r[2]; 4&apos;d6: sda_r &lt;= db_r[1]; 4&apos;d7: sda_r &lt;= db_r[0]; default: ; endcase end end else cstate &lt;= ADD1; end ACK1: begin if(`SCL_NEG) //该器件不考虑应答，直接认为已经响应，接下来传输写入的地址 begin cstate &lt;= ADD2; db_r &lt;= `BYTE_ADDR; end else cstate &lt;= ACK1; end ADD2: //写入数据的地址 begin if(`SCL_LOW) begin if(num == 4&apos;d8) begin num &lt;= 4&apos;d0; sda_r &lt;= 1&apos;b1; sda_link &lt;= 1&apos;b0; //设置为高阻态，为解说应答做准备 cstate &lt;= ACK2; end else begin sda_link &lt;= 1&apos;b1; num &lt;= num + 1&apos;b1; case(num) 4&apos;d0: sda_r &lt;= db_r[7]; 4&apos;d1: sda_r &lt;= db_r[6]; 4&apos;d2: sda_r &lt;= db_r[5]; 4&apos;d3: sda_r &lt;= db_r[4]; 4&apos;d4: sda_r &lt;= db_r[3]; 4&apos;d5: sda_r &lt;= db_r[2]; 4&apos;d6: sda_r &lt;= db_r[1]; 4&apos;d7: sda_r &lt;= db_r[0]; default: ; endcase cstate &lt;= ADD2; end end else cstate &lt;= ADD2; end ACK2: begin if(`SCL_NEG) begin if(!sw1_r) //根据按键判断是读还是写 begin cstate &lt;= DATA; db_r &lt;= `WRITE_DATA; end else if(!sw2_r) begin db_r &lt;= `DEVICE_READ; cstate &lt;= START2; end end else cstate &lt;= START2; end START2: begin if(`SCL_LOW) begin sda_link &lt;= 1&apos;b1; sda_r &lt;= 1&apos;b1; cstate &lt;= START2; end else if(`SCL_HIG) begin sda_r &lt;= 1&apos;b0; cstate &lt;= ADD3; end else cstate &lt;= START2; end ADD3: //写入要读的地址 begin if(`SCL_LOW) begin if(num == 4&apos;d8) begin num &lt;= 4&apos;d0; sda_r &lt;= 1&apos;b1; sda_link &lt;= 1&apos;b0; cstate &lt;= ACK3; end else begin case(num) 4&apos;d0: sda_r &lt;= db_r[7]; 4&apos;d1: sda_r &lt;= db_r[6]; 4&apos;d2: sda_r &lt;= db_r[5]; 4&apos;d3: sda_r &lt;= db_r[4]; 4&apos;d4: sda_r &lt;= db_r[3]; 4&apos;d5: sda_r &lt;= db_r[2]; 4&apos;d6: sda_r &lt;= db_r[1]; 4&apos;d7: sda_r &lt;= db_r[0]; default: ; endcase cstate &lt;= ADD3; end end else cstate &lt;= ADD3; end ACK3: begin if(`SCL_NEG) begin cstate &lt;= DATA; sda_link &lt;= 1&apos;b0; end else cstate &lt;= ACK3; end DATA: begin if(!sw2_r) //读操作 begin if(num &lt;= 4&apos;d7) begin cstate &lt;= DATA; if(`SCL_HIG) begin num &lt;= num + 1&apos;b1; case(num) 4&apos;d0: read_data[7] &lt;= sda; //依次在高电平保存数据 4&apos;d1: read_data[6] &lt;= sda; 4&apos;d2: read_data[5] &lt;= sda; 4&apos;d3: read_data[4] &lt;= sda; 4&apos;d4: read_data[3] &lt;= sda; 4&apos;d5: read_data[2] &lt;= sda; 4&apos;d6: read_data[1] &lt;= sda; 4&apos;d7: read_data[0] &lt;= sda; default: ; endcase end end else if((`SCL_LOW) &amp;&amp; (num == 4&apos;d8)) begin num &lt;= 4&apos;d0; cstate &lt;= ACK4; end else cstate &lt;= DATA; end else if(!sw1_r) //写操作 begin sda_link &lt;= 1&apos;b1; if(num &lt;= 4&apos;d7) begin cstate &lt;= DATA; if(`SCL_LOW) begin sda_link &lt;= 1&apos;b1; num &lt;= num + 1&apos;b1; case(num) 4&apos;d0: sda_r &lt;= db_r[7]; 4&apos;d1: sda_r &lt;= db_r[6]; 4&apos;d2: sda_r &lt;= db_r[5]; 4&apos;d3: sda_r &lt;= db_r[4]; 4&apos;d4: sda_r &lt;= db_r[3]; 4&apos;d5: sda_r &lt;= db_r[2]; 4&apos;d6: sda_r &lt;= db_r[1]; 4&apos;d7: sda_r &lt;= db_r[0]; default: ; endcase end end else if((`SCL_LOW) &amp;&amp; (num == 4&apos;d8)) begin num &lt;= 4&apos;d0; sda_r &lt;= 1&apos;b1; sda_link &lt;= 1&apos;b0; cstate &lt;= ACK4; end else cstate &lt;= ACK4; end end ACK4: begin if(`SCL_NEG) begin cstate &lt;= STOP1; end else cstate &lt;= ACK4; end STOP1: begin if(`SCL_LOW) begin sda_link &lt;= 1&apos;b1; sda_r &lt;= 1&apos;b0; cstate &lt;= STOP1; end else if(`SCL_HIG) begin sda_r &lt;= 1&apos;b1; cstate &lt;= STOP2; end else cstate &lt;= STOP1; end STOP2: begin if(`SCL_LOW) sda_r &lt;= 1&apos;b1; else if(cnt_20ms == 20&apos;hffff0) cstate &lt;= IDLE; else cstate &lt;= STOP2; end default: cstate &lt;= IDLE; endcaseendassign sda = sda_link ? sda_r:1&apos;bz;assign dis_data = read_data;endmodule","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://coderdock.com/categories/基础知识/"}],"tags":[{"name":"IIC","slug":"IIC","permalink":"http://coderdock.com/tags/IIC/"},{"name":"Verilog HDL","slug":"Verilog-HDL","permalink":"http://coderdock.com/tags/Verilog-HDL/"},{"name":"IIC实现","slug":"IIC实现","permalink":"http://coderdock.com/tags/IIC实现/"}]},{"title":"Linux统一设备模型之我见","slug":"LinuxSource/Linux统一设备模型之我见","date":"2017-06-06T05:01:37.000Z","updated":"2018-01-03T00:06:56.528Z","comments":true,"path":"2017/06/06/LinuxSource/Linux统一设备模型之我见/","link":"","permalink":"http://coderdock.com/2017/06/06/LinuxSource/Linux统一设备模型之我见/","excerpt":"Linux设备模型为内核建立起一个统一的设备模型，从而有一个对系统结构的一般性抽象描述。1234567891011121314151617______ _______ _________ _______ _______( __ \\ ( ____ \\|\\ /|\\__ __/( ____ \\( ____ \\| ( \\ )| ( \\/| ) ( | ) ( | ( \\/| ( \\/| | ) || (__ | | | | | | | | | (__| | | || __) ( ( ) ) | | | | | __)| | ) || ( \\ \\_/ / | | | | | (| (__/ )| (____/\\ \\ / ___) (___| (____/\\| (____/\\(______/ (_______/ \\_/ \\_______/(_______/(_______/_______ _______ ______ _______ _( )( ___ )( __ \\ ( ____ \\( \\| () () || ( ) || ( \\ )| ( \\/| (| || || || | | || | ) || (__ | || |(_)| || | | || | | || __) | || | | || | | || | ) || ( | || ) ( || (___) || (__/ )| (____/\\| (____/\\|/ \\|(_______)(______/ (_______/(_______/","text":"Linux设备模型为内核建立起一个统一的设备模型，从而有一个对系统结构的一般性抽象描述。1234567891011121314151617______ _______ _________ _______ _______( __ \\ ( ____ \\|\\ /|\\__ __/( ____ \\( ____ \\| ( \\ )| ( \\/| ) ( | ) ( | ( \\/| ( \\/| | ) || (__ | | | | | | | | | (__| | | || __) ( ( ) ) | | | | | __)| | ) || ( \\ \\_/ / | | | | | (| (__/ )| (____/\\ \\ / ___) (___| (____/\\| (____/\\(______/ (_______/ \\_/ \\_______/(_______/(_______/_______ _______ ______ _______ _( )( ___ )( __ \\ ( ____ \\( \\| () () || ( ) || ( \\ )| ( \\/| (| || || || | | || | ) || (__ | || |(_)| || | | || | | || __) | || | | || | | || | ) || ( | || ) ( || (___) || (__/ )| (____/\\| (____/\\|/ \\|(_______)(______/ (_______/(_______/ 1.背景在 Linux 2.5 内核的开发过程中，人们设计了一套新的设备模型，目的是为了对计算机上的所有设备进行统一地表示和操作，包括设备本身和设备之间的连接关系。这个模型是在分析了 PCI 和 USB 的总线驱动过程中得到的，这两个总线类型能代表当前系统中的大多数设备类型，它们都有完善的热挺拔机制和电源管理的支持，也都有级连机制的支持，以桥接的 PCI/USB 总线控制器的方式可以支持更多的 PCI/USB 设备。为了给所有设备添加统一的电源管理的支持，而不是让每个设备中去独立实现电源管理的支持，人们考虑的是如何尽可能地重用代码；而且在有层次模型的 PCI/USB 总线中，必须以合理形式展示出这个层次关系，这也是电源管理等所要求的必须有层次结构。 如在一个典型的 PC 系统中，中央处理器(CPU)能直接控制的是 PCI 总线设备，而 USB 总线设备是以一个 PCI 设备(PCI-USB桥)的形式接入在 PCI 总线设备上，外部 USB 设备再接入在 USB 总线设备上；当计算机执行挂起(suspend)操作时， Linux 内核应该以 “外部USB设备-&gt;USB总线设备-&gt;PCI总线设备” 的顺序通知每一个设备将电源挂起；执行恢复(resume)时则以相反的顺序通知；反之如果不按此顺序则将有设备得不到正确的电源状态变迁的通知，将无法正常工作。 2.Linux统一设备模型2.1 基本结构 类型 所包含的内容 对应的内核数据结构 设备（Device） 设备是此模型中最基本的类型，以设备本身的连接按层次组织 struct device 设备驱动（Device Drivver） 在一个系统中安装多个相同设备，只需要一份驱动程序的支持 struct device_driver 总线类型(Bus Types) 在整个总线级别对此总线上连接的所有设备进行管理 struct bus_type 设备类别(Device Classes) 按照功能进行分类组织的设备层次树,如键盘在输入类下 struct class 2.1 基本连接从内核在实现它们时所使用的数据结构来说， Linux 统一设备模型又是以两种基本数据结构进行树型和链表型结构组织的： kobject: 在 Linux 设备模型中最基本的对象，它的功能是提供引用计数和维持父子(parent)结构、平级(sibling)目录关系，上面的 device, device_driver 等各对象都是以 kobject 基础功能之上实现的。12345678910111213struct kobject &#123; const char *name; struct list_head entry; struct kobject *parent; struct kset *kset; struct kobj_type *ktype; struct sysfs_dirent *sd; struct kref kref; unsigned int state_initialized:1; unsigned int state_in_sysfs:1; unsigned int state_add_uevent_sent:1; unsigned int state_remove_uevent_sent:1;&#125;; 其中 struct kref 内含一个 atomic_t 类型用于引用计数， parent 是单个指向父节点的指针， entry 用于父 kset 以链表头结构将 kobject 结构维护成双向链表； kset: 它用来对同类型对象提供一个包装集合，在内核数据结构上它也是由内嵌一个 kboject 实现，因而它同时也是一个 kobject (面向对象 OOP 概念中的继承关系) ，具有 kobject 的全部功能。123456truct kset &#123; struct list_head list; spinlock_t list_lock; struct kobject kobj; struct kset_uevent_ops *uevent_ops;&#125;; 其中的 struct list_head list 用于将集合中的 kobject 按 struct list_head entry 维护成双向链表。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://coderdock.com/categories/Linux/"},{"name":"统一设备模型","slug":"Linux/统一设备模型","permalink":"http://coderdock.com/categories/Linux/统一设备模型/"},{"name":"我的见解","slug":"Linux/统一设备模型/我的见解","permalink":"http://coderdock.com/categories/Linux/统一设备模型/我的见解/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://coderdock.com/tags/Linux/"},{"name":"统一设备模型","slug":"统一设备模型","permalink":"http://coderdock.com/tags/统一设备模型/"}]},{"title":"Linux输入子系统Core源码简要分析","slug":"LinuxSource/Linux输入子系统Core源码简要分析","date":"2017-06-02T23:53:48.000Z","updated":"2018-01-03T00:06:56.521Z","comments":true,"path":"2017/06/03/LinuxSource/Linux输入子系统Core源码简要分析/","link":"","permalink":"http://coderdock.com/2017/06/03/LinuxSource/Linux输入子系统Core源码简要分析/","excerpt":"本章对Linux输入子系统InPutCore的源码进行简要分析。1234567891011121314151617_________ _ _______ _________\\__ __/( ( /|( ____ )|\\ /|\\__ __/ ) ( | \\ ( || ( )|| ) ( | ) ( | | | \\ | || (____)|| | | | | | | | | (\\ \\) || _____)| | | | | | | | | | \\ || ( | | | | | |___) (___| ) \\ || ) | (___) | | |\\_______/|/ )_)|/ (_______) )_( _______ _______ _______ _______( ____ \\( ___ )( ____ )( ____ \\| ( \\/| ( ) || ( )|| ( \\/| | | | | || (____)|| (__| | | | | || __)| __)| | | | | || (\\ ( | (| (____/\\| (___) || ) \\ \\__| (____/\\(_______/(_______)|/ \\__/(_______/","text":"本章对Linux输入子系统InPutCore的源码进行简要分析。1234567891011121314151617_________ _ _______ _________\\__ __/( ( /|( ____ )|\\ /|\\__ __/ ) ( | \\ ( || ( )|| ) ( | ) ( | | | \\ | || (____)|| | | | | | | | | (\\ \\) || _____)| | | | | | | | | | \\ || ( | | | | | |___) (___| ) \\ || ) | (___) | | |\\_______/|/ )_)|/ (_______) )_( _______ _______ _______ _______( ____ \\( ___ )( ____ )( ____ \\| ( \\/| ( ) || ( )|| ( \\/| | | | | || (____)|| (__| | | | | || __)| __)| | | | | || (\\ ( | (| (____/\\| (___) || ) \\ \\__| (____/\\(_______/(_______)|/ \\__/(_______/ 想要读懂Linux输入子系统的源码需要先明确三个结构体： input_handle建立 input_dev 和 input_handler的联系，通过两个list保存系统中所有的device和 handler。123456789101112131415161718192021/** * struct input_handle - links input device with an input handler * @private: handler-specific data * @open: counter showing whether the handle is &apos;open&apos;, i.e. should deliver * events from its device * @name: name given to the handle by handler that created it * @dev: input device the handle is attached to * @handler: handler that works with the device through this handle * @d_node: used to put the handle on device&apos;s list of attached handles * @h_node: used to put the handle on handler&apos;s list of handles from which * it gets events */struct input_handle &#123; void *private; int open; const char *name; struct input_dev *dev; struct input_handler *handler; struct list_head d_node; struct list_head h_node;&#125;; input_dev表征一个输入设备：在向InputCore注册一个输入设备前，需要先分配一个此结构体并且初始化某些值，如设置按键类型，按键值等。如需要定时操作，初始化timer_list，这样就可以进行定时操作了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134/** * struct input_dev - represents an input device * @name: name of the device * @phys: physical path to the device in the system hierarchy * @uniq: unique identification code for the device (if device has it) * @id: id of the device (struct input_id) * @propbit: bitmap of device properties and quirks * @evbit: bitmap of types of events supported by the device (EV_KEY, * EV_REL, etc.) * @keybit: bitmap of keys/buttons this device has * @relbit: bitmap of relative axes for the device * @absbit: bitmap of absolute axes for the device * @mscbit: bitmap of miscellaneous events supported by the device * @ledbit: bitmap of leds present on the device * @sndbit: bitmap of sound effects supported by the device * @ffbit: bitmap of force feedback effects supported by the device * @swbit: bitmap of switches present on the device * @hint_events_per_packet: average number of events generated by the * device in a packet (between EV_SYN/SYN_REPORT events). Used by * event handlers to estimate size of the buffer needed to hold * events. * @keycodemax: size of keycode table * @keycodesize: size of elements in keycode table * @keycode: map of scancodes to keycodes for this device * @getkeycode: optional legacy method to retrieve current keymap. * @setkeycode: optional method to alter current keymap, used to implement * sparse keymaps. If not supplied default mechanism will be used. * The method is being called while holding event_lock and thus must * not sleep * @ff: force feedback structure associated with the device if device * supports force feedback effects * @repeat_key: stores key code of the last key pressed; used to implement * software autorepeat * @timer: timer for software autorepeat * @rep: current values for autorepeat parameters (delay, rate) * @mt: pointer to multitouch state * @absinfo: array of &amp;struct input_absinfo elements holding information * about absolute axes (current value, min, max, flat, fuzz, * resolution) * @key: reflects current state of device&apos;s keys/buttons * @led: reflects current state of device&apos;s LEDs * @snd: reflects current state of sound effects * @sw: reflects current state of device&apos;s switches * @open: this method is called when the very first user calls * input_open_device(). The driver must prepare the device * to start generating events (start polling thread, * request an IRQ, submit URB, etc.) * @close: this method is called when the very last user calls * input_close_device(). * @flush: purges the device. Most commonly used to get rid of force * feedback effects loaded into the device when disconnecting * from it * @event: event handler for events sent _to_ the device, like EV_LED * or EV_SND. The device is expected to carry out the requested * action (turn on a LED, play sound, etc.) The call is protected * by @event_lock and must not sleep * @grab: input handle that currently has the device grabbed (via * EVIOCGRAB ioctl). When a handle grabs a device it becomes sole * recipient for all input events coming from the device * @event_lock: this spinlock is taken when input core receives * and processes a new event for the device (in input_event()). * Code that accesses and/or modifies parameters of a device * (such as keymap or absmin, absmax, absfuzz, etc.) after device * has been registered with input core must take this lock. * @mutex: serializes calls to open(), close() and flush() methods * @users: stores number of users (input handlers) that opened this * device. It is used by input_open_device() and input_close_device() * to make sure that dev-&gt;open() is only called when the first * user opens device and dev-&gt;close() is called when the very * last user closes the device * @going_away: marks devices that are in a middle of unregistering and * causes input_open_device*() fail with -ENODEV. * @dev: driver model&apos;s view of this device * @h_list: list of input handles associated with the device. When * accessing the list dev-&gt;mutex must be held * @node: used to place the device onto input_dev_list * @num_vals: number of values queued in the current frame * @max_vals: maximum number of values queued in a frame * @vals: array of values queued in the current frame * @devres_managed: indicates that devices is managed with devres framework * and needs not be explicitly unregistered or freed. */struct input_dev &#123; const char *name; const char *phys; const char *uniq; struct input_id id; unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)]; unsigned long evbit[BITS_TO_LONGS(EV_CNT)]; unsigned long keybit[BITS_TO_LONGS(KEY_CNT)]; unsigned long relbit[BITS_TO_LONGS(REL_CNT)]; unsigned long absbit[BITS_TO_LONGS(ABS_CNT)]; unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)]; unsigned long ledbit[BITS_TO_LONGS(LED_CNT)]; unsigned long sndbit[BITS_TO_LONGS(SND_CNT)]; unsigned long ffbit[BITS_TO_LONGS(FF_CNT)]; unsigned long swbit[BITS_TO_LONGS(SW_CNT)]; unsigned int hint_events_per_packet; unsigned int keycodemax; unsigned int keycodesize; void *keycode; int (*setkeycode)(struct input_dev *dev, const struct input_keymap_entry *ke, unsigned int *old_keycode); int (*getkeycode)(struct input_dev *dev, struct input_keymap_entry *ke); struct ff_device *ff; unsigned int repeat_key; struct timer_list timer; int rep[REP_CNT]; struct input_mt *mt; struct input_absinfo *absinfo; unsigned long key[BITS_TO_LONGS(KEY_CNT)]; unsigned long led[BITS_TO_LONGS(LED_CNT)]; unsigned long snd[BITS_TO_LONGS(SND_CNT)]; unsigned long sw[BITS_TO_LONGS(SW_CNT)]; int (*open)(struct input_dev *dev); void (*close)(struct input_dev *dev); int (*flush)(struct input_dev *dev, struct file *file); int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value); struct input_handle __rcu *grab; spinlock_t event_lock; struct mutex mutex; unsigned int users; bool going_away; struct device dev; struct list_head h_list; struct list_head node; unsigned int num_vals; unsigned int max_vals; struct input_value *vals; bool devres_managed;&#125;;#define to_input_dev(d) container_of(d, struct input_dev, dev) input_handler1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * struct input_handler - implements one of interfaces for input devices * @private: driver-specific data * @event: event handler. This method is being called by input core with * interrupts disabled and dev-&gt;event_lock spinlock held and so * it may not sleep * @events: event sequence handler. This method is being called by * input core with interrupts disabled and dev-&gt;event_lock * spinlock held and so it may not sleep * @filter: similar to @event; separates normal event handlers from * &quot;filters&quot;. * @match: called after comparing device&apos;s id with handler&apos;s id_table * to perform fine-grained matching between device and handler * @connect: called when attaching a handler to an input device * @disconnect: disconnects a handler from input device * @start: starts handler for given handle. This function is called by * input core right after connect() method and also when a process * that &quot;grabbed&quot; a device releases it * @legacy_minors: set to %true by drivers using legacy minor ranges * @minor: beginning of range of 32 legacy minors for devices this driver * can provide * @name: name of the handler, to be shown in /proc/bus/input/handlers * @id_table: pointer to a table of input_device_ids this driver can * handle * @h_list: list of input handles associated with the handler * @node: for placing the driver onto input_handler_list * * Input handlers attach to input devices and create input handles. There * are likely several handlers attached to any given input device at the * same time. All of them will get their copy of input event generated by * the device. * * The very same structure is used to implement input filters. Input core * allows filters to run first and will not pass event to regular handlers * if any of the filters indicate that the event should be filtered (by * returning %true from their filter() method). * * Note that input core serializes calls to connect() and disconnect() * methods. */struct input_handler &#123; void *private; void (*event)(struct input_handle *handle, unsigned int type, unsigned int code, int value); void (*events)(struct input_handle *handle, const struct input_value *vals, unsigned int count); bool (*filter)(struct input_handle *handle, unsigned int type, unsigned int code, int value); bool (*match)(struct input_handler *handler, struct input_dev *dev); int (*connect)(struct input_handler *handler, struct input_dev *dev, const struct input_device_id *id); void (*disconnect)(struct input_handle *handle); void (*start)(struct input_handle *handle); bool legacy_minors; int minor; const char *name; const struct input_device_id *id_table; struct list_head h_list; struct list_head node;&#125;; 以下是inputcore的源码，我们需要着重关注，进行了中文注释的部分， 以及 register_input_device、register_input_handler、attach_to_handler、input_handle_event等几个关键操作：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221122212231224122512261227122812291230123112321233123412351236123712381239124012411242124312441245124612471248124912501251125212531254125512561257125812591260126112621263126412651266126712681269127012711272127312741275127612771278127912801281128212831284128512861287128812891290129112921293129412951296129712981299130013011302130313041305130613071308130913101311131213131314131513161317131813191320132113221323132413251326132713281329133013311332133313341335133613371338133913401341134213431344134513461347134813491350135113521353135413551356135713581359136013611362136313641365136613671368136913701371137213731374137513761377137813791380138113821383138413851386138713881389139013911392139313941395139613971398139914001401140214031404140514061407140814091410141114121413141414151416141714181419142014211422142314241425142614271428142914301431143214331434143514361437143814391440144114421443144414451446144714481449145014511452145314541455145614571458145914601461146214631464146514661467146814691470147114721473147414751476147714781479148014811482148314841485148614871488148914901491149214931494149514961497149814991500150115021503150415051506150715081509151015111512151315141515151615171518151915201521152215231524152515261527152815291530153115321533153415351536153715381539154015411542154315441545154615471548154915501551155215531554155515561557155815591560156115621563156415651566156715681569157015711572157315741575157615771578157915801581158215831584158515861587158815891590159115921593159415951596159715981599160016011602160316041605160616071608160916101611161216131614161516161617161816191620162116221623162416251626162716281629163016311632163316341635163616371638163916401641164216431644164516461647164816491650165116521653165416551656165716581659166016611662166316641665166616671668166916701671167216731674167516761677167816791680168116821683168416851686168716881689169016911692169316941695169616971698169917001701170217031704170517061707170817091710171117121713171417151716171717181719172017211722172317241725172617271728172917301731173217331734173517361737173817391740174117421743174417451746174717481749175017511752175317541755175617571758175917601761176217631764176517661767176817691770177117721773177417751776177717781779178017811782178317841785178617871788178917901791179217931794179517961797179817991800180118021803180418051806180718081809181018111812181318141815181618171818181918201821182218231824182518261827182818291830183118321833183418351836183718381839184018411842184318441845184618471848184918501851185218531854185518561857185818591860186118621863186418651866186718681869187018711872187318741875187618771878187918801881188218831884188518861887188818891890189118921893189418951896189718981899190019011902190319041905190619071908190919101911191219131914191519161917191819191920192119221923192419251926192719281929193019311932193319341935193619371938193919401941194219431944194519461947194819491950195119521953195419551956195719581959196019611962196319641965196619671968196919701971197219731974197519761977197819791980198119821983198419851986198719881989199019911992199319941995199619971998199920002001200220032004200520062007200820092010201120122013201420152016201720182019202020212022202320242025202620272028202920302031203220332034203520362037203820392040204120422043204420452046204720482049205020512052205320542055205620572058205920602061206220632064206520662067206820692070207120722073207420752076207720782079208020812082208320842085208620872088208920902091209220932094209520962097209820992100210121022103210421052106210721082109211021112112211321142115211621172118211921202121212221232124212521262127212821292130213121322133213421352136213721382139214021412142214321442145214621472148214921502151215221532154215521562157215821592160216121622163216421652166216721682169217021712172217321742175217621772178217921802181218221832184218521862187218821892190219121922193219421952196219721982199220022012202220322042205220622072208220922102211221222132214221522162217221822192220222122222223222422252226222722282229223022312232223322342235223622372238223922402241224222432244224522462247224822492250225122522253225422552256225722582259226022612262226322642265226622672268226922702271227222732274227522762277227822792280228122822283228422852286228722882289229022912292229322942295229622972298229923002301230223032304230523062307230823092310231123122313231423152316231723182319232023212322232323242325232623272328232923302331233223332334233523362337233823392340234123422343234423452346234723482349235023512352235323542355235623572358235923602361236223632364236523662367236823692370237123722373237423752376237723782379238023812382238323842385238623872388238923902391239223932394239523962397239823992400240124022403240424052406240724082409241024112412241324142415241624172418241924202421242224232424242524262427242824292430243124322433243424352436243724382439244024412442244324442445244624472448244924502451245224532454245524562457245824592460246124622463246424652466246724682469247024712472247324742475247624772478247924802481248224832484248524862487248824892490249124922493/* * The input core * * Copyright (c) 1999-2002 Vojtech Pavlik *//* * This program is free software; you can redistribute it and/or modify it * under the terms of the GNU General Public License version 2 as published by * the Free Software Foundation. */#define pr_fmt(fmt) KBUILD_BASENAME &quot;: &quot; fmt#include &lt;linux/init.h&gt;#include &lt;linux/types.h&gt;#include &lt;linux/idr.h&gt;#include &lt;linux/input/mt.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/random.h&gt;#include &lt;linux/major.h&gt;#include &lt;linux/proc_fs.h&gt;#include &lt;linux/sched.h&gt;#include &lt;linux/seq_file.h&gt;#include &lt;linux/poll.h&gt;#include &lt;linux/device.h&gt;#include &lt;linux/mutex.h&gt;#include &lt;linux/rcupdate.h&gt;#include &quot;input-compat.h&quot;MODULE_AUTHOR(&quot;Vojtech Pavlik &lt;vojtech@suse.cz&gt;&quot;);MODULE_DESCRIPTION(&quot;Input core&quot;);MODULE_LICENSE(&quot;GPL&quot;);#define INPUT_MAX_CHAR_DEVICES 1024#define INPUT_FIRST_DYNAMIC_DEV 256static DEFINE_IDA(input_ida);static LIST_HEAD(input_dev_list); //初始化设备列表static LIST_HEAD(input_handler_list); //初始化handler列表/* * input_mutex protects access to both input_dev_list and input_handler_list. * This also causes input_[un]register_device and input_[un]register_handler * be mutually exclusive which simplifies locking in drivers implementing * input handlers. */static DEFINE_MUTEX(input_mutex); //在 input_[un]register_device input_[un]register_handler 起保护作用static const struct input_value input_value_sync = &#123; EV_SYN, SYN_REPORT, 1 &#125;;static inline int is_event_supported(unsigned int code, unsigned long *bm, unsigned int max)&#123; return code &lt;= max &amp;&amp; test_bit(code, bm); //没超过事件的最大值，并且 1 &lt;&lt; code &amp; *bm != 0&#125;//模糊绝对坐标static int input_defuzz_abs_event(int value, int old_val, int fuzz)&#123; if (fuzz) &#123; if (value &gt; old_val - fuzz / 2 &amp;&amp; value &lt; old_val + fuzz / 2) return old_val; if (value &gt; old_val - fuzz &amp;&amp; value &lt; old_val + fuzz) return (old_val * 3 + value) / 4; if (value &gt; old_val - fuzz * 2 &amp;&amp; value &lt; old_val + fuzz * 2) return (old_val + value) / 2; &#125; return value;&#125;//自动重复做某一事件码,在设备驱动中我们可以调用此借口使核心层定时上传event,而不用在设备驱动中使用定时器static void input_start_autorepeat(struct input_dev *dev, int code)&#123; if (test_bit(EV_REP, dev-&gt;evbit) &amp;&amp; dev-&gt;rep[REP_PERIOD] &amp;&amp; dev-&gt;rep[REP_DELAY] &amp;&amp; dev-&gt;timer.data) &#123; dev-&gt;repeat_key = code; mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(dev-&gt;rep[REP_DELAY])); //ms转jiffies &#125;&#125;//停止自动重复static void input_stop_autorepeat(struct input_dev *dev)&#123; del_timer(&amp;dev-&gt;timer);&#125;/* * Pass event first through all filters and then, if event has not been * filtered out, through all open handles. This function is called with * dev-&gt;event_lock held and interrupts disabled. *///由input得到对应的handler，怎么得到呢？就是查看由所有handler的filter函数决定，//如果某一个handler能够处理某一类型的event 和 codestatic unsigned int input_to_handler(struct input_handle *handle, struct input_value *vals, unsigned int count)&#123; struct input_handler *handler = handle-&gt;handler; struct input_value *end = vals; struct input_value *v; if (handler-&gt;filter) &#123; for (v = vals; v != vals + count; v++) &#123; if (handler-&gt;filter(handle, v-&gt;type, v-&gt;code, v-&gt;value)) continue; if (end != v) *end = *v; end++; //如果上面有一个通过-continue,那么 count = 0;,直接返回0 &#125; count = end - vals; &#125; if (!count) return 0; //如果handler函数实现的序列处理，那么就调用序列处理，否则以一个调用event if (handler-&gt;events) handler-&gt;events(handle, vals, count); else if (handler-&gt;event) for (v = vals; v != vals + count; v++) handler-&gt;event(handle, v-&gt;type, v-&gt;code, v-&gt;value); return count;&#125;/* * Pass values first through all filters and then, if event has not been * filtered out, through all open handles. This function is called with * dev-&gt;event_lock held and interrupts disabled. *///上传某一个值的时候，需要先通过所有的filterstatic void input_pass_values(struct input_dev *dev, struct input_value *vals, unsigned int count)&#123; struct input_handle *handle; struct input_value *v; if (!count) return; rcu_read_lock(); handle = rcu_dereference(dev-&gt;grab); if (handle) &#123; //如果传入参数指定了handl,那么就传人指定的handle，否则在列表中一个个尝试 count = input_to_handler(handle, vals, count); &#125; else &#123; list_for_each_entry_rcu(handle, &amp;dev-&gt;h_list, d_node) if (handle-&gt;open) &#123; count = input_to_handler(handle, vals, count); if (!count) break; &#125; &#125; rcu_read_unlock(); /* trigger auto repeat for key events */ //如果该设备设置了重复位，就启动重复上传 if (test_bit(EV_REP, dev-&gt;evbit) &amp;&amp; test_bit(EV_KEY, dev-&gt;evbit)) &#123; for (v = vals; v != vals + count; v++) &#123; if (v-&gt;type == EV_KEY &amp;&amp; v-&gt;value != 2) &#123; if (v-&gt;value) input_start_autorepeat(dev, v-&gt;code); else input_stop_autorepeat(dev); &#125; &#125; &#125;&#125;static void input_pass_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)&#123; struct input_value vals[] = &#123; &#123; type, code, value &#125; &#125;; input_pass_values(dev, vals, ARRAY_SIZE(vals));&#125;/* * Generate software autorepeat event. Note that we take * dev-&gt;event_lock here to avoid racing with input_event * which may cause keys get &quot;stuck&quot;. *///重复上传事件的具体实现函数，在上传事件后，修改定时器//前面的auto_repeat_start只是启动了重复上传的定时器，并没有上传具体事件（值）//注意在这里会使用自旋锁防止竞争static void input_repeat_key(unsigned long data)&#123; struct input_dev *dev = (void *) data; unsigned long flags; spin_lock_irqsave(&amp;dev-&gt;event_lock, flags); //在得到锁之后会保存中断信息 if (test_bit(dev-&gt;repeat_key, dev-&gt;key) &amp;&amp; is_event_supported(dev-&gt;repeat_key, dev-&gt;keybit, KEY_MAX)) &#123; struct input_value vals[] = &#123; &#123; EV_KEY, dev-&gt;repeat_key, 2 &#125;, input_value_sync &#125;; input_pass_values(dev, vals, ARRAY_SIZE(vals)); if (dev-&gt;rep[REP_PERIOD]) mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(dev-&gt;rep[REP_PERIOD])); &#125; spin_unlock_irqrestore(&amp;dev-&gt;event_lock, flags); //还原中断信息，为的是在得到锁的期间的其他输入在之后能够接着被处理&#125;#define INPUT_IGNORE_EVENT 0#define INPUT_PASS_TO_HANDLERS 1#define INPUT_PASS_TO_DEVICE 2#define INPUT_SLOT 4#define INPUT_FLUSH 8#define INPUT_PASS_TO_ALL (INPUT_PASS_TO_HANDLERS | INPUT_PASS_TO_DEVICE)//ABS事件的处理函数，在input_get_disposition函数中根据事件类型进行调用，//在该函数中并没有与handler进行交互static int input_handle_abs_event(struct input_dev *dev, unsigned int code, int *pval)&#123; struct input_mt *mt = dev-&gt;mt; bool is_mt_event; int *pold; if (code == ABS_MT_SLOT) &#123; /* * &quot;Stage&quot; the event; we&apos;ll flush it later, when we * get actual touch data. */ if (mt &amp;&amp; *pval &gt;= 0 &amp;&amp; *pval &lt; mt-&gt;num_slots) mt-&gt;slot = *pval; return INPUT_IGNORE_EVENT; &#125; is_mt_event = input_is_mt_value(code); if (!is_mt_event) &#123; pold = &amp;dev-&gt;absinfo[code].value; &#125; else if (mt) &#123; pold = &amp;mt-&gt;slots[mt-&gt;slot].abs[code - ABS_MT_FIRST]; &#125; else &#123; /* * Bypass filtering for multi-touch events when * not employing slots. */ pold = NULL; &#125; if (pold) &#123; *pval = input_defuzz_abs_event(*pval, *pold, dev-&gt;absinfo[code].fuzz); if (*pold == *pval) return INPUT_IGNORE_EVENT; *pold = *pval; &#125; /* Flush pending &quot;slot&quot; event */ if (is_mt_event &amp;&amp; mt &amp;&amp; mt-&gt;slot != input_abs_get_val(dev, ABS_MT_SLOT)) &#123; input_abs_set_val(dev, ABS_MT_SLOT, mt-&gt;slot); return INPUT_PASS_TO_HANDLERS | INPUT_SLOT; &#125; return INPUT_PASS_TO_HANDLERS;&#125;//得到事件要发送的目的地static int input_get_disposition(struct input_dev *dev, unsigned int type, unsigned int code, int *pval)&#123; int disposition = INPUT_IGNORE_EVENT; int value = *pval; switch (type) &#123; case EV_SYN: switch (code) &#123; case SYN_CONFIG: disposition = INPUT_PASS_TO_ALL; break; case SYN_REPORT: disposition = INPUT_PASS_TO_HANDLERS | INPUT_FLUSH; break; case SYN_MT_REPORT: disposition = INPUT_PASS_TO_HANDLERS; break; &#125; break; case EV_KEY: if (is_event_supported(code, dev-&gt;keybit, KEY_MAX)) &#123; /* auto-repeat bypasses state updates */ //按键事件值不是2的时候，就直接传送给所有的handler if (value == 2) &#123; disposition = INPUT_PASS_TO_HANDLERS; break; &#125; //不是2时，进行相应转换，即 value转换为 1&lt;&lt;value， //在设备驱动层与handler的值表示方法有差异， n = 1&lt;&lt;n if (!!test_bit(code, dev-&gt;key) != !!value) &#123; __change_bit(code, dev-&gt;key); disposition = INPUT_PASS_TO_HANDLERS; &#125; &#125; break; case EV_SW: if (is_event_supported(code, dev-&gt;swbit, SW_MAX) &amp;&amp; !!test_bit(code, dev-&gt;sw) != !!value) &#123; __change_bit(code, dev-&gt;sw); disposition = INPUT_PASS_TO_HANDLERS; &#125; break; case EV_ABS: if (is_event_supported(code, dev-&gt;absbit, ABS_MAX)) disposition = input_handle_abs_event(dev, code, &amp;value); break; case EV_REL: if (is_event_supported(code, dev-&gt;relbit, REL_MAX) &amp;&amp; value) disposition = INPUT_PASS_TO_HANDLERS; break; case EV_MSC: if (is_event_supported(code, dev-&gt;mscbit, MSC_MAX)) disposition = INPUT_PASS_TO_ALL; break; case EV_LED: if (is_event_supported(code, dev-&gt;ledbit, LED_MAX) &amp;&amp; !!test_bit(code, dev-&gt;led) != !!value) &#123; __change_bit(code, dev-&gt;led); disposition = INPUT_PASS_TO_ALL; &#125; break; case EV_SND: if (is_event_supported(code, dev-&gt;sndbit, SND_MAX)) &#123; if (!!test_bit(code, dev-&gt;snd) != !!value) __change_bit(code, dev-&gt;snd); disposition = INPUT_PASS_TO_ALL; &#125; break; case EV_REP: if (code &lt;= REP_MAX &amp;&amp; value &gt;= 0 &amp;&amp; dev-&gt;rep[code] != value) &#123; dev-&gt;rep[code] = value; disposition = INPUT_PASS_TO_ALL; &#125; break; case EV_FF: if (value &gt;= 0) disposition = INPUT_PASS_TO_ALL; break; case EV_PWR: disposition = INPUT_PASS_TO_ALL; break; &#125; *pval = value; return disposition;&#125;/******************************************************************************///该函数为核心层事件处理的核心函数，依据 设备 事件类型 事件值 进行相应的上传static void input_handle_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)&#123; int disposition = input_get_disposition(dev, type, code, &amp;value); if (disposition != INPUT_IGNORE_EVENT &amp;&amp; type != EV_SYN) add_input_randomness(type, code, value); if ((disposition &amp; INPUT_PASS_TO_DEVICE) &amp;&amp; dev-&gt;event) dev-&gt;event(dev, type, code, value); if (!dev-&gt;vals) return; //传送给handler的事件处理 if (disposition &amp; INPUT_PASS_TO_HANDLERS) &#123; struct input_value *v; if (disposition &amp; INPUT_SLOT) &#123; v = &amp;dev-&gt;vals[dev-&gt;num_vals++]; v-&gt;type = EV_ABS; v-&gt;code = ABS_MT_SLOT; v-&gt;value = dev-&gt;mt-&gt;slot; &#125; v = &amp;dev-&gt;vals[dev-&gt;num_vals++]; v-&gt;type = type; v-&gt;code = code; v-&gt;value = value; &#125; if (disposition &amp; INPUT_FLUSH) &#123; if (dev-&gt;num_vals &gt;= 2) input_pass_values(dev, dev-&gt;vals, dev-&gt;num_vals); dev-&gt;num_vals = 0; &#125; else if (dev-&gt;num_vals &gt;= dev-&gt;max_vals - 2) &#123; dev-&gt;vals[dev-&gt;num_vals++] = input_value_sync; input_pass_values(dev, dev-&gt;vals, dev-&gt;num_vals); dev-&gt;num_vals = 0; &#125;&#125;/** * input_event() - report new input event * @dev: device that generated the event * @type: type of the event * @code: event code * @value: value of the event * * This function should be used by drivers implementing various input * devices to report input events. See also input_inject_event(). * * NOTE: input_event() may be safely used right after input device was * allocated with input_allocate_device(), even before it is registered * with input_register_device(), but the event will not reach any of the * input handlers. Such early invocation of input_event() may be used * to &apos;seed&apos; initial state of a switch or initial position of absolute * axis, etc. *///调用上一个函数，只不过加了自旋锁保护，同时也是一个对外的接口void input_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)&#123; unsigned long flags; if (is_event_supported(type, dev-&gt;evbit, EV_MAX)) &#123; spin_lock_irqsave(&amp;dev-&gt;event_lock, flags); input_handle_event(dev, type, code, value); spin_unlock_irqrestore(&amp;dev-&gt;event_lock, flags); &#125;&#125;EXPORT_SYMBOL(input_event);/** * input_inject_event() - send input event from input handler * @handle: input handle to send event through * @type: type of the event * @code: event code * @value: value of the event * * Similar to input_event() but will ignore event if device is * &quot;grabbed&quot; and handle injecting event is not the one that owns * the device. *///这个是handler调用的事件处理接口，当某一个handler不能处理上传给它的一个事件时、//可以调用这个接口，进行反馈void input_inject_event(struct input_handle *handle, unsigned int type, unsigned int code, int value)&#123; struct input_dev *dev = handle-&gt;dev; struct input_handle *grab; unsigned long flags; if (is_event_supported(type, dev-&gt;evbit, EV_MAX)) &#123; spin_lock_irqsave(&amp;dev-&gt;event_lock, flags); rcu_read_lock(); grab = rcu_dereference(dev-&gt;grab); if (!grab || grab == handle) input_handle_event(dev, type, code, value); rcu_read_unlock(); spin_unlock_irqrestore(&amp;dev-&gt;event_lock, flags); &#125;&#125;EXPORT_SYMBOL(input_inject_event);/** * input_alloc_absinfo - allocates array of input_absinfo structs * @dev: the input device emitting absolute events * * If the absinfo struct the caller asked for is already allocated, this * functions will not do anything. *///为abs事件分配 abs_info结构体//在input_set_abs_params中调用，这也就意味着如果你有ABS事件，那么你需要调用set_params接口void input_alloc_absinfo(struct input_dev *dev)&#123; if (!dev-&gt;absinfo) dev-&gt;absinfo = kcalloc(ABS_CNT, sizeof(*dev-&gt;absinfo), GFP_KERNEL); WARN(!dev-&gt;absinfo, &quot;%s(): kcalloc() failed?\\n&quot;, __func__);&#125;EXPORT_SYMBOL(input_alloc_absinfo);void input_set_abs_params(struct input_dev *dev, unsigned int axis, int min, int max, int fuzz, int flat)&#123; struct input_absinfo *absinfo; input_alloc_absinfo(dev); if (!dev-&gt;absinfo) return; absinfo = &amp;dev-&gt;absinfo[axis]; absinfo-&gt;minimum = min; absinfo-&gt;maximum = max; absinfo-&gt;fuzz = fuzz; absinfo-&gt;flat = flat; __set_bit(EV_ABS, dev-&gt;evbit); __set_bit(axis, dev-&gt;absbit);&#125;EXPORT_SYMBOL(input_set_abs_params);/** * input_grab_device - grabs device for exclusive use * @handle: input handle that wants to own the device * * When a device is grabbed by an input handle all events generated by * the device are delivered only to this handle. Also events injected * by other input handles are ignored while device is grabbed. *///得到某个设备做排他使用，即如果某个handler得到了某个设备，那么这个设备产生的所有事件将只发送给这一个handlerint input_grab_device(struct input_handle *handle)&#123; struct input_dev *dev = handle-&gt;dev; int retval; retval = mutex_lock_interruptible(&amp;dev-&gt;mutex); if (retval) return retval; if (dev-&gt;grab) &#123; retval = -EBUSY; goto out; &#125; rcu_assign_pointer(dev-&gt;grab, handle); out: mutex_unlock(&amp;dev-&gt;mutex); return retval;&#125;EXPORT_SYMBOL(input_grab_device);//释放独占设备static void __input_release_device(struct input_handle *handle)&#123; struct input_dev *dev = handle-&gt;dev; struct input_handle *grabber; grabber = rcu_dereference_protected(dev-&gt;grab, lockdep_is_held(&amp;dev-&gt;mutex)); if (grabber == handle) &#123; rcu_assign_pointer(dev-&gt;grab, NULL); /* Make sure input_pass_event() notices that grab is gone */ synchronize_rcu(); list_for_each_entry(handle, &amp;dev-&gt;h_list, d_node) if (handle-&gt;open &amp;&amp; handle-&gt;handler-&gt;start) handle-&gt;handler-&gt;start(handle); &#125;&#125;/** * input_release_device - release previously grabbed device * @handle: input handle that owns the device * * Releases previously grabbed device so that other input handles can * start receiving input events. Upon release all handlers attached * to the device have their start() method called so they have a change * to synchronize device state with the rest of the system. */void input_release_device(struct input_handle *handle)&#123; struct input_dev *dev = handle-&gt;dev; mutex_lock(&amp;dev-&gt;mutex); __input_release_device(handle); mutex_unlock(&amp;dev-&gt;mutex);&#125;EXPORT_SYMBOL(input_release_device);/** * input_open_device - open input device * @handle: handle through which device is being accessed * * This function should be called by input handlers when they * want to start receive events from given input device. */int input_open_device(struct input_handle *handle)&#123; //得到传入handle的dev struct input_dev *dev = handle-&gt;dev; int retval; retval = mutex_lock_interruptible(&amp;dev-&gt;mutex); if (retval) return retval; if (dev-&gt;going_away) &#123; retval = -ENODEV; goto out; &#125; handle-&gt;open++; //调用对应dev-&gt;open打开设备， if (!dev-&gt;users++ &amp;&amp; dev-&gt;open) retval = dev-&gt;open(dev); if (retval) &#123; dev-&gt;users--; if (!--handle-&gt;open) &#123; /* * Make sure we are not delivering any more events * through this handle */ synchronize_rcu(); &#125; &#125; out: mutex_unlock(&amp;dev-&gt;mutex); return retval;&#125;EXPORT_SYMBOL(input_open_device);//就是调用对应的flush函数int input_flush_device(struct input_handle *handle, struct file *file)&#123; struct input_dev *dev = handle-&gt;dev; int retval; retval = mutex_lock_interruptible(&amp;dev-&gt;mutex); if (retval) return retval; if (dev-&gt;flush) retval = dev-&gt;flush(dev, file); mutex_unlock(&amp;dev-&gt;mutex); return retval;&#125;EXPORT_SYMBOL(input_flush_device);/** * input_close_device - close input device * @handle: handle through which device is being accessed * * This function should be called by input handlers when they * want to stop receive events from given input device. */void input_close_device(struct input_handle *handle)&#123; struct input_dev *dev = handle-&gt;dev; mutex_lock(&amp;dev-&gt;mutex); __input_release_device(handle); if (!--dev-&gt;users &amp;&amp; dev-&gt;close) dev-&gt;close(dev); if (!--handle-&gt;open) &#123; /* * synchronize_rcu() makes sure that input_pass_event() * completed and that no more input events are delivered * through this handle */ synchronize_rcu(); &#125; mutex_unlock(&amp;dev-&gt;mutex);&#125;EXPORT_SYMBOL(input_close_device);/* * Simulate keyup events for all keys that are marked as pressed. * The function must be called with dev-&gt;event_lock held. *///模拟一个释放按键的动作，比如handler要断开与设备的联系，但设备正在按键按下期间，那么可能导致驱动 “stuck&quot;static void input_dev_release_keys(struct input_dev *dev)&#123; bool need_sync = false; int code; if (is_event_supported(EV_KEY, dev-&gt;evbit, EV_MAX)) &#123; for_each_set_bit(code, dev-&gt;key, KEY_CNT) &#123; input_pass_event(dev, EV_KEY, code, 0); need_sync = true; &#125; if (need_sync) input_pass_event(dev, EV_SYN, SYN_REPORT, 1); memset(dev-&gt;key, 0, sizeof(dev-&gt;key)); &#125;&#125;/* * Prepare device for unregistering */static void input_disconnect_device(struct input_dev *dev)&#123; struct input_handle *handle; /* * Mark device as going away. Note that we take dev-&gt;mutex here * not to protect access to dev-&gt;going_away but rather to ensure * that there are no threads in the middle of input_open_device() */ mutex_lock(&amp;dev-&gt;mutex); dev-&gt;going_away = true; mutex_unlock(&amp;dev-&gt;mutex); spin_lock_irq(&amp;dev-&gt;event_lock); /* * Simulate keyup events for all pressed keys so that handlers * are not left with &quot;stuck&quot; keys. The driver may continue * generate events even after we done here but they will not * reach any handlers. */ input_dev_release_keys(dev); list_for_each_entry(handle, &amp;dev-&gt;h_list, d_node) handle-&gt;open = 0; spin_unlock_irq(&amp;dev-&gt;event_lock);&#125;/** * input_scancode_to_scalar() - converts scancode in &amp;struct input_keymap_entry * @ke: keymap entry containing scancode to be converted. * @scancode: pointer to the location where converted scancode should * be stored. * * This function is used to convert scancode stored in &amp;struct keymap_entry * into scalar form understood by legacy keymap handling methods. These * methods expect scancodes to be represented as &apos;unsigned int&apos;. *///不同数据长度之间的转化//如设备驱动层用的是8位长度，但handler层使用的32位长度，那么就需要转换int input_scancode_to_scalar(const struct input_keymap_entry *ke, unsigned int *scancode)&#123; switch (ke-&gt;len) &#123; case 1: *scancode = *((u8 *)ke-&gt;scancode); break; case 2: *scancode = *((u16 *)ke-&gt;scancode); break; case 4: *scancode = *((u32 *)ke-&gt;scancode); break; default: return -EINVAL; &#125; return 0;&#125;EXPORT_SYMBOL(input_scancode_to_scalar);/* * Those routines handle the default case where no [gs]etkeycode() is * defined. In this case, an array indexed by the scancode is used. */static unsigned int input_fetch_keycode(struct input_dev *dev, unsigned int index)&#123; switch (dev-&gt;keycodesize) &#123; case 1: return ((u8 *)dev-&gt;keycode)[index]; case 2: return ((u16 *)dev-&gt;keycode)[index]; default: return ((u32 *)dev-&gt;keycode)[index]; &#125;&#125;static int input_default_getkeycode(struct input_dev *dev, struct input_keymap_entry *ke)&#123; unsigned int index; int error; if (!dev-&gt;keycodesize) return -EINVAL; if (ke-&gt;flags &amp; INPUT_KEYMAP_BY_INDEX) index = ke-&gt;index; else &#123; error = input_scancode_to_scalar(ke, &amp;index); if (error) return error; &#125; if (index &gt;= dev-&gt;keycodemax) return -EINVAL; ke-&gt;keycode = input_fetch_keycode(dev, index); ke-&gt;index = index; ke-&gt;len = sizeof(index); memcpy(ke-&gt;scancode, &amp;index, sizeof(index)); return 0;&#125;static int input_default_setkeycode(struct input_dev *dev, const struct input_keymap_entry *ke, unsigned int *old_keycode)&#123; unsigned int index; int error; int i; if (!dev-&gt;keycodesize) return -EINVAL; if (ke-&gt;flags &amp; INPUT_KEYMAP_BY_INDEX) &#123; index = ke-&gt;index; &#125; else &#123; error = input_scancode_to_scalar(ke, &amp;index); if (error) return error; &#125; if (index &gt;= dev-&gt;keycodemax) return -EINVAL; if (dev-&gt;keycodesize &lt; sizeof(ke-&gt;keycode) &amp;&amp; (ke-&gt;keycode &gt;&gt; (dev-&gt;keycodesize * 8))) return -EINVAL; switch (dev-&gt;keycodesize) &#123; case 1: &#123; u8 *k = (u8 *)dev-&gt;keycode; *old_keycode = k[index]; k[index] = ke-&gt;keycode; break; &#125; case 2: &#123; u16 *k = (u16 *)dev-&gt;keycode; *old_keycode = k[index]; k[index] = ke-&gt;keycode; break; &#125; default: &#123; u32 *k = (u32 *)dev-&gt;keycode; *old_keycode = k[index]; k[index] = ke-&gt;keycode; break; &#125; &#125; __clear_bit(*old_keycode, dev-&gt;keybit); __set_bit(ke-&gt;keycode, dev-&gt;keybit); for (i = 0; i &lt; dev-&gt;keycodemax; i++) &#123; if (input_fetch_keycode(dev, i) == *old_keycode) &#123; __set_bit(*old_keycode, dev-&gt;keybit); break; /* Setting the bit twice is useless, so break */ &#125; &#125; return 0;&#125;/** * input_get_keycode - retrieve keycode currently mapped to a given scancode * @dev: input device which keymap is being queried * @ke: keymap entry * * This function should be called by anyone interested in retrieving current * keymap. Presently evdev handlers use it. */int input_get_keycode(struct input_dev *dev, struct input_keymap_entry *ke)&#123; unsigned long flags; int retval; spin_lock_irqsave(&amp;dev-&gt;event_lock, flags); retval = dev-&gt;getkeycode(dev, ke); spin_unlock_irqrestore(&amp;dev-&gt;event_lock, flags); return retval;&#125;EXPORT_SYMBOL(input_get_keycode);/** * input_set_keycode - attribute a keycode to a given scancode * @dev: input device which keymap is being updated * @ke: new keymap entry * * This function should be called by anyone needing to update current * keymap. Presently keyboard and evdev handlers use it. */int input_set_keycode(struct input_dev *dev, const struct input_keymap_entry *ke)&#123; unsigned long flags; unsigned int old_keycode; int retval; if (ke-&gt;keycode &gt; KEY_MAX) return -EINVAL; spin_lock_irqsave(&amp;dev-&gt;event_lock, flags); retval = dev-&gt;setkeycode(dev, ke, &amp;old_keycode); if (retval) goto out; /* Make sure KEY_RESERVED did not get enabled. */ __clear_bit(KEY_RESERVED, dev-&gt;keybit); /* * Simulate keyup event if keycode is not present * in the keymap anymore */ if (test_bit(EV_KEY, dev-&gt;evbit) &amp;&amp; !is_event_supported(old_keycode, dev-&gt;keybit, KEY_MAX) &amp;&amp; __test_and_clear_bit(old_keycode, dev-&gt;key)) &#123; struct input_value vals[] = &#123; &#123; EV_KEY, old_keycode, 0 &#125;, input_value_sync &#125;; input_pass_values(dev, vals, ARRAY_SIZE(vals)); &#125; out: spin_unlock_irqrestore(&amp;dev-&gt;event_lock, flags); return retval;&#125;EXPORT_SYMBOL(input_set_keycode);//参数dev为设备驱动层的属性//input_device_id为handler的属性bool input_match_device_id(const struct input_dev *dev, const struct input_device_id *id)&#123; //先判断flag中是否设置了某一属性，如依据BUS VENDOR进行对比 if (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_BUS) if (id-&gt;bustype != dev-&gt;id.bustype) return false; if (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_VENDOR) if (id-&gt;vendor != dev-&gt;id.vendor) return false; if (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_PRODUCT) if (id-&gt;product != dev-&gt;id.product) return false; if (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_VERSION) if (id-&gt;version != dev-&gt;id.version) return false; //确认input_device中设置的事件是否是handler能处理的子集 if (!bitmap_subset(id-&gt;evbit, dev-&gt;evbit, EV_MAX) || !bitmap_subset(id-&gt;keybit, dev-&gt;keybit, KEY_MAX) || !bitmap_subset(id-&gt;relbit, dev-&gt;relbit, REL_MAX) || !bitmap_subset(id-&gt;absbit, dev-&gt;absbit, ABS_MAX) || !bitmap_subset(id-&gt;mscbit, dev-&gt;mscbit, MSC_MAX) || !bitmap_subset(id-&gt;ledbit, dev-&gt;ledbit, LED_MAX) || !bitmap_subset(id-&gt;sndbit, dev-&gt;sndbit, SND_MAX) || !bitmap_subset(id-&gt;ffbit, dev-&gt;ffbit, FF_MAX) || !bitmap_subset(id-&gt;swbit, dev-&gt;swbit, SW_MAX) || !bitmap_subset(id-&gt;propbit, dev-&gt;propbit, INPUT_PROP_MAX)) &#123; return false; &#125; return true;&#125;EXPORT_SYMBOL(input_match_device_id);static const struct input_device_id *input_match_device(struct input_handler *handler, struct input_dev *dev)&#123; const struct input_device_id *id; //依次将设备的与handler的Idtable进行对比 for (id = handler-&gt;id_table; id-&gt;flags || id-&gt;driver_info; id++) &#123; if (input_match_device_id(dev, id) &amp;&amp; (!handler-&gt;match || handler-&gt;match(handler, dev))) &#123; return id; &#125; &#125; return NULL;&#125;static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)&#123; const struct input_device_id *id; int error; id = input_match_device(handler, dev); if (!id) return -ENODEV; //对比通过后，通过connect建立联系 error = handler-&gt;connect(handler, dev, id); if (error &amp;&amp; error != -ENODEV) pr_err(&quot;failed to attach handler %s to device %s, error: %d\\n&quot;, handler-&gt;name, kobject_name(&amp;dev-&gt;dev.kobj), error); return error;&#125;#ifdef CONFIG_COMPATstatic int input_bits_to_string(char *buf, int buf_size, unsigned long bits, bool skip_empty)&#123; int len = 0; if (in_compat_syscall()) &#123; u32 dword = bits &gt;&gt; 32; if (dword || !skip_empty) len += snprintf(buf, buf_size, &quot;%x &quot;, dword); dword = bits &amp; 0xffffffffUL; if (dword || !skip_empty || len) len += snprintf(buf + len, max(buf_size - len, 0), &quot;%x&quot;, dword); &#125; else &#123; if (bits || !skip_empty) len += snprintf(buf, buf_size, &quot;%lx&quot;, bits); &#125; return len;&#125;#else /* !CONFIG_COMPAT */static int input_bits_to_string(char *buf, int buf_size, unsigned long bits, bool skip_empty)&#123; return bits || !skip_empty ? snprintf(buf, buf_size, &quot;%lx&quot;, bits) : 0;&#125;#endif#ifdef CONFIG_PROC_FSstatic struct proc_dir_entry *proc_bus_input_dir;static DECLARE_WAIT_QUEUE_HEAD(input_devices_poll_wait);static int input_devices_state;static inline void input_wakeup_procfs_readers(void)&#123; input_devices_state++; wake_up(&amp;input_devices_poll_wait);&#125;static unsigned int input_proc_devices_poll(struct file *file, poll_table *wait)&#123; poll_wait(file, &amp;input_devices_poll_wait, wait); if (file-&gt;f_version != input_devices_state) &#123; file-&gt;f_version = input_devices_state; return POLLIN | POLLRDNORM; &#125; return 0;&#125;union input_seq_state &#123; struct &#123; unsigned short pos; bool mutex_acquired; &#125;; void *p;&#125;;static void *input_devices_seq_start(struct seq_file *seq, loff_t *pos)&#123; union input_seq_state *state = (union input_seq_state *)&amp;seq-&gt;private; int error; /* We need to fit into seq-&gt;private pointer */ BUILD_BUG_ON(sizeof(union input_seq_state) != sizeof(seq-&gt;private)); error = mutex_lock_interruptible(&amp;input_mutex); if (error) &#123; state-&gt;mutex_acquired = false; return ERR_PTR(error); &#125; state-&gt;mutex_acquired = true; return seq_list_start(&amp;input_dev_list, *pos);&#125;static void *input_devices_seq_next(struct seq_file *seq, void *v, loff_t *pos)&#123; return seq_list_next(v, &amp;input_dev_list, pos);&#125;static void input_seq_stop(struct seq_file *seq, void *v)&#123; union input_seq_state *state = (union input_seq_state *)&amp;seq-&gt;private; if (state-&gt;mutex_acquired) mutex_unlock(&amp;input_mutex);&#125;static void input_seq_print_bitmap(struct seq_file *seq, const char *name, unsigned long *bitmap, int max)&#123; int i; bool skip_empty = true; char buf[18]; seq_printf(seq, &quot;B: %s=&quot;, name); for (i = BITS_TO_LONGS(max) - 1; i &gt;= 0; i--) &#123; if (input_bits_to_string(buf, sizeof(buf), bitmap[i], skip_empty)) &#123; skip_empty = false; seq_printf(seq, &quot;%s%s&quot;, buf, i &gt; 0 ? &quot; &quot; : &quot;&quot;); &#125; &#125; /* * If no output was produced print a single 0. */ if (skip_empty) seq_putc(seq, &apos;0&apos;); seq_putc(seq, &apos;\\n&apos;);&#125;static int input_devices_seq_show(struct seq_file *seq, void *v)&#123; struct input_dev *dev = container_of(v, struct input_dev, node); const char *path = kobject_get_path(&amp;dev-&gt;dev.kobj, GFP_KERNEL); struct input_handle *handle; seq_printf(seq, &quot;I: Bus=%04x Vendor=%04x Product=%04x Version=%04x\\n&quot;, dev-&gt;id.bustype, dev-&gt;id.vendor, dev-&gt;id.product, dev-&gt;id.version); seq_printf(seq, &quot;N: Name=\\&quot;%s\\&quot;\\n&quot;, dev-&gt;name ? dev-&gt;name : &quot;&quot;); seq_printf(seq, &quot;P: Phys=%s\\n&quot;, dev-&gt;phys ? dev-&gt;phys : &quot;&quot;); seq_printf(seq, &quot;S: Sysfs=%s\\n&quot;, path ? path : &quot;&quot;); seq_printf(seq, &quot;U: Uniq=%s\\n&quot;, dev-&gt;uniq ? dev-&gt;uniq : &quot;&quot;); seq_puts(seq, &quot;H: Handlers=&quot;); list_for_each_entry(handle, &amp;dev-&gt;h_list, d_node) seq_printf(seq, &quot;%s &quot;, handle-&gt;name); seq_putc(seq, &apos;\\n&apos;); input_seq_print_bitmap(seq, &quot;PROP&quot;, dev-&gt;propbit, INPUT_PROP_MAX); input_seq_print_bitmap(seq, &quot;EV&quot;, dev-&gt;evbit, EV_MAX); if (test_bit(EV_KEY, dev-&gt;evbit)) input_seq_print_bitmap(seq, &quot;KEY&quot;, dev-&gt;keybit, KEY_MAX); if (test_bit(EV_REL, dev-&gt;evbit)) input_seq_print_bitmap(seq, &quot;REL&quot;, dev-&gt;relbit, REL_MAX); if (test_bit(EV_ABS, dev-&gt;evbit)) input_seq_print_bitmap(seq, &quot;ABS&quot;, dev-&gt;absbit, ABS_MAX); if (test_bit(EV_MSC, dev-&gt;evbit)) input_seq_print_bitmap(seq, &quot;MSC&quot;, dev-&gt;mscbit, MSC_MAX); if (test_bit(EV_LED, dev-&gt;evbit)) input_seq_print_bitmap(seq, &quot;LED&quot;, dev-&gt;ledbit, LED_MAX); if (test_bit(EV_SND, dev-&gt;evbit)) input_seq_print_bitmap(seq, &quot;SND&quot;, dev-&gt;sndbit, SND_MAX); if (test_bit(EV_FF, dev-&gt;evbit)) input_seq_print_bitmap(seq, &quot;FF&quot;, dev-&gt;ffbit, FF_MAX); if (test_bit(EV_SW, dev-&gt;evbit)) input_seq_print_bitmap(seq, &quot;SW&quot;, dev-&gt;swbit, SW_MAX); seq_putc(seq, &apos;\\n&apos;); kfree(path); return 0;&#125;static const struct seq_operations input_devices_seq_ops = &#123; .start = input_devices_seq_start, .next = input_devices_seq_next, .stop = input_seq_stop, .show = input_devices_seq_show,&#125;;static int input_proc_devices_open(struct inode *inode, struct file *file)&#123; return seq_open(file, &amp;input_devices_seq_ops);&#125;static const struct file_operations input_devices_fileops = &#123; .owner = THIS_MODULE, .open = input_proc_devices_open, .poll = input_proc_devices_poll, .read = seq_read, .llseek = seq_lseek, .release = seq_release,&#125;;static void *input_handlers_seq_start(struct seq_file *seq, loff_t *pos)&#123; union input_seq_state *state = (union input_seq_state *)&amp;seq-&gt;private; int error; /* We need to fit into seq-&gt;private pointer */ BUILD_BUG_ON(sizeof(union input_seq_state) != sizeof(seq-&gt;private)); error = mutex_lock_interruptible(&amp;input_mutex); if (error) &#123; state-&gt;mutex_acquired = false; return ERR_PTR(error); &#125; state-&gt;mutex_acquired = true; state-&gt;pos = *pos; return seq_list_start(&amp;input_handler_list, *pos);&#125;static void *input_handlers_seq_next(struct seq_file *seq, void *v, loff_t *pos)&#123; union input_seq_state *state = (union input_seq_state *)&amp;seq-&gt;private; state-&gt;pos = *pos + 1; return seq_list_next(v, &amp;input_handler_list, pos);&#125;static int input_handlers_seq_show(struct seq_file *seq, void *v)&#123; struct input_handler *handler = container_of(v, struct input_handler, node); union input_seq_state *state = (union input_seq_state *)&amp;seq-&gt;private; seq_printf(seq, &quot;N: Number=%u Name=%s&quot;, state-&gt;pos, handler-&gt;name); if (handler-&gt;filter) seq_puts(seq, &quot; (filter)&quot;); if (handler-&gt;legacy_minors) seq_printf(seq, &quot; Minor=%d&quot;, handler-&gt;minor); seq_putc(seq, &apos;\\n&apos;); return 0;&#125;static const struct seq_operations input_handlers_seq_ops = &#123; .start = input_handlers_seq_start, .next = input_handlers_seq_next, .stop = input_seq_stop, .show = input_handlers_seq_show,&#125;;static int input_proc_handlers_open(struct inode *inode, struct file *file)&#123; return seq_open(file, &amp;input_handlers_seq_ops);&#125;static const struct file_operations input_handlers_fileops = &#123; .owner = THIS_MODULE, .open = input_proc_handlers_open, .read = seq_read, .llseek = seq_lseek, .release = seq_release,&#125;;static int __init input_proc_init(void)&#123; struct proc_dir_entry *entry; proc_bus_input_dir = proc_mkdir(&quot;bus/input&quot;, NULL); if (!proc_bus_input_dir) return -ENOMEM; entry = proc_create(&quot;devices&quot;, 0, proc_bus_input_dir, &amp;input_devices_fileops); if (!entry) goto fail1; entry = proc_create(&quot;handlers&quot;, 0, proc_bus_input_dir, &amp;input_handlers_fileops); if (!entry) goto fail2; return 0; fail2: remove_proc_entry(&quot;devices&quot;, proc_bus_input_dir); fail1: remove_proc_entry(&quot;bus/input&quot;, NULL); return -ENOMEM;&#125;static void input_proc_exit(void)&#123; remove_proc_entry(&quot;devices&quot;, proc_bus_input_dir); remove_proc_entry(&quot;handlers&quot;, proc_bus_input_dir); remove_proc_entry(&quot;bus/input&quot;, NULL);&#125;#else /* !CONFIG_PROC_FS */static inline void input_wakeup_procfs_readers(void) &#123; &#125;static inline int input_proc_init(void) &#123; return 0; &#125;static inline void input_proc_exit(void) &#123; &#125;#endif#define INPUT_DEV_STRING_ATTR_SHOW(name) \\static ssize_t input_dev_show_##name(struct device *dev, \\ struct device_attribute *attr, \\ char *buf) \\&#123; \\ struct input_dev *input_dev = to_input_dev(dev); \\ \\ return scnprintf(buf, PAGE_SIZE, &quot;%s\\n&quot;, \\ input_dev-&gt;name ? input_dev-&gt;name : &quot;&quot;); \\&#125; \\static DEVICE_ATTR(name, S_IRUGO, input_dev_show_##name, NULL)INPUT_DEV_STRING_ATTR_SHOW(name);INPUT_DEV_STRING_ATTR_SHOW(phys);INPUT_DEV_STRING_ATTR_SHOW(uniq);static int input_print_modalias_bits(char *buf, int size, char name, unsigned long *bm, unsigned int min_bit, unsigned int max_bit)&#123; int len = 0, i; len += snprintf(buf, max(size, 0), &quot;%c&quot;, name); for (i = min_bit; i &lt; max_bit; i++) if (bm[BIT_WORD(i)] &amp; BIT_MASK(i)) len += snprintf(buf + len, max(size - len, 0), &quot;%X,&quot;, i); return len;&#125;static int input_print_modalias(char *buf, int size, struct input_dev *id, int add_cr)&#123; int len; len = snprintf(buf, max(size, 0), &quot;input:b%04Xv%04Xp%04Xe%04X-&quot;, id-&gt;id.bustype, id-&gt;id.vendor, id-&gt;id.product, id-&gt;id.version); len += input_print_modalias_bits(buf + len, size - len, &apos;e&apos;, id-&gt;evbit, 0, EV_MAX); len += input_print_modalias_bits(buf + len, size - len, &apos;k&apos;, id-&gt;keybit, KEY_MIN_INTERESTING, KEY_MAX); len += input_print_modalias_bits(buf + len, size - len, &apos;r&apos;, id-&gt;relbit, 0, REL_MAX); len += input_print_modalias_bits(buf + len, size - len, &apos;a&apos;, id-&gt;absbit, 0, ABS_MAX); len += input_print_modalias_bits(buf + len, size - len, &apos;m&apos;, id-&gt;mscbit, 0, MSC_MAX); len += input_print_modalias_bits(buf + len, size - len, &apos;l&apos;, id-&gt;ledbit, 0, LED_MAX); len += input_print_modalias_bits(buf + len, size - len, &apos;s&apos;, id-&gt;sndbit, 0, SND_MAX); len += input_print_modalias_bits(buf + len, size - len, &apos;f&apos;, id-&gt;ffbit, 0, FF_MAX); len += input_print_modalias_bits(buf + len, size - len, &apos;w&apos;, id-&gt;swbit, 0, SW_MAX); if (add_cr) len += snprintf(buf + len, max(size - len, 0), &quot;\\n&quot;); return len;&#125;static ssize_t input_dev_show_modalias(struct device *dev, struct device_attribute *attr, char *buf)&#123; struct input_dev *id = to_input_dev(dev); ssize_t len; len = input_print_modalias(buf, PAGE_SIZE, id, 1); return min_t(int, len, PAGE_SIZE);&#125;static DEVICE_ATTR(modalias, S_IRUGO, input_dev_show_modalias, NULL);static int input_print_bitmap(char *buf, int buf_size, unsigned long *bitmap, int max, int add_cr);static ssize_t input_dev_show_properties(struct device *dev, struct device_attribute *attr, char *buf)&#123; struct input_dev *input_dev = to_input_dev(dev); int len = input_print_bitmap(buf, PAGE_SIZE, input_dev-&gt;propbit, INPUT_PROP_MAX, true); return min_t(int, len, PAGE_SIZE);&#125;static DEVICE_ATTR(properties, S_IRUGO, input_dev_show_properties, NULL);static struct attribute *input_dev_attrs[] = &#123; &amp;dev_attr_name.attr, &amp;dev_attr_phys.attr, &amp;dev_attr_uniq.attr, &amp;dev_attr_modalias.attr, &amp;dev_attr_properties.attr, NULL&#125;;static const struct attribute_group input_dev_attr_group = &#123; .attrs = input_dev_attrs,&#125;;#define INPUT_DEV_ID_ATTR(name) \\static ssize_t input_dev_show_id_##name(struct device *dev, \\ struct device_attribute *attr, \\ char *buf) \\&#123; \\ struct input_dev *input_dev = to_input_dev(dev); \\ return scnprintf(buf, PAGE_SIZE, &quot;%04x\\n&quot;, input_dev-&gt;id.name); \\&#125; \\static DEVICE_ATTR(name, S_IRUGO, input_dev_show_id_##name, NULL)INPUT_DEV_ID_ATTR(bustype);INPUT_DEV_ID_ATTR(vendor);INPUT_DEV_ID_ATTR(product);INPUT_DEV_ID_ATTR(version);static struct attribute *input_dev_id_attrs[] = &#123; &amp;dev_attr_bustype.attr, &amp;dev_attr_vendor.attr, &amp;dev_attr_product.attr, &amp;dev_attr_version.attr, NULL&#125;;static const struct attribute_group input_dev_id_attr_group = &#123; .name = &quot;id&quot;, .attrs = input_dev_id_attrs,&#125;;static int input_print_bitmap(char *buf, int buf_size, unsigned long *bitmap, int max, int add_cr)&#123; int i; int len = 0; bool skip_empty = true; for (i = BITS_TO_LONGS(max) - 1; i &gt;= 0; i--) &#123; len += input_bits_to_string(buf + len, max(buf_size - len, 0), bitmap[i], skip_empty); if (len) &#123; skip_empty = false; if (i &gt; 0) len += snprintf(buf + len, max(buf_size - len, 0), &quot; &quot;); &#125; &#125; /* * If no output was produced print a single 0. */ if (len == 0) len = snprintf(buf, buf_size, &quot;%d&quot;, 0); if (add_cr) len += snprintf(buf + len, max(buf_size - len, 0), &quot;\\n&quot;); return len;&#125;#define INPUT_DEV_CAP_ATTR(ev, bm) \\static ssize_t input_dev_show_cap_##bm(struct device *dev, \\ struct device_attribute *attr, \\ char *buf) \\&#123; \\ struct input_dev *input_dev = to_input_dev(dev); \\ int len = input_print_bitmap(buf, PAGE_SIZE, \\ input_dev-&gt;bm##bit, ev##_MAX, \\ true); \\ return min_t(int, len, PAGE_SIZE); \\&#125; \\static DEVICE_ATTR(bm, S_IRUGO, input_dev_show_cap_##bm, NULL)INPUT_DEV_CAP_ATTR(EV, ev);INPUT_DEV_CAP_ATTR(KEY, key);INPUT_DEV_CAP_ATTR(REL, rel);INPUT_DEV_CAP_ATTR(ABS, abs);INPUT_DEV_CAP_ATTR(MSC, msc);INPUT_DEV_CAP_ATTR(LED, led);INPUT_DEV_CAP_ATTR(SND, snd);INPUT_DEV_CAP_ATTR(FF, ff);INPUT_DEV_CAP_ATTR(SW, sw);static struct attribute *input_dev_caps_attrs[] = &#123; &amp;dev_attr_ev.attr, &amp;dev_attr_key.attr, &amp;dev_attr_rel.attr, &amp;dev_attr_abs.attr, &amp;dev_attr_msc.attr, &amp;dev_attr_led.attr, &amp;dev_attr_snd.attr, &amp;dev_attr_ff.attr, &amp;dev_attr_sw.attr, NULL&#125;;static const struct attribute_group input_dev_caps_attr_group = &#123; .name = &quot;capabilities&quot;, .attrs = input_dev_caps_attrs,&#125;;static const struct attribute_group *input_dev_attr_groups[] = &#123; &amp;input_dev_attr_group, &amp;input_dev_id_attr_group, &amp;input_dev_caps_attr_group, NULL&#125;;static void input_dev_release(struct device *device)&#123; struct input_dev *dev = to_input_dev(device); input_ff_destroy(dev); input_mt_destroy_slots(dev); kfree(dev-&gt;absinfo); kfree(dev-&gt;vals); kfree(dev); module_put(THIS_MODULE);&#125;/* * Input uevent interface - loading event handlers based on * device bitfields. */static int input_add_uevent_bm_var(struct kobj_uevent_env *env, const char *name, unsigned long *bitmap, int max)&#123; int len; if (add_uevent_var(env, &quot;%s&quot;, name)) return -ENOMEM; len = input_print_bitmap(&amp;env-&gt;buf[env-&gt;buflen - 1], sizeof(env-&gt;buf) - env-&gt;buflen, bitmap, max, false); if (len &gt;= (sizeof(env-&gt;buf) - env-&gt;buflen)) return -ENOMEM; env-&gt;buflen += len; return 0;&#125;static int input_add_uevent_modalias_var(struct kobj_uevent_env *env, struct input_dev *dev)&#123; int len; if (add_uevent_var(env, &quot;MODALIAS=&quot;)) return -ENOMEM; len = input_print_modalias(&amp;env-&gt;buf[env-&gt;buflen - 1], sizeof(env-&gt;buf) - env-&gt;buflen, dev, 0); if (len &gt;= (sizeof(env-&gt;buf) - env-&gt;buflen)) return -ENOMEM; env-&gt;buflen += len; return 0;&#125;#define INPUT_ADD_HOTPLUG_VAR(fmt, val...) \\ do &#123; \\ int err = add_uevent_var(env, fmt, val); \\ if (err) \\ return err; \\ &#125; while (0)#define INPUT_ADD_HOTPLUG_BM_VAR(name, bm, max) \\ do &#123; \\ int err = input_add_uevent_bm_var(env, name, bm, max); \\ if (err) \\ return err; \\ &#125; while (0)#define INPUT_ADD_HOTPLUG_MODALIAS_VAR(dev) \\ do &#123; \\ int err = input_add_uevent_modalias_var(env, dev); \\ if (err) \\ return err; \\ &#125; while (0)static int input_dev_uevent(struct device *device, struct kobj_uevent_env *env)&#123; struct input_dev *dev = to_input_dev(device); INPUT_ADD_HOTPLUG_VAR(&quot;PRODUCT=%x/%x/%x/%x&quot;, dev-&gt;id.bustype, dev-&gt;id.vendor, dev-&gt;id.product, dev-&gt;id.version); if (dev-&gt;name) INPUT_ADD_HOTPLUG_VAR(&quot;NAME=\\&quot;%s\\&quot;&quot;, dev-&gt;name); if (dev-&gt;phys) INPUT_ADD_HOTPLUG_VAR(&quot;PHYS=\\&quot;%s\\&quot;&quot;, dev-&gt;phys); if (dev-&gt;uniq) INPUT_ADD_HOTPLUG_VAR(&quot;UNIQ=\\&quot;%s\\&quot;&quot;, dev-&gt;uniq); INPUT_ADD_HOTPLUG_BM_VAR(&quot;PROP=&quot;, dev-&gt;propbit, INPUT_PROP_MAX); INPUT_ADD_HOTPLUG_BM_VAR(&quot;EV=&quot;, dev-&gt;evbit, EV_MAX); if (test_bit(EV_KEY, dev-&gt;evbit)) INPUT_ADD_HOTPLUG_BM_VAR(&quot;KEY=&quot;, dev-&gt;keybit, KEY_MAX); if (test_bit(EV_REL, dev-&gt;evbit)) INPUT_ADD_HOTPLUG_BM_VAR(&quot;REL=&quot;, dev-&gt;relbit, REL_MAX); if (test_bit(EV_ABS, dev-&gt;evbit)) INPUT_ADD_HOTPLUG_BM_VAR(&quot;ABS=&quot;, dev-&gt;absbit, ABS_MAX); if (test_bit(EV_MSC, dev-&gt;evbit)) INPUT_ADD_HOTPLUG_BM_VAR(&quot;MSC=&quot;, dev-&gt;mscbit, MSC_MAX); if (test_bit(EV_LED, dev-&gt;evbit)) INPUT_ADD_HOTPLUG_BM_VAR(&quot;LED=&quot;, dev-&gt;ledbit, LED_MAX); if (test_bit(EV_SND, dev-&gt;evbit)) INPUT_ADD_HOTPLUG_BM_VAR(&quot;SND=&quot;, dev-&gt;sndbit, SND_MAX); if (test_bit(EV_FF, dev-&gt;evbit)) INPUT_ADD_HOTPLUG_BM_VAR(&quot;FF=&quot;, dev-&gt;ffbit, FF_MAX); if (test_bit(EV_SW, dev-&gt;evbit)) INPUT_ADD_HOTPLUG_BM_VAR(&quot;SW=&quot;, dev-&gt;swbit, SW_MAX); INPUT_ADD_HOTPLUG_MODALIAS_VAR(dev); return 0;&#125;#define INPUT_DO_TOGGLE(dev, type, bits, on) \\ do &#123; \\ int i; \\ bool active; \\ \\ if (!test_bit(EV_##type, dev-&gt;evbit)) \\ break; \\ \\ for_each_set_bit(i, dev-&gt;bits##bit, type##_CNT) &#123; \\ active = test_bit(i, dev-&gt;bits); \\ if (!active &amp;&amp; !on) \\ continue; \\ \\ dev-&gt;event(dev, EV_##type, i, on ? active : 0); \\ &#125; \\ &#125; while (0)static void input_dev_toggle(struct input_dev *dev, bool activate)&#123; if (!dev-&gt;event) return; INPUT_DO_TOGGLE(dev, LED, led, activate); INPUT_DO_TOGGLE(dev, SND, snd, activate); if (activate &amp;&amp; test_bit(EV_REP, dev-&gt;evbit)) &#123; dev-&gt;event(dev, EV_REP, REP_PERIOD, dev-&gt;rep[REP_PERIOD]); dev-&gt;event(dev, EV_REP, REP_DELAY, dev-&gt;rep[REP_DELAY]); &#125;&#125;/** * input_reset_device() - reset/restore the state of input device * @dev: input device whose state needs to be reset * * This function tries to reset the state of an opened input device and * bring internal state and state if the hardware in sync with each other. * We mark all keys as released, restore LED state, repeat rate, etc. */void input_reset_device(struct input_dev *dev)&#123; unsigned long flags; mutex_lock(&amp;dev-&gt;mutex); spin_lock_irqsave(&amp;dev-&gt;event_lock, flags); input_dev_toggle(dev, true); input_dev_release_keys(dev); spin_unlock_irqrestore(&amp;dev-&gt;event_lock, flags); mutex_unlock(&amp;dev-&gt;mutex);&#125;EXPORT_SYMBOL(input_reset_device);#ifdef CONFIG_PM_SLEEPstatic int input_dev_suspend(struct device *dev)&#123; struct input_dev *input_dev = to_input_dev(dev); spin_lock_irq(&amp;input_dev-&gt;event_lock); /* * Keys that are pressed now are unlikely to be * still pressed when we resume. */ input_dev_release_keys(input_dev); /* Turn off LEDs and sounds, if any are active. */ input_dev_toggle(input_dev, false); spin_unlock_irq(&amp;input_dev-&gt;event_lock); return 0;&#125;static int input_dev_resume(struct device *dev)&#123; struct input_dev *input_dev = to_input_dev(dev); spin_lock_irq(&amp;input_dev-&gt;event_lock); /* Restore state of LEDs and sounds, if any were active. */ input_dev_toggle(input_dev, true); spin_unlock_irq(&amp;input_dev-&gt;event_lock); return 0;&#125;static int input_dev_freeze(struct device *dev)&#123; struct input_dev *input_dev = to_input_dev(dev); spin_lock_irq(&amp;input_dev-&gt;event_lock); /* * Keys that are pressed now are unlikely to be * still pressed when we resume. */ input_dev_release_keys(input_dev); spin_unlock_irq(&amp;input_dev-&gt;event_lock); return 0;&#125;static int input_dev_poweroff(struct device *dev)&#123; struct input_dev *input_dev = to_input_dev(dev); spin_lock_irq(&amp;input_dev-&gt;event_lock); /* Turn off LEDs and sounds, if any are active. */ input_dev_toggle(input_dev, false); spin_unlock_irq(&amp;input_dev-&gt;event_lock); return 0;&#125;static const struct dev_pm_ops input_dev_pm_ops = &#123; .suspend = input_dev_suspend, .resume = input_dev_resume, .freeze = input_dev_freeze, .poweroff = input_dev_poweroff, .restore = input_dev_resume,&#125;;#endif /* CONFIG_PM */static const struct device_type input_dev_type = &#123; .groups = input_dev_attr_groups, .release = input_dev_release, .uevent = input_dev_uevent,#ifdef CONFIG_PM_SLEEP .pm = &amp;input_dev_pm_ops,#endif&#125;;static char *input_devnode(struct device *dev, umode_t *mode)&#123; return kasprintf(GFP_KERNEL, &quot;input/%s&quot;, dev_name(dev));&#125;struct class input_class = &#123; .name = &quot;input&quot;, .devnode = input_devnode,&#125;;EXPORT_SYMBOL_GPL(input_class);/** * input_allocate_device - allocate memory for new input device * * Returns prepared struct input_dev or %NULL. * * NOTE: Use input_free_device() to free devices that have not been * registered; input_unregister_device() should be used for already * registered devices. */struct input_dev *input_allocate_device(void)&#123; static atomic_t input_no = ATOMIC_INIT(-1); struct input_dev *dev; dev = kzalloc(sizeof(*dev), GFP_KERNEL); if (dev) &#123; dev-&gt;dev.type = &amp;input_dev_type; dev-&gt;dev.class = &amp;input_class; device_initialize(&amp;dev-&gt;dev); mutex_init(&amp;dev-&gt;mutex); spin_lock_init(&amp;dev-&gt;event_lock); init_timer(&amp;dev-&gt;timer); INIT_LIST_HEAD(&amp;dev-&gt;h_list); INIT_LIST_HEAD(&amp;dev-&gt;node); dev_set_name(&amp;dev-&gt;dev, &quot;input%lu&quot;, (unsigned long)atomic_inc_return(&amp;input_no)); __module_get(THIS_MODULE); &#125; return dev;&#125;EXPORT_SYMBOL(input_allocate_device);struct input_devres &#123; struct input_dev *input;&#125;;static int devm_input_device_match(struct device *dev, void *res, void *data)&#123; struct input_devres *devres = res; return devres-&gt;input == data;&#125;static void devm_input_device_release(struct device *dev, void *res)&#123; struct input_devres *devres = res; struct input_dev *input = devres-&gt;input; dev_dbg(dev, &quot;%s: dropping reference to %s\\n&quot;, __func__, dev_name(&amp;input-&gt;dev)); input_put_device(input);&#125;/** * devm_input_allocate_device - allocate managed input device * @dev: device owning the input device being created * * Returns prepared struct input_dev or %NULL. * * Managed input devices do not need to be explicitly unregistered or * freed as it will be done automatically when owner device unbinds from * its driver (or binding fails). Once managed input device is allocated, * it is ready to be set up and registered in the same fashion as regular * input device. There are no special devm_input_device_[un]register() * variants, regular ones work with both managed and unmanaged devices, * should you need them. In most cases however, managed input device need * not be explicitly unregistered or freed. * * NOTE: the owner device is set up as parent of input device and users * should not override it. */struct input_dev *devm_input_allocate_device(struct device *dev)&#123; struct input_dev *input; struct input_devres *devres; devres = devres_alloc(devm_input_device_release, sizeof(*devres), GFP_KERNEL); if (!devres) return NULL; input = input_allocate_device(); if (!input) &#123; devres_free(devres); return NULL; &#125; input-&gt;dev.parent = dev; input-&gt;devres_managed = true; devres-&gt;input = input; devres_add(dev, devres); return input;&#125;EXPORT_SYMBOL(devm_input_allocate_device);/** * input_free_device - free memory occupied by input_dev structure * @dev: input device to free * * This function should only be used if input_register_device() * was not called yet or if it failed. Once device was registered * use input_unregister_device() and memory will be freed once last * reference to the device is dropped. * * Device should be allocated by input_allocate_device(). * * NOTE: If there are references to the input device then memory * will not be freed until last reference is dropped. */void input_free_device(struct input_dev *dev)&#123; if (dev) &#123; if (dev-&gt;devres_managed) WARN_ON(devres_destroy(dev-&gt;dev.parent, devm_input_device_release, devm_input_device_match, dev)); input_put_device(dev); &#125;&#125;EXPORT_SYMBOL(input_free_device);/** * input_set_capability - mark device as capable of a certain event * @dev: device that is capable of emitting or accepting event * @type: type of the event (EV_KEY, EV_REL, etc...) * @code: event code * * In addition to setting up corresponding bit in appropriate capability * bitmap the function also adjusts dev-&gt;evbit. */void input_set_capability(struct input_dev *dev, unsigned int type, unsigned int code)&#123; switch (type) &#123; case EV_KEY: __set_bit(code, dev-&gt;keybit); break; case EV_REL: __set_bit(code, dev-&gt;relbit); break; case EV_ABS: input_alloc_absinfo(dev); if (!dev-&gt;absinfo) return; __set_bit(code, dev-&gt;absbit); break; case EV_MSC: __set_bit(code, dev-&gt;mscbit); break; case EV_SW: __set_bit(code, dev-&gt;swbit); break; case EV_LED: __set_bit(code, dev-&gt;ledbit); break; case EV_SND: __set_bit(code, dev-&gt;sndbit); break; case EV_FF: __set_bit(code, dev-&gt;ffbit); break; case EV_PWR: /* do nothing */ break; default: pr_err(&quot;input_set_capability: unknown type %u (code %u)\\n&quot;, type, code); dump_stack(); return; &#125; __set_bit(type, dev-&gt;evbit);&#125;EXPORT_SYMBOL(input_set_capability);static unsigned int input_estimate_events_per_packet(struct input_dev *dev)&#123; int mt_slots; int i; unsigned int events; if (dev-&gt;mt) &#123; mt_slots = dev-&gt;mt-&gt;num_slots; &#125; else if (test_bit(ABS_MT_TRACKING_ID, dev-&gt;absbit)) &#123; mt_slots = dev-&gt;absinfo[ABS_MT_TRACKING_ID].maximum - dev-&gt;absinfo[ABS_MT_TRACKING_ID].minimum + 1, mt_slots = clamp(mt_slots, 2, 32); &#125; else if (test_bit(ABS_MT_POSITION_X, dev-&gt;absbit)) &#123; mt_slots = 2; &#125; else &#123; mt_slots = 0; &#125; events = mt_slots + 1; /* count SYN_MT_REPORT and SYN_REPORT */ if (test_bit(EV_ABS, dev-&gt;evbit)) for_each_set_bit(i, dev-&gt;absbit, ABS_CNT) events += input_is_mt_axis(i) ? mt_slots : 1; if (test_bit(EV_REL, dev-&gt;evbit)) events += bitmap_weight(dev-&gt;relbit, REL_CNT); /* Make room for KEY and MSC events */ events += 7; return events;&#125;#define INPUT_CLEANSE_BITMASK(dev, type, bits) \\ do &#123; \\ if (!test_bit(EV_##type, dev-&gt;evbit)) \\ memset(dev-&gt;bits##bit, 0, \\ sizeof(dev-&gt;bits##bit)); \\ &#125; while (0)static void input_cleanse_bitmasks(struct input_dev *dev)&#123; INPUT_CLEANSE_BITMASK(dev, KEY, key); INPUT_CLEANSE_BITMASK(dev, REL, rel); INPUT_CLEANSE_BITMASK(dev, ABS, abs); INPUT_CLEANSE_BITMASK(dev, MSC, msc); INPUT_CLEANSE_BITMASK(dev, LED, led); INPUT_CLEANSE_BITMASK(dev, SND, snd); INPUT_CLEANSE_BITMASK(dev, FF, ff); INPUT_CLEANSE_BITMASK(dev, SW, sw);&#125;static void __input_unregister_device(struct input_dev *dev)&#123; struct input_handle *handle, *next; input_disconnect_device(dev); mutex_lock(&amp;input_mutex); list_for_each_entry_safe(handle, next, &amp;dev-&gt;h_list, d_node) handle-&gt;handler-&gt;disconnect(handle); WARN_ON(!list_empty(&amp;dev-&gt;h_list)); del_timer_sync(&amp;dev-&gt;timer); list_del_init(&amp;dev-&gt;node); input_wakeup_procfs_readers(); mutex_unlock(&amp;input_mutex); device_del(&amp;dev-&gt;dev);&#125;static void devm_input_device_unregister(struct device *dev, void *res)&#123; struct input_devres *devres = res; struct input_dev *input = devres-&gt;input; dev_dbg(dev, &quot;%s: unregistering device %s\\n&quot;, __func__, dev_name(&amp;input-&gt;dev)); __input_unregister_device(input);&#125;/** * input_enable_softrepeat - enable software autorepeat * @dev: input device * @delay: repeat delay * @period: repeat period * * Enable software autorepeat on the input device. */void input_enable_softrepeat(struct input_dev *dev, int delay, int period)&#123; dev-&gt;timer.data = (unsigned long) dev; dev-&gt;timer.function = input_repeat_key; dev-&gt;rep[REP_DELAY] = delay; dev-&gt;rep[REP_PERIOD] = period;&#125;EXPORT_SYMBOL(input_enable_softrepeat);/** * input_register_device - register device with input core * @dev: device to be registered * * This function registers device with input core. The device must be * allocated with input_allocate_device() and all it&apos;s capabilities * set up before registering. * If function fails the device must be freed with input_free_device(). * Once device has been successfully registered it can be unregistered * with input_unregister_device(); input_free_device() should not be * called in this case. * * Note that this function is also used to register managed input devices * (ones allocated with devm_input_allocate_device()). Such managed input * devices need not be explicitly unregistered or freed, their tear down * is controlled by the devres infrastructure. It is also worth noting * that tear down of managed input devices is internally a 2-step process: * registered managed input device is first unregistered, but stays in * memory and can still handle input_event() calls (although events will * not be delivered anywhere). The freeing of managed input device will * happen later, when devres stack is unwound to the point where device * allocation was made. */int input_register_device(struct input_dev *dev)&#123; struct input_devres *devres = NULL; struct input_handler *handler; unsigned int packet_size; const char *path; int error; if (test_bit(EV_ABS, dev-&gt;evbit) &amp;&amp; !dev-&gt;absinfo) &#123; dev_err(&amp;dev-&gt;dev, &quot;Absolute device without dev-&gt;absinfo, refusing to register\\n&quot;); return -EINVAL; &#125; if (dev-&gt;devres_managed) &#123; devres = devres_alloc(devm_input_device_unregister, sizeof(*devres), GFP_KERNEL); if (!devres) return -ENOMEM; devres-&gt;input = dev; &#125; /* Every input device generates EV_SYN/SYN_REPORT events. */ __set_bit(EV_SYN, dev-&gt;evbit); /* KEY_RESERVED is not supposed to be transmitted to userspace. */ __clear_bit(KEY_RESERVED, dev-&gt;keybit); /* Make sure that bitmasks not mentioned in dev-&gt;evbit are clean. */ input_cleanse_bitmasks(dev); packet_size = input_estimate_events_per_packet(dev); if (dev-&gt;hint_events_per_packet &lt; packet_size) dev-&gt;hint_events_per_packet = packet_size; dev-&gt;max_vals = dev-&gt;hint_events_per_packet + 2; dev-&gt;vals = kcalloc(dev-&gt;max_vals, sizeof(*dev-&gt;vals), GFP_KERNEL); if (!dev-&gt;vals) &#123; error = -ENOMEM; goto err_devres_free; &#125; /* * If delay and period are pre-set by the driver, then autorepeating * is handled by the driver itself and we don&apos;t do it in input.c. */ if (!dev-&gt;rep[REP_DELAY] &amp;&amp; !dev-&gt;rep[REP_PERIOD]) input_enable_softrepeat(dev, 250, 33); if (!dev-&gt;getkeycode) dev-&gt;getkeycode = input_default_getkeycode; if (!dev-&gt;setkeycode) dev-&gt;setkeycode = input_default_setkeycode; error = device_add(&amp;dev-&gt;dev); if (error) goto err_free_vals; path = kobject_get_path(&amp;dev-&gt;dev.kobj, GFP_KERNEL); pr_info(&quot;%s as %s\\n&quot;, dev-&gt;name ? dev-&gt;name : &quot;Unspecified device&quot;, path ? path : &quot;N/A&quot;); kfree(path); error = mutex_lock_interruptible(&amp;input_mutex); if (error) goto err_device_del; list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list); //在此处建立联系 list_for_each_entry(handler, &amp;input_handler_list, node) input_attach_handler(dev, handler); input_wakeup_procfs_readers(); mutex_unlock(&amp;input_mutex); if (dev-&gt;devres_managed) &#123; dev_dbg(dev-&gt;dev.parent, &quot;%s: registering %s with devres.\\n&quot;, __func__, dev_name(&amp;dev-&gt;dev)); devres_add(dev-&gt;dev.parent, devres); &#125; return 0;err_device_del: device_del(&amp;dev-&gt;dev);err_free_vals: kfree(dev-&gt;vals); dev-&gt;vals = NULL;err_devres_free: devres_free(devres); return error;&#125;EXPORT_SYMBOL(input_register_device);/** * input_unregister_device - unregister previously registered device * @dev: device to be unregistered * * This function unregisters an input device. Once device is unregistered * the caller should not try to access it as it may get freed at any moment. */void input_unregister_device(struct input_dev *dev)&#123; if (dev-&gt;devres_managed) &#123; WARN_ON(devres_destroy(dev-&gt;dev.parent, devm_input_device_unregister, devm_input_device_match, dev)); __input_unregister_device(dev); /* * We do not do input_put_device() here because it will be done * when 2nd devres fires up. */ &#125; else &#123; __input_unregister_device(dev); input_put_device(dev); &#125;&#125;EXPORT_SYMBOL(input_unregister_device);/** * input_register_handler - register a new input handler * @handler: handler to be registered * * This function registers a new input handler (interface) for input * devices in the system and attaches it to all input devices that * are compatible with the handler. *///在int input_register_handler(struct input_handler *handler)&#123; struct input_dev *dev; int error; error = mutex_lock_interruptible(&amp;input_mutex); if (error) return error; INIT_LIST_HEAD(&amp;handler-&gt;h_list); list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list); list_for_each_entry(dev, &amp;input_dev_list, node) input_attach_handler(dev, handler); input_wakeup_procfs_readers(); mutex_unlock(&amp;input_mutex); return 0;&#125;EXPORT_SYMBOL(input_register_handler);/** * input_unregister_handler - unregisters an input handler * @handler: handler to be unregistered * * This function disconnects a handler from its input devices and * removes it from lists of known handlers. */void input_unregister_handler(struct input_handler *handler)&#123; struct input_handle *handle, *next; mutex_lock(&amp;input_mutex); list_for_each_entry_safe(handle, next, &amp;handler-&gt;h_list, h_node) handler-&gt;disconnect(handle); WARN_ON(!list_empty(&amp;handler-&gt;h_list)); list_del_init(&amp;handler-&gt;node); input_wakeup_procfs_readers(); mutex_unlock(&amp;input_mutex);&#125;EXPORT_SYMBOL(input_unregister_handler);/** * input_handler_for_each_handle - handle iterator * @handler: input handler to iterate * @data: data for the callback * @fn: function to be called for each handle * * Iterate over @bus&apos;s list of devices, and call @fn for each, passing * it @data and stop when @fn returns a non-zero value. The function is * using RCU to traverse the list and therefore may be using in atomic * contexts. The @fn callback is invoked from RCU critical section and * thus must not sleep. */int input_handler_for_each_handle(struct input_handler *handler, void *data, int (*fn)(struct input_handle *, void *))&#123; struct input_handle *handle; int retval = 0; rcu_read_lock(); list_for_each_entry_rcu(handle, &amp;handler-&gt;h_list, h_node) &#123; retval = fn(handle, data); if (retval) break; &#125; rcu_read_unlock(); return retval;&#125;EXPORT_SYMBOL(input_handler_for_each_handle);/** * input_register_handle - register a new input handle * @handle: handle to register * * This function puts a new input handle onto device&apos;s * and handler&apos;s lists so that events can flow through * it once it is opened using input_open_device(). * * This function is supposed to be called from handler&apos;s * connect() method. */int input_register_handle(struct input_handle *handle)&#123; struct input_handler *handler = handle-&gt;handler; struct input_dev *dev = handle-&gt;dev; int error; /* * We take dev-&gt;mutex here to prevent race with * input_release_device(). */ error = mutex_lock_interruptible(&amp;dev-&gt;mutex); if (error) return error; /* * Filters go to the head of the list, normal handlers * to the tail. */ if (handler-&gt;filter) list_add_rcu(&amp;handle-&gt;d_node, &amp;dev-&gt;h_list); else list_add_tail_rcu(&amp;handle-&gt;d_node, &amp;dev-&gt;h_list); mutex_unlock(&amp;dev-&gt;mutex); /* * Since we are supposed to be called from -&gt;connect() * which is mutually exclusive with -&gt;disconnect() * we can&apos;t be racing with input_unregister_handle() * and so separate lock is not needed here. */ list_add_tail_rcu(&amp;handle-&gt;h_node, &amp;handler-&gt;h_list); if (handler-&gt;start) handler-&gt;start(handle); return 0;&#125;EXPORT_SYMBOL(input_register_handle);/** * input_unregister_handle - unregister an input handle * @handle: handle to unregister * * This function removes input handle from device&apos;s * and handler&apos;s lists. * * This function is supposed to be called from handler&apos;s * disconnect() method. */void input_unregister_handle(struct input_handle *handle)&#123; struct input_dev *dev = handle-&gt;dev; list_del_rcu(&amp;handle-&gt;h_node); /* * Take dev-&gt;mutex to prevent race with input_release_device(). */ mutex_lock(&amp;dev-&gt;mutex); list_del_rcu(&amp;handle-&gt;d_node); mutex_unlock(&amp;dev-&gt;mutex); synchronize_rcu();&#125;EXPORT_SYMBOL(input_unregister_handle);/** * input_get_new_minor - allocates a new input minor number * @legacy_base: beginning or the legacy range to be searched * @legacy_num: size of legacy range * @allow_dynamic: whether we can also take ID from the dynamic range * * This function allocates a new device minor for from input major namespace. * Caller can request legacy minor by specifying @legacy_base and @legacy_num * parameters and whether ID can be allocated from dynamic range if there are * no free IDs in legacy range. */int input_get_new_minor(int legacy_base, unsigned int legacy_num, bool allow_dynamic)&#123; /* * This function should be called from input handler&apos;s -&gt;connect() * methods, which are serialized with input_mutex, so no additional * locking is needed here. */ if (legacy_base &gt;= 0) &#123; int minor = ida_simple_get(&amp;input_ida, legacy_base, legacy_base + legacy_num, GFP_KERNEL); if (minor &gt;= 0 || !allow_dynamic) return minor; &#125; return ida_simple_get(&amp;input_ida, INPUT_FIRST_DYNAMIC_DEV, INPUT_MAX_CHAR_DEVICES, GFP_KERNEL);&#125;EXPORT_SYMBOL(input_get_new_minor);/** * input_free_minor - release previously allocated minor * @minor: minor to be released * * This function releases previously allocated input minor so that it can be * reused later. */void input_free_minor(unsigned int minor)&#123; ida_simple_remove(&amp;input_ida, minor);&#125;EXPORT_SYMBOL(input_free_minor);//注册类以及input设备节点static int __init input_init(void)&#123; int err; err = class_register(&amp;input_class); if (err) &#123; pr_err(&quot;unable to register input_dev class\\n&quot;); return err; &#125; err = input_proc_init(); if (err) goto fail1; err = register_chrdev_region(MKDEV(INPUT_MAJOR, 0), INPUT_MAX_CHAR_DEVICES, &quot;input&quot;); if (err) &#123; pr_err(&quot;unable to register char major %d&quot;, INPUT_MAJOR); goto fail2; &#125; return 0; fail2: input_proc_exit(); fail1: class_unregister(&amp;input_class); return err;&#125;static void __exit input_exit(void)&#123; input_proc_exit(); unregister_chrdev_region(MKDEV(INPUT_MAJOR, 0), INPUT_MAX_CHAR_DEVICES); class_unregister(&amp;input_class);&#125;subsys_initcall(input_init);module_exit(input_exit);","categories":[{"name":"Linux","slug":"Linux","permalink":"http://coderdock.com/categories/Linux/"},{"name":"输入子系统","slug":"Linux/输入子系统","permalink":"http://coderdock.com/categories/Linux/输入子系统/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://coderdock.com/tags/Linux/"},{"name":"输入子系统","slug":"输入子系统","permalink":"http://coderdock.com/tags/输入子系统/"},{"name":"InputCore","slug":"InputCore","permalink":"http://coderdock.com/tags/InputCore/"}]},{"title":"Linux输入子系统之我见(一)","slug":"LinuxSource/Linux输入子系统之我见-一","date":"2017-06-01T23:12:04.000Z","updated":"2018-01-03T00:06:56.495Z","comments":true,"path":"2017/06/02/LinuxSource/Linux输入子系统之我见-一/","link":"","permalink":"http://coderdock.com/2017/06/02/LinuxSource/Linux输入子系统之我见-一/","excerpt":"本章介绍Linux输入子系统的基本概念。1234567891011121314151617_________ _ _______ _________\\__ __/( ( /|( ____ )|\\ /|\\__ __/ ) ( | \\ ( || ( )|| ) ( | ) ( | | | \\ | || (____)|| | | | | | | | | (\\ \\) || _____)| | | | | | | | | | \\ || ( | | | | | |___) (___| ) \\ || ) | (___) | | |\\_______/|/ )_)|/ (_______) )_( _______ ______ _______ _______( ____ \\|\\ /|( ___ \\ ( ____ \\|\\ /|( ____ \\| ( \\/| ) ( || ( ) )| ( \\/( \\ / )| ( \\/| (_____ | | | || (__/ / | (_____ \\ (_) / | (_____(_____ )| | | || __ ( (_____ ) \\ / (_____ ) ) || | | || ( \\ \\ ) | ) ( ) |/\\____) || (___) || )___) )/\\____) | | | /\\____) |\\_______)(_______)|/ \\___/ \\_______) \\_/ \\_______)","text":"本章介绍Linux输入子系统的基本概念。1234567891011121314151617_________ _ _______ _________\\__ __/( ( /|( ____ )|\\ /|\\__ __/ ) ( | \\ ( || ( )|| ) ( | ) ( | | | \\ | || (____)|| | | | | | | | | (\\ \\) || _____)| | | | | | | | | | \\ || ( | | | | | |___) (___| ) \\ || ) | (___) | | |\\_______/|/ )_)|/ (_______) )_( _______ ______ _______ _______( ____ \\|\\ /|( ___ \\ ( ____ \\|\\ /|( ____ \\| ( \\/| ) ( || ( ) )| ( \\/( \\ / )| ( \\/| (_____ | | | || (__/ / | (_____ \\ (_) / | (_____(_____ )| | | || __ ( (_____ ) \\ / (_____ ) ) || | | || ( \\ \\ ) | ) ( ) |/\\____) || (___) || )___) )/\\____) | | | /\\____) |\\_______)(_______)|/ \\___/ \\_______) \\_/ \\_______) 1.分层Linux输入子系统分为三层： 输入子系统事件处理层(EventHandler)：用户编程的接口，并处理驱动层提交的数据。 输入子系统核心层(InputCore)，为设备驱动层提供接口，核心层会自动把数据提交给事件处理层。 输入子系统设备驱动层，实现对硬件的读写访问，中断设置、并把硬件产生的事件转换为核心层定义的规范提交给事件处理层 123456789 核心层 / \\ / \\ 事件处理层 设备驱动层 / (键盘、鼠标、TS) / 设备节点（/dev/input/event*） (/dev/input/misc) 输入子系统核心代码为driver/input/input.c 2.编程要点在使用Linux输入子系统进行编程时，需要进行一下三步： 分配Input Device结构体 在该结构体中设置该设备支持的事件类型及具体事件 编写硬件处理函数，如使用中断监听按键的动作 将需要处理的事件提交到InputCore 将该设备注册到子系统中2.1 输入子系统支持的事件类型| 事件码 | 数字值 | 说明 || :—: |:—-:| :—:||EV_SYN | 0x00 |同步事件 || EV_KEY| 0x01 |按键事件||EV_REL | 0x02 | 相对坐标 || EV_ABS | 0x03 | 绝对坐标 || EV_MSC | ０x04 | 其他 || EV_SW | 0x05 | 开关 || EV_LED | 0x11 | 按键 设备灯 || EV_SND | ０x12 | 声音 || EV_REP | 0x14 | 重复 || EV_FF | 0x15 | 力反馈 || EV_PWR | 0x16 | 电源 || EV_FF_STATUS | 0x17 | 力反馈状态 |我们所实现的每个设备驱动都可以选择一个或多个进行上报给InputCore3.简单示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;linux/input.h&gt; #include &lt;linux/module.h&gt; #include &lt;linux/init.h&gt; #include &lt;asm/irq.h&gt; #include &lt;asm/io.h&gt; static struct input_dev *button_dev; static void button_interrupt(int irq, void*dummy, struct pt_regs *fp) &#123; //上报事件 input_report_key(button_dev, BTN_1, inb(BUTTON_PORT) &amp; 1); //在上报后sync通知Core有事件要处理 input_sync(button_dev); &#125; static int __init button_init(void) &#123; int error; //请求中断，并且在中断服务函数中进行事件上报 if (request_irq(BUTTON_IRQ, button_interrupt, 0, &quot;button&quot;,NULL)) &#123; printk(KERN_ERR&quot;button.c: Can&apos;t allocate irq %d\\n&quot;, button_irq); return -EBUSY; &#125; // 1.分配结构体 button_dev = input_allocate_device(); if (!button_dev) &#123; printk(KERN_ERR&quot;button.c: Not enough memory\\n&quot;); error = -ENOMEM; goto err_free_irq; &#125; //支持事件类型 按键 button_dev-&gt;evbit[0] = BIT(EV_KEY); //支持按键 BTN_0 button_dev-&gt;keybit[LONG(BTN_0)] = BIT(BTN_0); //向InputCore注册该设备驱动 error = input_register_device(button_dev); if (error) &#123; printk(KERN_ERR&quot;button.c: Failed to register device\\n&quot;); goto err_free_dev; &#125; return 0; err_free_dev: input_free_device(button_dev); err_free_irq: free_irq(BUTTON_IRQ, button_interrupt); return error; &#125; static void __exit button_exit(void) &#123; input_unregister_device(button_dev); free_irq(BUTTON_IRQ, button_interrupt);&#125;module_init(button_init);module_exit(button_exit); 由上面的源码可知，相对于自己完全实现字符设备类型驱动而言，我们所进行的编码量已经大为减少。而且层次更为清楚。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://coderdock.com/categories/Linux/"},{"name":"输入子系统","slug":"Linux/输入子系统","permalink":"http://coderdock.com/categories/Linux/输入子系统/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://coderdock.com/tags/Linux/"},{"name":"我的见解","slug":"我的见解","permalink":"http://coderdock.com/tags/我的见解/"}]},{"title":"Linux启动过程之我见","slug":"LinuxSource/Linux启动过程之我见","date":"2017-06-01T05:11:21.000Z","updated":"2018-01-03T00:06:56.488Z","comments":true,"path":"2017/06/01/LinuxSource/Linux启动过程之我见/","link":"","permalink":"http://coderdock.com/2017/06/01/LinuxSource/Linux启动过程之我见/","excerpt":"本章介绍Linux启动过程和涉及的各个文件的作用。12345678_________ _ __________________\\__ __/( ( /|\\__ __/\\__ __/ ) ( | \\ ( | ) ( ) ( | | | \\ | | | | | | | | | (\\ \\) | | | | | | | | | \\ | | | | |___) (___| ) \\ |___) (___ | |\\_______/|/ )_)\\_______/ )_(","text":"本章介绍Linux启动过程和涉及的各个文件的作用。12345678_________ _ __________________\\__ __/( ( /|\\__ __/\\__ __/ ) ( | \\ ( | ) ( ) ( | | | \\ | | | | | | | | | (\\ \\) | | | | | | | | | \\ | | | | |___) (___| ) \\ |___) (___ | |\\_______/|/ )_)\\_______/ )_( Init进程&emsp;&emsp;Init进程是第一个启动的进程，ID号为1，这个程序通常位于/sbin.init，改程序的源码位于init/main.c。当然我们也可以指定自己编写的初始化启动程序，传入启动参数的时候传入init=xxx即可。 &emsp;&emsp;/sbin/init、/etc/init、/bin/init、/bin/sh都是作为Init程序的备选者，有一个存在就会进入不再返回。 &emsp;&emsp;busybox的Init会先设置信号处理函数、初始化控制台、解析inittab等三项工作。 解析Inittabinittab中每一个条目定义了一个子进程。其条目格式如下:1id : runlevels : action : process id 表示这个进程要使用的控制台,(标准输入、标准输出、标准错误输出) runlevels 列出来运行的级别 为空则代表所有级别 action 要执行的动作 process 要执行的程序 Action详解 action名称 执行条件 说明 sysinit 系统启动后最先执行 只执行一次，init执行完成后才能执行其他操作 wait 系统执行完sysinit后 只执行一次，init进程等待它执行完成后才执行其他操作 once 系统执行完wait进程后 只执行一次， init不等它执行完成 respwan 启动完once进程后 init进程发现子进程退出时，重新启动它 askfirst 启动完respwan进程后 输出“Please Press Enter to activcate this console”等用户输入回车键后才启动子进程 shutdown 系统关机时启动 重启 关闭系统命令时 ctrlaltdel 按下 Ctrl + Alt +Del 时 - inittab文件实例1234# /etc/inittab::sysinit:/etc/init.d/rcSttySAC0:askfirst:~/bin/sh::shutdown:/bin/umount -a 同样在rcS一般只有两行123#/bin/shifconfig eth0 192.168.100.100mount -a 那么 mount -a依据那个文件呢？ fastab文件一个典型的fstab文件如下：1234567891011# &lt;file system&gt;&lt;dir&gt;&lt;type&gt;&lt;options&gt;&lt;dump&gt;&lt;pass&gt;none /dev/pts devpts defaults 0 0none /dev/shm tmpfs defaults 0 0/dev/cdrom /media/cd iso9660 ro,user,noauto,unhide 0 0/dev/dvd /media/dvd udf ro,user,noauto,unhide 0 0/dev/fd0 /media/fl auto user,noauto 0 0/dev/hda1 swap swap defaults 0 0/dev/hda4 / ext3 defaults 0 1/dev/hda3 /home xfs rw,suid,exec,auto,nouser,async 0 2 file systems 不是我们通常理解的文件系统，而是指设备（硬盘及其分区，DVD光驱等）。它告知我们设备（分区）的名字，这是你在命令行中挂载（mount）、卸载（umount）设备时要用到的。so one should substitute for this entry the device name, remote partition, or similar. 挂载目录 type 指挂载设备或分区为何种文件系统类型（例如：ext2, ext3, reiserfs, xfs, jfs, smbfs, iso9660, vfat, ntfs, swap等）。 archLinux支持许多文件系统。 要得到一个完整的支持名单查找mount man-page。典型 的名字包括这些：ext2, ext3, reiserfs, xfs, jfs, smbfs, iso9660, vfat, ntfs, swap和auto, ‘auto’ 不是一个文件系统，而是让mount命令自动判断文件类型，特别对于可移动设备，软盘，DVD驱动器，这样做是很有必要的，因为可能每次挂载的文件类型不一致。 选项，这部分是最有用的设置，它能使你所挂载的设备在开机时自动加载、使中文显示不出现乱码、限制对挂载分区读写权限。它是与mount命令的用法相关的。 noatime 关闭atime特性，提高性能，这是一个很老的特性，放心关闭，还能减少loadcycle defaults 使用默认设置。等于rw,suid,dev,exec,auto,nouser,async，具体含义看下面的解释 auto 在启动或在终端中输入mount -a时自动挂载 noauto 设备（分区）只能手动挂载 iocharset＝ 在＝号后面加入你的本地编码，似乎在这个设备（分区）中做文件IO的时候就会自动做编码的格式转换。 ro 挂载为只读权限 rw 挂载为读写权限 exec 是一个默认设置项，它使在那个分区中的可执行的二进制文件能够执行。 noexec 二进制文件不允许执行。千万不要在你的root分区中用这个选项 sync 所有的I/O将以同步方式进行 async 所有的I/O将以非同步方式进行 dump 备份相关 pass sck会检查这个头目下的数字来决定检查文件系统的顺序（looks at the number substituted for and determines in which order the file systems should be checked）。允许的数字是0, 1, 和2。 文件系统的选项是0将不会被fsck utility检查。root文件系统应该拥有最高的优先权， 1，而所有其它的文件系统，如果你想让它被check的话，应该写成2。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://coderdock.com/categories/Linux/"},{"name":"启动过程","slug":"Linux/启动过程","permalink":"http://coderdock.com/categories/Linux/启动过程/"},{"name":"Init","slug":"Linux/启动过程/Init","permalink":"http://coderdock.com/categories/Linux/启动过程/Init/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://coderdock.com/tags/Linux/"},{"name":"Init","slug":"Init","permalink":"http://coderdock.com/tags/Init/"}]},{"title":"通信协议-IIC","slug":"Protocal/通信协议-IIC","date":"2017-05-24T09:39:56.000Z","updated":"2018-01-03T00:10:53.139Z","comments":true,"path":"2017/05/24/Protocal/通信协议-IIC/","link":"","permalink":"http://coderdock.com/2017/05/24/Protocal/通信协议-IIC/","excerpt":"&emsp;&emsp;IIC协议在Dock看来是最简单易懂的协议之一。本文介绍IIC协议的基础要点。","text":"&emsp;&emsp;IIC协议在Dock看来是最简单易懂的协议之一。本文介绍IIC协议的基础要点。 1.IIC基础要点 在时钟的高电平周期内，SDA线上的数据必须保持稳定，数据线仅可以在时钟SCL为低电平时改变。 起始条件：当SCL为高电平的时候，SDA线上由高到低的跳变被定义为起始条件 结束条件：当SCL为高电平的时候，SDA线上由低到高的跳变被定义为停止条件 每当主机向从机发送完一个字节的数据，主机总是需要等待从机给出一个应答信号，以确认从机是否成功接收到了数据，从机应答主机所需要的时钟仍是主机提供的，应答出现在每一次主机完成8个数据位传输后紧跟着的时钟周期，低电平0表示应答，1表示非应答。 2 IIC的C实现 初始时SDA、SCL都处于高电平 1234567void Init()&#123; SCL = 1; delay(); SDA = 1; delay();&#125; 起始信号 SDA在SCL为高电平时产生下降沿： 12345678void StartUp&#123; SCL = 1; SDA = 1; delay(); SDA = 0; delay();&#125; 结束信号 SDA在SCL为高电平时产生上升沿： 12345678void End()&#123; SCL = 1; SDA = 0; delay(); SDA = 1; delay();&#125; 字节发送函数 SCL为低时SDA变为有效数据，SCL为高时，采集数据 123456789101112void Transfer(int8_t i8Send)&#123; int32_t nIndex = 0; for(nIndex = 7; nIndex &gt;= 0; nIndex++) &#123; SCL = 0; SDA = (i8Send &gt;&gt; nIndex) &amp; 0x01; //MSB方式进行发送 delay(); SCL = 1; //变为高电平，SLAVE短进行数据锁存 delay(); &#125;&#125; 判断回复报文 Slave端主动拉低SDA 123456789101112int8_t CheckAck()&#123; delay(); if(SDA == 0) &#123; return 1; &#125; else &#123; return 0; &#125;&#125;","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://coderdock.com/categories/基础知识/"},{"name":"IIC","slug":"基础知识/IIC","permalink":"http://coderdock.com/categories/基础知识/IIC/"}],"tags":[]},{"title":"虚拟开发板-uboot添加实现命令","slug":"VirtualBoard/虚拟开发板-uboot添加实现命令","date":"2017-04-29T04:00:09.000Z","updated":"2018-01-03T00:06:56.471Z","comments":true,"path":"2017/04/29/VirtualBoard/虚拟开发板-uboot添加实现命令/","link":"","permalink":"http://coderdock.com/2017/04/29/VirtualBoard/虚拟开发板-uboot添加实现命令/","excerpt":"在本章会介绍uboot命令的相关结构体并添加自定义命令。12345678______ _______ _______ _________ _______ _______ ______|\\ /|( ___ \\ ( ___ )( ___ )\\__ __/ ( ____ \\( )( __ \\| ) ( || ( ) )| ( ) || ( ) | ) ( | ( \\/| () () || ( \\ )| | | || (__/ / | | | || | | | | | | | | || || || | ) || | | || __ ( | | | || | | | | | | | | |(_)| || | | || | | || ( \\ \\ | | | || | | | | | | | | | | || | ) || (___) || )___) )| (___) || (___) | | | | (____/\\| ) ( || (__/ )(_______)|/ \\___/ (_______)(_______) )_( (_______/|/ \\|(______/","text":"在本章会介绍uboot命令的相关结构体并添加自定义命令。12345678______ _______ _______ _________ _______ _______ ______|\\ /|( ___ \\ ( ___ )( ___ )\\__ __/ ( ____ \\( )( __ \\| ) ( || ( ) )| ( ) || ( ) | ) ( | ( \\/| () () || ( \\ )| | | || (__/ / | | | || | | | | | | | | || || || | ) || | | || __ ( | | | || | | | | | | | | |(_)| || | | || | | || ( \\ \\ | | | || | | | | | | | | | | || | ) || (___) || )___) )| (___) || (___) | | | | (____/\\| ) ( || (__/ )(_______)|/ \\___/ (_______)(_______) )_( (_______/|/ \\|(______/ 1.相关结构体分析在uboot中与命令相关的一个结构体如下，该结构体的内容会被保存在二进制u_boot_cmd段，每当输入一个命令，就会依次在该段内寻找命令，然后执行相应的函数。123456789101112131415struct cmd_tbl_s &#123; char *name; /* Command Name */ int maxargs; /* maximum number of arguments */ int repeatable; /* autorepeat allowed? */ /* Implementation function */ int (*cmd)(struct cmd_tbl_s *, int, int, char * const []); char *usage; /* Usage message (short) */#ifdef CONFIG_SYS_LONGHELP char *help; /* Help message (long) */#endif#ifdef CONFIG_AUTO_COMPLETE /* do auto completion on the arguments */ int (*complete)(int argc, char * const argv[], char last_char, int maxv, char *cmdv[]);#endif&#125;; 如下：就定义了一个imls命令，参数最多为1，可重复执行，实现函数为do_imls,之后是帮助文档。12345678U_BOOT_CMD( imls, 1, 1, do_imls, &quot;list all images found in flash&quot;, &quot;\\n&quot; &quot; - Prints information about all images found at sector/block\\n&quot; &quot; boundaries in nor/nand flash.&quot;);#endif 2.增加自定义命令在common目录下新建hello_cmd.c文件,输入一下内容：12345678910111213141516#include &lt;common.h&gt;#include &lt;bootretry.h&gt;#include &lt;cli.h&gt;#include &lt;console.h&gt;#include &lt;linux/ctype.h&gt;static int do_hello(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])&#123; printf(&quot;Hello World\\n&quot;); return 0;&#125;U_BOOT_CMD( hello, CONFIG_SYS_MAXARGS, 1, do_hello, &quot;print Hello&quot;, &quot;print hello&quot; &quot; passing &apos;arg&apos; as arguments&quot;); 在Makefile中输入：1obj-y += hello_cmd.o 重新使用命令：1make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- 重新编译后，进入uboot:","categories":[{"name":"虚拟开发板","slug":"虚拟开发板","permalink":"http://coderdock.com/categories/虚拟开发板/"}],"tags":[{"name":"uboot","slug":"uboot","permalink":"http://coderdock.com/tags/uboot/"},{"name":"虚拟开发板","slug":"虚拟开发板","permalink":"http://coderdock.com/tags/虚拟开发板/"},{"name":"命令","slug":"命令","permalink":"http://coderdock.com/tags/命令/"}]},{"title":"虚拟开发板-Qemu调试uboot","slug":"VirtualBoard/虚拟开发板-Qemu调试uboot","date":"2017-04-29T03:59:51.000Z","updated":"2018-01-03T00:06:56.456Z","comments":true,"path":"2017/04/29/VirtualBoard/虚拟开发板-Qemu调试uboot/","link":"","permalink":"http://coderdock.com/2017/04/29/VirtualBoard/虚拟开发板-Qemu调试uboot/","excerpt":"在本节介绍使用qemu + gdb调试uboot 和 kernel。1234567( ___ )( ____ \\( )|\\ /| ( ____ \\( __ \\ ( ___ \\| ( ) || ( \\/| () () || ) ( | | ( \\/| ( \\ )| ( ) )| | | || (__ | || || || | | | | | | | ) || (__/ /| | | || __) | |(_)| || | | | | | ____ | | | || __ (| | /\\| || ( | | | || | | | | | \\_ )| | ) || ( \\ \\| (_\\ \\ || (____/\\| ) ( || (___) | | (___) || (__/ )| )___) )(____\\/_)(_______/|/ \\|(_______) (_______)(______/ |/ \\___/","text":"在本节介绍使用qemu + gdb调试uboot 和 kernel。1234567( ___ )( ____ \\( )|\\ /| ( ____ \\( __ \\ ( ___ \\| ( ) || ( \\/| () () || ) ( | | ( \\/| ( \\ )| ( ) )| | | || (__ | || || || | | | | | | | ) || (__/ /| | | || __) | |(_)| || | | | | | ____ | | | || __ (| | /\\| || ( | | | || | | | | | \\_ )| | ) || ( \\ \\| (_\\ \\ || (____/\\| ) ( || (___) | | (___) || (__/ )| )___) )(____\\/_)(_______/|/ \\|(_______) (_______)(______/ |/ \\___/ 1.调试命令我们之前qemu启动uboot的命令为：1qemu-system-arm -M vexpress-a9 -m 256M -nographic -kernel u-boot 现在变为：1qemu-system-arm -M vexpress-a9 -m 256M -nographic -kernel u-boot -gdb tcp::1234 -S -S指在启动的时候释放CPU。qemu会在启动的时候卡住。 2.进行连接新打开一个终端，依次输入：12arm-linux-gnueabihf-gdb u-boottarget remote : 1234 出现以下画面说明成功：","categories":[{"name":"虚拟开发板","slug":"虚拟开发板","permalink":"http://coderdock.com/categories/虚拟开发板/"}],"tags":[{"name":"uboot","slug":"uboot","permalink":"http://coderdock.com/tags/uboot/"},{"name":"虚拟开发板","slug":"虚拟开发板","permalink":"http://coderdock.com/tags/虚拟开发板/"},{"name":"qemu","slug":"qemu","permalink":"http://coderdock.com/tags/qemu/"},{"name":"调试","slug":"调试","permalink":"http://coderdock.com/tags/调试/"}]},{"title":"虚拟开发板-Linux环境搭建","slug":"VirtualBoard/虚拟开发板-Linux环境搭建","date":"2017-04-27T22:41:31.000Z","updated":"2018-01-03T00:06:56.450Z","comments":true,"path":"2017/04/28/VirtualBoard/虚拟开发板-Linux环境搭建/","link":"","permalink":"http://coderdock.com/2017/04/28/VirtualBoard/虚拟开发板-Linux环境搭建/","excerpt":"&emsp;&emsp;本章介绍使用qemu搭建Linux开发环境","text":"&emsp;&emsp;本章介绍使用qemu搭建Linux开发环境 1.Linux源码下载Linux Source: https://www.kernel.org/ 2.编译过程123456789export ARCH=armexport CROSS_COMPILE=arm-linux-gnueabihf-make vexpress_defconfig#生成zImagemake -j4#下面这条会生成uImage供uboot使用make uImage LOADADDR=0x60003000make modulesmake dtbs 3.各种镜像格式介绍 vmlinux编译出来的最原始的内核elf文件，未压缩。 zImage是vmlinux经过objcopy gzip压缩后的文件， objcopy实现由vmlinux的elf文件拷贝成纯二进制数据文件。 bzImage bz表示“big zImage”，不是用bzip2压缩的。两者的不同之处在于，zImage解压缩内核到低端内存(第一个640K)，bzImage解压缩内核到高端内存(1M以上)。如果内核比较小，那么采用zImage或bzImage都行，如果比较大应该用bzImage。 uImageU-boot专用的映像文件，它是在zImage之前加上一个长度为0x40的tag。 vmlinuz 是bzImage/zImage文件的拷贝或指向bzImage/zImage的链接。 initrd 是“initial ramdisk”的简写。一般被用来临时的引导硬件到实际内核vmlinuz能够接管并继续引导的状态。3.qemu启动1qemu-system-arm -nographic -sd vexpress.img -M vexpress-a9 -m 512M -kernel ./arch/arm/boot/zImage -dtb ./arch/arm/boot/dts/vexpress-v2p-ca9.dtb -smp 4 -append &quot; earlyprintk console=ttyAMA0&quot; 在启动文件系统的时候出错，那是因为我们还没有制作根文件系统 4.生成根文件系统1234567891011qemu-img create -f raw vexpress.img 100Mfdisk vexpress.img #在其中进行分区sudo losetup /dev/loop0 vexpress.img #将image挂载到loop0上sudo partx -u /dev/loop0 #刷新分区sudo mkfs.ext3 /dev/loop0p1mkdir rootfssudo mount -o loop /dev/loop0p1 ./rootfs #将rootfs挂载到loo0p1sudo partx -d /dev/loop0 #卸载sudo losetup -d /dev/loop0 #卸载 5.生成根文件系统5.1编译BusyBox123456789配置成下面这种方式：Busybox Settings ---&gt; Build Options ---&gt; [*] Build BusyBox as a static binary (no shared libs) (arm-linux-gnueabihf-) Cross Compiler prefixmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf-make install # 在 ./_install/下生成文件 出现下面输出说明生成成功 5.2制作根文件系统拷贝运行库1234cp -arf _install/* rootfs/cp -arf arm-linux-gcc/lib/* rootfsrm lib/*.aarm-linux-gnueabihf-stripe lib/* 创建文件夹123456sudo mkdir -p rootfs/proc/sudo mkdir -p rootfs/sys/sudo mkdir -p rootfs/tmp/sudo mkdir -p rootfs/root/sudo mkdir -p rootfs/var/sudo mkdir -p rootfs/mnt/ 创建节点1234567sudo mkdir -p rootfs/dev/sudo mknod rootfs/dev/tty1 c 4 1sudo mknod rootfs/dev/tty2 c 4 2sudo mknod rootfs/dev/tty3 c 4 3sudo mknod rootfs/dev/tty4 c 4 4sudo mknod rootfs/dev/console c 5 1sudo mknod rootfs/dev/null c 1 3 添加配置文件1参考linux启动过程章节 6.启动命令1qemu-system-arm -nographic -sd vexpress.img -M vexpress-a9 -m 512M -kernel ./arch/arm/boot/zImage -dtb ./arch/arm/boot/dts/vexpress-v2p-ca9.dtb -smp 4 -append &quot;noinitrd root=/dev/mmcblk0p1 rw rootwait earlyprintk console=ttyAMA0&quot; -net nic,vlan=0 -net tap,vlan=0,ifname=tap30,script=no,downscript=no 7.关闭qemu1ps -A | grep qemu-system-arm | awk &apos;&#123;print $1&#125;&apos; | xargs sudo kill -9 8.网络配置1234sudo apt-get install uml-utilitiessudo apt-get install bridge-utilssudo tunctl -u root -t tap30 #在主机上创建tap30设备ifconfig tap30 192.168.111.1 promisc up #启用设备，并设置为混杂模式 再启动脚本中添加如下几行，以使用网络1-net nic,vlan=0 -net tap,vlan=0,ifname=tap30,script=no,downscript=no 进入虚拟机后使用 1ifconfig eth0 192.168.111.2 promisc up #启用设备","categories":[{"name":"虚拟开发板","slug":"虚拟开发板","permalink":"http://coderdock.com/categories/虚拟开发板/"},{"name":"Linux","slug":"虚拟开发板/Linux","permalink":"http://coderdock.com/categories/虚拟开发板/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://coderdock.com/tags/Linux/"},{"name":"虚拟开发板","slug":"虚拟开发板","permalink":"http://coderdock.com/tags/虚拟开发板/"}]},{"title":"虚拟开发板-uboot环境搭建","slug":"VirtualBoard/虚拟开发板-uboot环境搭建","date":"2017-04-27T08:30:14.000Z","updated":"2018-01-03T00:06:56.463Z","comments":true,"path":"2017/04/27/VirtualBoard/虚拟开发板-uboot环境搭建/","link":"","permalink":"http://coderdock.com/2017/04/27/VirtualBoard/虚拟开发板-uboot环境搭建/","excerpt":"&emsp;&emsp;在本节会介绍如何从头搭建使用qemu + uboot的虚拟开发环境。","text":"&emsp;&emsp;在本节会介绍如何从头搭建使用qemu + uboot的虚拟开发环境。 1.下载安装 uboot qemu arm-linux-gnu uboot : http://www.denx.de/wiki/U-Boot/ qemu : sudo apt-get install qemu arm-linux-gcc : sudo apt-get install gcc-arm-linux-gnueabi 或 https://www.linaro.org/ 2. 编译uboot1234export ARCH=armexport CROSS_COMPILE=arm-linux-gnueabi-make vexpress_ca9x4_configmake -j4 3. qemu启动uboot1qemu-system-arm -M vexpress-a9 -m 256M -nographic -kernel u-boot","categories":[{"name":"uboot","slug":"uboot","permalink":"http://coderdock.com/categories/uboot/"},{"name":"环境搭建","slug":"uboot/环境搭建","permalink":"http://coderdock.com/categories/uboot/环境搭建/"}],"tags":[{"name":"uboot","slug":"uboot","permalink":"http://coderdock.com/tags/uboot/"},{"name":"虚拟开发板","slug":"虚拟开发板","permalink":"http://coderdock.com/tags/虚拟开发板/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://coderdock.com/tags/环境搭建/"}]},{"title":"uboot 配置分析","slug":"Basic/uboot工程配置简要分析","date":"2017-04-27T08:14:03.000Z","updated":"2018-01-03T00:06:56.577Z","comments":true,"path":"2017/04/27/Basic/uboot工程配置简要分析/","link":"","permalink":"http://coderdock.com/2017/04/27/Basic/uboot工程配置简要分析/","excerpt":"简要介绍uboot的配置工程和文件作用。","text":"简要介绍uboot的配置工程和文件作用。 1.uboot文件夹配置uboot源码的目录结构如下： api : 硬件无关的功能函数的API。uboot移植时基本不用管，这些函数是uboot本身使用的。 arch: 与体系结构相关的代码 board : 对应不同配置的开发板oard文件夹下每一个文件都代表一个开发板，这个文件夹下面放的文件就是用来描述这一个开发板的信息的。board目录下有多少个文件夹，就表示当前这个uboot已经被移植到多少个开发板上了（当前的uboot支持多少个开发板）。 common : 通用代码，涵盖各个方面，以命令行处理为主 disk : 磁盘分区相关代码 doc : 常见功能和问题的说明文档，一堆README开头的文件 drivers : 常用的设备驱动程序，每个类型的设备驱动占用一个子目录 examples : 示例程序 fs : 文件系统，支持嵌入式开发常见的fs(cramfs,ext2,ext3,jffs2,etc) include : 全局需要的头文件定义在这儿 lib : 通用库文件 net : 网络相关的代码，小型的协议栈。 tools : 辅助程序， 用于编译和检查uboot目标文件 2.配置架构2.1 配置树整个uboot工程是由以下几个配置文件进行配置的 .config Makefile include auto.conf autoconf.h Kconfig 2.2 配置联系 顶层的Makefile是顶层入口。 在调用make menuconfig的时候，会使用到各个子目录的Kconfig进行显示，最后将结果汇总到 .config – XXX_CONFIG = y 或者 XXX_CONFIG = m auto.conf，其内容来自 .config 用于子目录的Makefile编译，其形式为 obj-$(XXX_CONFIG) += xxx.o,当 XXX_CONFIG = y时就会编译近启动文件，m则为驱动方式，uboot没有驱动，所以全部都是在二进制文件中。 aotoconf.h其内容也来自.config ，由源码进行调用，其中的定义则都是 XXX_CONFIG = 1 3.Kconfig内容解析以常见的DM9000网卡驱动的Kconfig为例： 1234567891011121314151617181920# Network device configurationmenuconfig NETDEVICES default y if UML depends on NET bool &quot;Network device support&quot; ---help--- You can say N here if you don&apos;t intend to connect your Linux box to any other computer at all.……config DM9000 tristate &quot;DM9000 support&quot; depends on ARM || BLACKFIN || MIPS select CRC32 select MII ---help--- Support for DM9000 chipset. To compile this driver as a module, choose M here. The module will be called dm9000.……source &quot;drivers/net/arcnet/Kconfig&quot;source &quot;drivers/net/phy/Kconfig&quot; menuconfig : 表示菜单，本身属于一个菜单中的项目，但是他又有子菜单项目。 config表示菜单中的一个配置项（本身并没有子菜单下的项目）。一个menuconfig后面跟着的所有config项就是这个menuconfig的子菜单。这就是Kconfig中表示的目录关系。 NETDEVICES : menuconfig或者config后面空格隔开的大写字母表示的类似于 NETDEVICES 的就是这个配置项的配置项名字，这个字符串前面添加CONFIG_后就构成了“.config”文件中的配置项名字。 source：内核源码目录树中每一个Kconfig都会用source引入其所有子目录下的Kconfig，从而保证了所有的Kconfig项目都被包含进menuconfig中。这个也说明了：如果你自己在linux内核中添加了一个文件夹，一定要在这个文件夹下创建一个Kconfig文件，然后在这个文件夹的上一层目录的Kconfig中source引入这个文件夹下的Kconfig文件。 tristate：意思是三态（3种状态，对应Y、N、M三种选择方式），意思就是这个配置项可以被三种选择。 bool：是要么真要么假（对应Y和N）。意思是这个配置项只能被2种选择。 depends：意思是本配置项依赖于另一个配置项。如果那个依赖的配置项为Y或者M，则本配置项才有意义；如果依赖的哪个配置项本身被设置为N，则本配置项根本没有意义。depends项会导致make menuconfig的时候找不到一些配置项。所以在menuconfig中如果找不到一个选项，但是这个选项在Kconfig中却是有的，则可能的原因就是这个配置项依赖的一个配置项是不成立的。depends依赖的配置项可以是多个，还可以有逻辑运算。这种时候只要依赖项目运算式子的结果为真则依赖就成立。 select：表示depends on的值有效时，下面的select也会成立，将相应的内容选上。 default：表示depends on的值有效时，下面的default也会成立，将相应的选项选上，有三种选项，分别对应y，n，m。 help：帮助信息，解释这个配置项的含义，以及如何去配置他。","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://coderdock.com/categories/基础知识/"},{"name":"uboot","slug":"基础知识/uboot","permalink":"http://coderdock.com/categories/基础知识/uboot/"}],"tags":[{"name":"uboot","slug":"uboot","permalink":"http://coderdock.com/tags/uboot/"},{"name":"uboot配置","slug":"uboot配置","permalink":"http://coderdock.com/tags/uboot配置/"}]},{"title":"我的Makefilee模板","slug":"Basic/我的Makefilee模板","date":"2017-03-08T07:52:42.000Z","updated":"2018-01-03T00:10:51.064Z","comments":true,"path":"2017/03/08/Basic/我的Makefilee模板/","link":"","permalink":"http://coderdock.com/2017/03/08/Basic/我的Makefilee模板/","excerpt":"&emsp;&emsp;在Linux下开发，使用Makefile组织源码工程师基本功。在本篇文章中会介绍Makefile的基础知识以及Dock经常使用的Makefile函数及模板。","text":"&emsp;&emsp;在Linux下开发，使用Makefile组织源码工程师基本功。在本篇文章中会介绍Makefile的基础知识以及Dock经常使用的Makefile函数及模板。 1.基本概念&emsp;&emsp;每一个Makefile选项都是由 Target、Prerequisite、Function三部分组成，如：12target: prerequisites command 一个实例如下：12hello: hello.c gcc hello.c -o hello 这样在我们使用 make hello的时候,就会调用 gcc hello.c -o hello命令。 2.常用函数&emsp;&emsp;通配函数，下面这个会通配所有以 .cpp结尾的文件。如当前文件夹下有a.cpp &emsp;b.c &emsp;c.cpp,那么 SRC_CPP的值就会是 a.cpp &emsp;c.cpp1SRC_CPP = $(wildcard *.cpp) &emsp;&emsp;替换函数。我们在实际开发中常用到的一点就是讲.cpp .c转换为.o文件，但是总不能一个一个去敲吧。那么替换函数就派上用场了。1OBJS += $(patsubst %c, %o, $(SRC_C)) 上面这条就是把 $SRC_C中每一项的c换为 o。 3.Makefile模板12345678910111213141516171819202122232425262728#CXX = g++#CC = gccCXX = arm-linux-gnu-g++CC = arm-linux-gnu-gccCXXFLAGS = -pthread -Wall -std=c++11INCLUDE_PATH = -I./incSRC_CPP = $(wildcard *.cpp)SRC_C += $(wildcard ./*.c)OBJS += $(patsubst %c, %o, $(SRC_C))OBJS += $(patsubst %cpp, %o, $(SRC_CPP))TARGET=Hello #自定义自己的目标文件$(TARGET):$(OBJS) $(CXX) $^ $(CXXFLAGS) -o $@ -L./ -lsxtl.cpp.o: #cpp 编译成 o $(CXX) -c $(CXXFLAGS) $(INCLUDE_PATH) $&lt; -o $@.c.o: # c 编译成 o $(CXX) -c $(CXXFLAGS) $(INCLUDE_PATH) $&lt; -o $@clean: rm $(OBJS) rm $(TARGET) 每次Dock需要重新配置一个Makefile的时候就会将上边这个Makefile修改一下，适配新工程。","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://coderdock.com/categories/基础知识/"},{"name":"Makefile","slug":"基础知识/Makefile","permalink":"http://coderdock.com/categories/基础知识/Makefile/"}],"tags":[{"name":"Makefile","slug":"Makefile","permalink":"http://coderdock.com/tags/Makefile/"}]},{"title":"Nand Flash使用要点","slug":"Basic/Nand-Flash使用要点","date":"2017-03-01T05:59:34.000Z","updated":"2018-01-03T00:06:56.564Z","comments":true,"path":"2017/03/01/Basic/Nand-Flash使用要点/","link":"","permalink":"http://coderdock.com/2017/03/01/Basic/Nand-Flash使用要点/","excerpt":"以K9F1208U0M介绍NandFlash的基础要点。","text":"以K9F1208U0M介绍NandFlash的基础要点。 1.主要引脚 I/O[0:7] : 数据输入输出 CLE : 命令锁存使能 ALE : 地址锁存使能 nCE ：芯片使能 nRE : 读使能 nWE : 写使能 nWP : 写保护 R/nB : 就绪/忙信号 Vcc : 电源 Vss : 地 2.物理架构 页 : 512 + 16 字节(EDC/ECC校验使用) 块 ：528 * 32 页 器件： 4096 块 总大小： 4096 32 512 = 65536KB = 64MB 3.使用方式","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://coderdock.com/categories/基础知识/"},{"name":"NandFlash","slug":"基础知识/NandFlash","permalink":"http://coderdock.com/categories/基础知识/NandFlash/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://coderdock.com/tags/基础知识/"},{"name":"NandFlash","slug":"NandFlash","permalink":"http://coderdock.com/tags/NandFlash/"}]},{"title":"通信协议-UART","slug":"Protocal/通信协议-UART","date":"2017-02-27T07:57:25.000Z","updated":"2018-01-03T00:06:56.409Z","comments":true,"path":"2017/02/27/Protocal/通信协议-UART/","link":"","permalink":"http://coderdock.com/2017/02/27/Protocal/通信协议-UART/","excerpt":"&emsp;&emsp;UART协议也是一种很简单易懂的通信协议。 &emsp;&emsp;通用异步收发传输器(Universal Asynchronous Receiver/Transmitter)，通常称作 UART，是一种异步收发传输器。将数据由串行通信与并行通信间作传输转换，作为并行输入成为串行输出的芯片 UART 是一种通用串行数据总线，用于异步通信。该总线双向通信，可以实现全双工传输和接收。","text":"&emsp;&emsp;UART协议也是一种很简单易懂的通信协议。 &emsp;&emsp;通用异步收发传输器(Universal Asynchronous Receiver/Transmitter)，通常称作 UART，是一种异步收发传输器。将数据由串行通信与并行通信间作传输转换，作为并行输入成为串行输出的芯片 UART 是一种通用串行数据总线，用于异步通信。该总线双向通信，可以实现全双工传输和接收。 1.协议要点 起始位：先发出一个逻辑”0”的信号，表示传输字符的开始。 数据位：紧接着起始位之后。数据位的个数可以是4、5、6、7、8等，构成一个字符。通常采用 ASCII 码。从最低位开始传送，靠时钟定位。 奇偶校验位：数据位加上这一位后，使得“1”的位数应为偶数(偶校验)或奇数(奇校验)，以此来校验数据传送的正确性。 停止位：它是一个字符数据的结束标志。可以是1位、1.5位、2位的高电平。由于数据是在传输线上定时的，并且每一个设备有其自己的时钟，很可能在通信中两台设备间出现了小小的不同步。因此停止位不仅仅是表示传输的结束，并且提供计算机校正时钟同步的机会。适用于停止位的位数越多，不同时钟同步的容忍程度越大。但是数据传输率同时也越慢。 空闲位：处于逻辑“1”状态，表示当前线路上没有数据传送 2.波特率&emsp;&emsp;波特率及1秒钟能传输的Bit数。如9600波特率及指一个脉冲的时间为 1/9600 S。","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://coderdock.com/categories/基础知识/"},{"name":"UART","slug":"基础知识/UART","permalink":"http://coderdock.com/categories/基础知识/UART/"}],"tags":[{"name":"UART","slug":"UART","permalink":"http://coderdock.com/tags/UART/"},{"name":"通信协议","slug":"通信协议","permalink":"http://coderdock.com/tags/通信协议/"}]},{"title":"MMU理解要点","slug":"Basic/MMU理解要点","date":"2017-02-27T04:54:09.000Z","updated":"2018-01-03T00:06:56.558Z","comments":true,"path":"2017/02/27/Basic/MMU理解要点/","link":"","permalink":"http://coderdock.com/2017/02/27/Basic/MMU理解要点/","excerpt":"&emsp;&emsp;MMU是我们必须要掌握的一个要点。","text":"&emsp;&emsp;MMU是我们必须要掌握的一个要点。 1.VA转MVA下面这个转换是使用硬件自动完成的if(VA &lt; 32M) then MVA = VA | (PID &lt;&lt; 25);else MVA = VA; 利用PID将VA转换成不同VA,那么多个进程的MVA就能存在于同一个页表中，那么在进行进程转换时，只需要取不同的页表就可以了(在实际使用中，进程也确实是小于32M的居多)。而如果是大进程，那么可能需要重新构建页表，那么就需要重新构建页表，那么进程切换的开销会很大。 2.页表转换 页表基址(TTB)存在于CP15的C2, TTB[31:14]:(MVA[31:20]&gt;&gt;18):00构成页表基址。 一级描述符：每一个页表项可以可以是段页描述符、粗页描述符、细页描述符 段页描述符，直接指向1MB的内存空间 粗页描述符，有256个二级页表项，每个二级页表项指向4KB的内存空间 细叶描述符，有1024个二级页表项，每个二级页表项指向1KB的内存空间 二级描述符：粗页描述符、细页描述符可以指向二级描述符，其中包括大页描述符、小页描述符、极小页描述符： 大页描述符：0b01为大页描述符，[31:16]为大页基址。[15:0]可以表示。但是粗页表中的页表项每项只能表示4KB,所以连续16个条目表示的都是同一个大页描述符。同理，对于细页表中，连续64个条目表示的都是同一个大页描述符。 小页描述符：0x10为小页描述符。[31:12]表示的为小页基址。[11:0]可以表示4KB大小。所以如果放在粗页表中，那么正好一一对应。如果放在细页表中，那么细页表中，连续四个条目表示同一个小页描述符 极小页描述符：0x11表示为极小页描述符，[31:10]为极小页基址。[9:0]可以表示1KB空间。极小页描述符只能放在细页表中，一个条目对应一个极小页描述符。3.转换实例 一级转换 段转换： 页表基址寄存器[31:14]:MVA[31:20]组成低两位为零的32位地址，MMU利用这个地址找到段描述符。 段描述法的[31:20]:MVA[19:20]即为PA 二级转换 小页描述符保存在粗页表中： 页表基址寄存器[31:14]:MVA[31:20]组成低两位为零的32位地址，MMU利用这个地址找到段描述符。 粗页表描述符的[31:10]:MVA[19:12],组成低两位为零的32位地址，可以找到小页描述符。 ‘小页描述符[31；12]:MVA[11:0]’组成PA。4.转换总结 一级转换负责转换到1M大小，之后要么使用段转换转换到物理地址。要么使用粗页表或细页表进行二级转换 大页[31:16] 小页[31:12] 极小页[31:10] 5.权限控制 内存的访问权限检查可以概括为以下两点： “域”决定是否对某块内存进行权限检查。 “AP”决定如何对某块内存进行权限检查。6. TLB的作用&emsp;&emsp;从虚拟地址到物理地址的转换过程可知：使用一级页表进行地址转换时，每次读/写数据需要访问两次内存，第一次访问一级页表获得物理地址，第二次才是真正的读写数据；使用两级页表时需要3次访存。利用程序执行时的局部性特性，通过使用一个高速、容量相对较小的存储器来存储近期用到的页表条目，这样可以大幅提高系统性能，这个存储器用来帮助快速地进行地址转换，称为”转译查找缓存”（TLB-Translation Lookaside Table）。","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://coderdock.com/categories/基础知识/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://coderdock.com/tags/基础知识/"},{"name":"MMU","slug":"MMU","permalink":"http://coderdock.com/tags/MMU/"}]},{"title":"通信协议-UART-Verilog实现","slug":"Protocal/通信协议-UART-Verilog实现","date":"2017-02-25T21:03:34.000Z","updated":"2018-01-03T00:06:56.403Z","comments":true,"path":"2017/02/26/Protocal/通信协议-UART-Verilog实现/","link":"","permalink":"http://coderdock.com/2017/02/26/Protocal/通信协议-UART-Verilog实现/","excerpt":"&emsp;&emsp;本篇通过使用Verilog实现UART的读写。","text":"&emsp;&emsp;本篇通过使用Verilog实现UART的读写。 RX模块 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394module my_uart_rx( clk,rst_n, rs232_rx,rx_data,rx_int, clk_bps,bps_start );input clk; // 50MHz主时钟input rst_n; //低电平复位信号input rs232_rx; // RS232接收数据信号input clk_bps; // clk_bps的高电平为接收或者发送数据位的中间采样点output bps_start; //接收到数据后，波特率时钟启动信号置位output[7:0] rx_data; //接收数据寄存器，保存直至下一个数据来到output rx_int; //接收数据中断信号,接收到数据期间始终为高电平//----------------------------------------------------------------reg rs232_rx0,rs232_rx1,rs232_rx2,rs232_rx3; //接收数据寄存器，滤波用wire neg_rs232_rx; //表示数据线接收到下降沿always @ (posedge clk or negedge rst_n) begin if(!rst_n) begin rs232_rx0 &lt;= 1&apos;b0; rs232_rx1 &lt;= 1&apos;b0; rs232_rx2 &lt;= 1&apos;b0; rs232_rx3 &lt;= 1&apos;b0; end else begin rs232_rx0 &lt;= rs232_rx; rs232_rx1 &lt;= rs232_rx0; rs232_rx2 &lt;= rs232_rx1; rs232_rx3 &lt;= rs232_rx2; endend //下面的下降沿检测可以滤掉&lt;20ns-40ns的毛刺(包括高脉冲和低脉冲毛刺)， //这里就是用资源换稳定（前提是我们对时间要求不是那么苛刻，因为输入信号打了好几拍） //（当然我们的有效低脉冲信号肯定是远远大于40ns的）assign neg_rs232_rx = rs232_rx3 &amp; rs232_rx2 &amp; ~rs232_rx1 &amp; ~rs232_rx0; //接收到下降沿后neg_rs232_rx置高一个时钟周期//----------------------------------------------------------------reg bps_start_r;reg[3:0] num; //移位次数reg rx_int; //接收数据中断信号,接收到数据期间始终为高电平always @ (posedge clk or negedge rst_n) if(!rst_n) begin bps_start_r &lt;= 1&apos;bz; rx_int &lt;= 1&apos;b0; end else if(neg_rs232_rx) begin //接收到串口接收线rs232_rx的下降沿标志信号 bps_start_r &lt;= 1&apos;b1; //启动串口准备数据接收 rx_int &lt;= 1&apos;b1; //接收数据中断信号使能 end else if(num==4&apos;d12) begin //接收完有用数据信息 bps_start_r &lt;= 1&apos;b0; //数据接收完毕，释放波特率启动信号 rx_int &lt;= 1&apos;b0; //接收数据中断信号关闭 endassign bps_start = bps_start_r;//----------------------------------------------------------------reg[7:0] rx_data_r; //串口接收数据寄存器，保存直至下一个数据来到//----------------------------------------------------------------reg[7:0] rx_temp_data; //当前接收数据寄存器always @ (posedge clk or negedge rst_n) if(!rst_n) begin rx_temp_data &lt;= 8&apos;d0; num &lt;= 4&apos;d0; rx_data_r &lt;= 8&apos;d0; end else if(rx_int) begin //接收数据处理 if(clk_bps) begin //读取并保存数据,接收数据为一个起始位，8bit数据，1或2个结束位 num &lt;= num+1&apos;b1; case (num) 4&apos;d1: rx_temp_data[0] &lt;= rs232_rx; //锁存第0bit 4&apos;d2: rx_temp_data[1] &lt;= rs232_rx; //锁存第1bit 4&apos;d3: rx_temp_data[2] &lt;= rs232_rx; //锁存第2bit 4&apos;d4: rx_temp_data[3] &lt;= rs232_rx; //锁存第3bit 4&apos;d5: rx_temp_data[4] &lt;= rs232_rx; //锁存第4bit 4&apos;d6: rx_temp_data[5] &lt;= rs232_rx; //锁存第5bit 4&apos;d7: rx_temp_data[6] &lt;= rs232_rx; //锁存第6bit 4&apos;d8: rx_temp_data[7] &lt;= rs232_rx; //锁存第7bit default: ; endcase end else if(num == 4&apos;d12) begin //我们的标准接收模式下只有1+8+1(2)=11bit的有效数据 num &lt;= 4&apos;d0; //接收到STOP位后结束,num清零 rx_data_r &lt;= rx_temp_data; //把数据锁存到数据寄存器rx_data中 end endassign rx_data = rx_data_r;endmodule TX模块 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091module my_uart_tx( clk,rst_n, rx_data,rx_int,rs232_tx, clk_bps,bps_start );input clk; // 50MHz主时钟input rst_n; //低电平复位信号input clk_bps; // clk_bps_r高电平为接收数据位的中间采样点,同时也作为发送数据的数据改变点input[7:0] rx_data; //接收数据寄存器input rx_int; //接收数据中断信号,接收到数据期间始终为高电平,在该模块中利用它的下降沿来启动串口发送数据output rs232_tx; // RS232发送数据信号output bps_start; //接收或者要发送数据，波特率时钟启动信号置位//---------------------------------------------------------reg rx_int0,rx_int1,rx_int2; //rx_int信号寄存器，捕捉下降沿滤波用wire neg_rx_int; // rx_int下降沿标志位always @ (posedge clk or negedge rst_n) begin if(!rst_n) begin rx_int0 &lt;= 1&apos;b0; rx_int1 &lt;= 1&apos;b0; rx_int2 &lt;= 1&apos;b0; end else begin rx_int0 &lt;= rx_int; rx_int1 &lt;= rx_int0; rx_int2 &lt;= rx_int1; endendassign neg_rx_int = ~rx_int1 &amp; rx_int2; //捕捉到下降沿后，neg_rx_int拉高保持一个主时钟周期//---------------------------------------------------------reg[7:0] tx_data; //待发送数据的寄存器//---------------------------------------------------------reg bps_start_r;reg tx_en; //发送数据使能信号，高有效reg[3:0] num;always @ (posedge clk or negedge rst_n) begin if(!rst_n) begin bps_start_r &lt;= 1&apos;bz; tx_en &lt;= 1&apos;b0; tx_data &lt;= 8&apos;d0; end else if(neg_rx_int) begin //接收数据完毕，准备把接收到的数据发回去 bps_start_r &lt;= 1&apos;b1; tx_data &lt;= rx_data; //把接收到的数据存入发送数据寄存器 tx_en &lt;= 1&apos;b1; //进入发送数据状态中 end else if(num==4&apos;d11) begin //数据发送完成，复位 bps_start_r &lt;= 1&apos;b0; tx_en &lt;= 1&apos;b0; endendassign bps_start = bps_start_r;//---------------------------------------------------------reg rs232_tx_r;always @ (posedge clk or negedge rst_n) begin if(!rst_n) begin num &lt;= 4&apos;d0; rs232_tx_r &lt;= 1&apos;b1; end else if(tx_en) begin if(clk_bps) begin num &lt;= num+1&apos;b1; case (num) 4&apos;d0: rs232_tx_r &lt;= 1&apos;b0; //发送起始位 4&apos;d1: rs232_tx_r &lt;= tx_data[0]; //发送bit0 4&apos;d2: rs232_tx_r &lt;= tx_data[1]; //发送bit1 4&apos;d3: rs232_tx_r &lt;= tx_data[2]; //发送bit2 4&apos;d4: rs232_tx_r &lt;= tx_data[3]; //发送bit3 4&apos;d5: rs232_tx_r &lt;= tx_data[4]; //发送bit4 4&apos;d6: rs232_tx_r &lt;= tx_data[5]; //发送bit5 4&apos;d7: rs232_tx_r &lt;= tx_data[6]; //发送bit6 4&apos;d8: rs232_tx_r &lt;= tx_data[7]; //发送bit7 4&apos;d9: rs232_tx_r &lt;= 1&apos;b1; //发送结束位 default: rs232_tx_r &lt;= 1&apos;b1; endcase end else if(num==4&apos;d11) num &lt;= 4&apos;d0; //复位 endendassign rs232_tx = rs232_tx_r;endmodule","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://coderdock.com/categories/基础知识/"},{"name":"UART","slug":"基础知识/UART","permalink":"http://coderdock.com/categories/基础知识/UART/"}],"tags":[{"name":"UART","slug":"UART","permalink":"http://coderdock.com/tags/UART/"},{"name":"Verilog实现","slug":"Verilog实现","permalink":"http://coderdock.com/tags/Verilog实现/"}]},{"title":"打造自己的VIM编辑器","slug":"Basic/Dock工具-打造自己的VIM编辑器","date":"2017-02-25T07:25:27.000Z","updated":"2017-12-24T04:23:16.245Z","comments":true,"path":"2017/02/25/Basic/Dock工具-打造自己的VIM编辑器/","link":"","permalink":"http://coderdock.com/2017/02/25/Basic/Dock工具-打造自己的VIM编辑器/","excerpt":"作为一个经常在Linux下开发的程序员，怎么能没有自己高逼格的VIM编辑器呢？在这片教程中会一步步的搭建起自己的高逼格VIM！","text":"作为一个经常在Linux下开发的程序员，怎么能没有自己高逼格的VIM编辑器呢？在这片教程中会一步步的搭建起自己的高逼格VIM！ 1. 主题&emsp;&emsp;刀客喜欢的主题有两个：molokai 、Solarized 1.1 molokai&emsp;&emsp;molokai的特点是色彩艳丽，设置为暗色背景很适合程序员开发。并且网上的教程都是使用Bundle进行安装，但刀客尝试后发现自己无法正常安装。还是一步步的从GIt进行安装更靠谱点。 git clone git@github.com:tomasr/molokai.git 将colors 文件夹的molokai.vim 拷贝到~/.vim/colors 在~/.vimrc中添加如下语句： 123colorscheme molokaiset t_Co=256set background=dark 噔噔噔噔！打开vim编辑器是不是变得很炫酷了？ 1.2 Solarized&emsp;&emsp;Solarized主题是使用最广泛的vim主题。但刀客还是更喜欢molokai一点。 git clone git@github.com/altercation/vim-colors-solarized 将colors 文件夹的molokai.vim 拷贝到~/.vim/colors 在~/.vimrc中添加如下语句： 123syntax enableset background=darkcolorscheme solarized 快快地打开你的vim编辑器看一下吧。 2. VIM 安装 作为一个程序员怎么能够不会使用源码这么高（苦）大（逼）的软件安装方式呢？好吧！是因为我要安装YCM(YouCompleteMe)代码自动不全工具需要Python的支持，但通过命令行安装的VIM一般不支持Python。 2.1 卸载VIM&emsp;&emsp;如果你的电脑上安装着vim,你需要完全卸载之前的VIM,方法很简单也很粗暴：12345sudo apt-get remove vimsudo apt-get remove vim-runtimesudo apt-get remove vim -tinysudo apt-get remove vim-commonsudo apt-get remove vim-docsudo apt-get remove vim-script 保证把vim卸载的渣渣都不剩。 2.2 安装&emsp;&emsp;先安装一下依赖吧，很简单,反正也不多：123sudo apt-get install libncurses5-dev libgnome2-dev libgnomeui-dev libgtk2.0-dev libatk1.0-dev libbonoboui2-dev libcairo2-dev libx11-dev libxpm-dev libxt-dev python-dev python3-dev ruby-dev liblua5.1-dev libperl-dev git &emsp;&emsp;然后下载vim,之后进行配置、编译、安装，三板斧嘛，开始：12345678910111213141516cd ~git clone https://github.com/vim/vim.gitcd vim./configure --with-features=huge \\ --enable-multibyte \\ --enable-rubyinterp=yes \\ --enable-pythoninterp=yes \\ --with-python-config-dir=/usr/lib/python2.7/config-x86_64-linux-gnu \\ --enable-python3interp=yes \\ --with-python3-config-dir=/usr/lib/python3.5/config-3.5m-x86_64_linux-gnu \\ --enable-perlinterp=yes \\ --enable-luainterp=yes \\ --enable-gui=gtk2 --enable-cscope --prefix=/usrmake VIMRUNTIMEDIR=/usr/share/vim/vim80cd ~/vimsudo make install 齐活！ 3.安装YCM&emsp;&emsp;VIM被称为编辑器之神，而YCM则是vim中最难装的插件，简直就是神的脚后跟。在网上搜索YCM的安装，基本都是使用Bundle安装，可是我试了好几次还是安装不上。算了还是苦逼地从源码安装吧。 &emsp;&emsp;经过刀客我的尝试，终于从源码安装上了YCM! 3.1 下载YCM&emsp;&emsp;首先将YCM从git下载到本地，我选了 ~/.vim/bundle/。因为之前通过Bundle安装没有成功，正好有这么一个文件夹，没有的自己见一个就是了。。。。 1234# 下载 （在 `～/.vim/bundle` 目录下）git clone --recursive git@github.com/Valloric/YouCompleteMe.git# 检查完整性（在 `～/.vim/bundle/YouCompleteMe` 目录下）git submodule update --init --recursive 这样就开始编译安装了是么？ NO No NO!,我们还需要安装依赖呢12#sudo apt-get install llvm-5.0 clang-5.0 libclang-5.0-dev libboost-all-dev 我统一选择了5.0版本，你要根据自己的软件源里的版本进行安装哦。 3.3 编译安装在家目录下新建一个安装目录，然后进行执行一下命令：12345mkdir ~/.ycm_buildcd ~/.ycm_buildcmake -G &quot;Unix Makefiles&quot; -DUSE_SYSTEM_BOOST=ON -DUSE_SYSTEM_LIBCLANG=ON . ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cppcmake -G &quot;Unix Makefiles&quot; -DUSE_SYSTEM_BOOST=ON -DEXTERNAL_LIBCLANG_PATH=/usr/lib/x86_64-linux-gnu/libclang-5.0.so . ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cppcmake --build . --target ycm_core --config Release 将配置文件拷贝到 ~/.vim1cp ~/.vim/bundle/YouCompleteMe/third_party/ycmd/examples/.ycm_extra_conf.py ~/.vim/ 最后在 ~/.vimrc中添加以下语句：12let g:ycm_server_python_interpreter=&apos;/usr/bin/python&apos;let g:ycm_global_ycm_extra_conf=&apos;~/.vim/.ycm_extra_conf.py&apos; 打开你的编辑器看一下吧！ 4.安装ctags和taglist&emsp;&emsp;众所周知，在Linux阅读大型源码是一件比较困难的事情，我们可以使用SourceInsigh或者UnderStand，但是总有一种被强奸的感觉，因为这样做不Linux啊。 &emsp;&emsp;总的来说，ctags负责将源码中的各个变量生成各个标签，我们可以随时查看调用位置。而taglist基于ctags提供了结构化浏览的功能，我们可以查看一个结构体中有哪些变量等等。 4.1 安装ctags使用命令行：1sudo apt-get install ctags 或者从github上下载源码后，使用三板斧：1./configure &amp;&amp; make &amp;&amp; make install 在.vimrc中添加1map &lt;C-F12&gt; :!ctags -R --c++-kinds=+p --fields=+iaS --extra=+q .&lt;CR&gt; 我们就可以进入代码根目录后，打开Vim，按下Ctrl-F12快捷键自动生成tags文件。命令执行完后，会在源代码目录生成tags文件。Vim默认会自动读取当前目录下的tags文件，所以不需要修改~/.vimrc文件。 此时，我们已经具有定义跳转的功能了。有两组快捷键是最常用的。12Ctrl-] 跳转到光标所在符号的定义。Ctrl-t 回到上次跳转前的位置。 更多功能通过命令man ctags或在Vim命令行下运行help ctags查询。 4.2 安装Taglist从下方网址下载talist包，解压打~/.vim，注意的是如果之前已经存在了doc或者plugin文件夹，我们只需要将对应文件放置到对应文件夹即可。 然后在 .vimrc中添加如下两句：12let Tlist_Show_One_File=1 let Tlist_Exit_OnlyWindow=1 5 安装NERDTree&emsp;&emsp;我们使用VIM进行大型源码编程的时候总是无法看到目录结构，这是一件比较苦恼的事情，那么我们就可以使用NERDTree来解决。方法很简单：1git clone https://github.com/scrooloose/nerdtree.git ~/ 然后将目录中的文件放置到对应的文件夹即可。进入 vims使用命令 NERDTreeToggle看看目录结构出来了没有。我们也可以在.vimrc中设置快捷键1map &lt;F6&gt; :NERDTreeToggle&lt;CR&gt; 这样就可以使用 F6打开或者关闭目录结构了。","categories":[{"name":"编程工具","slug":"编程工具","permalink":"http://coderdock.com/categories/编程工具/"}],"tags":[{"name":"编程工具","slug":"编程工具","permalink":"http://coderdock.com/tags/编程工具/"}]},{"title":"通信协议-SPI","slug":"Protocal/通信协议-SPI","date":"2017-02-24T07:57:46.000Z","updated":"2018-01-03T00:11:49.398Z","comments":true,"path":"2017/02/24/Protocal/通信协议-SPI/","link":"","permalink":"http://coderdock.com/2017/02/24/Protocal/通信协议-SPI/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"平台设备驱动之我见一","slug":"LinuxSource/平台设备驱动之我见一","date":"2017-02-02T23:52:56.000Z","updated":"2018-01-03T00:09:13.747Z","comments":true,"path":"2017/02/03/LinuxSource/平台设备驱动之我见一/","link":"","permalink":"http://coderdock.com/2017/02/03/LinuxSource/平台设备驱动之我见一/","excerpt":"本章介绍Linux平台设备的基础知识。12345678_______ _ _______ _________ _______ _______ _______ _______( ____ )( \\ ( ___ )\\__ __/( ____ \\( ___ )( ____ )( )| ( )|| ( | ( ) | ) ( | ( \\/| ( ) || ( )|| () () || (____)|| | | (___) | | | | (__ | | | || (____)|| || || || _____)| | | ___ | | | | __) | | | || __)| |(_)| || ( | | | ( ) | | | | ( | | | || (\\ ( | | | || ) | (____/\\| ) ( | | | | ) | (___) || ) \\ \\__| ) ( ||/ (_______/|/ \\| )_( |/ (_______)|/ \\__/|/ \\|","text":"本章介绍Linux平台设备的基础知识。12345678_______ _ _______ _________ _______ _______ _______ _______( ____ )( \\ ( ___ )\\__ __/( ____ \\( ___ )( ____ )( )| ( )|| ( | ( ) | ) ( | ( \\/| ( ) || ( )|| () () || (____)|| | | (___) | | | | (__ | | | || (____)|| || || || _____)| | | ___ | | | | __) | | | || __)| |(_)| || ( | | | ( ) | | | | ( | | | || (\\ ( | | | || ) | (____/\\| ) ( | | | | ) | (___) || ) \\ \\__| ) ( ||/ (_______/|/ \\| )_( |/ (_______)|/ \\__/|/ \\| 1.platform_bus_type在总线、驱动、设备三个基本要素中，总线居于中心位置，通过其中的match函数，将驱动和设备建立联系。1234567struct bus_type platform_bus_type = &#123; .name = &quot;platform&quot;, .dev_attrs = platform_dev_attrs, .match = platform_match, .uevent = platform_uevent, .pm = &amp;platform_dev_pm_ops,&#125;; 由platform_match源码可知，如果存在id则使用id进行匹配，否则使用name进行字符串匹配。123456789101112static int platform_match(struct device *dev, struct device_driver *drv)&#123; struct platform_device *pdev = to_platform_device(dev); struct platform_driver *pdrv = to_platform_driver(drv); /* match against the id table first */ if (pdrv-&gt;id_table) return platform_match_id(pdrv-&gt;id_table, pdev) != NULL; /* fall-back to driver name match */ return (strcmp(pdev-&gt;name, drv-&gt;name) == 0);&#125; 所以就能够理解驱动源码中的id_tables的含义了123456789static struct platform_device_id s3c24xx_driver_ids[] = &#123; &#123; .name = &quot;s3c2410-i2c&quot;, .driver_data = TYPE_S3C2410, &#125;, &#123; .name = &quot;s3c2440-i2c&quot;, .driver_data = TYPE_S3C2440, &#125;, &#123; &#125;,&#125;; 每一项表征能够支持一款设备。 2.platform_device12345678910struct platform_device &#123; const char * name; int id; struct device dev; u32 num_resources; struct resource * resource; struct platform_device_id *id_entry; /* arch specific additions */ struct pdev_archdata archdata;&#125;; 在该结构体中定义了ID以及name,在想平台总线注册设备的时候就会依据name或ID进行匹配。 dev，真正的设备，通过 container_of ,就能找到整个platform_device。 3.platform_device_dirver123456789struct platform_driver &#123; int (*probe)(struct platform_device *); int (*remove)(struct platform_device *); void (*shutdown)(struct platform_device *); int (*suspend)(struct platform_device *, pm_message_t state); int (*resume)(struct platform_device *); struct device_driver driver; struct platform_device_id *id_table;&#125;; 在driver中主要要实现probe函数，这是平台匹配到设备时第一个要调用的函数，同时设置好id_tables这样平台驱动才能够进行匹配。 4.接口4.1设备接口对于设备平台提供了如下接口，这也就是说我们在编写设备文件时能够调用这些接口：123456789101112131415161718192021222324252627282930313233343536373839/* include/linux/platform_device.h *///Platform设备的注册/注销接口extern int platform_device_register(struct platform_device *);extern void platform_device_unregister(struct platform_device *);//arch_setup_pdev_archdata，设置platform_device变量中的archdata指针。extern void arch_setup_pdev_archdata(struct platform_device *);//以下这些接口，可以获取platform_device变量中的resource信息，以及直接获取IRQ的number等等。extern struct resource *platform_get_resource(struct platform_device *, unsigned int, unsigned int);extern int platform_get_irq(struct platform_device *, unsigned int);extern struct resource *platform_get_resource_byname(struct platform_device *, unsigned int, const char *);extern int platform_get_irq_byname(struct platform_device *, const char *);extern int platform_add_devices(struct platform_device **, int);extern struct platform_device *platform_device_register_full(const struct platform_device_info *pdevinfo);static inline struct platform_device *platform_device_register_resndata( struct device *parent, const char *name, int id, const struct resource *res, unsigned int num, const void *data, size_t size)static inline struct platform_device *platform_device_register_simple( const char *name, int id, const struct resource *res, unsigned int num)static inline struct platform_device *platform_device_register_data( struct device *parent, const char *name, int id, const void *data, size_t size)extern struct platform_device *platform_device_alloc(const char *name, int id);extern int platform_device_add_resources(struct platform_device *pdev, const struct resource *res, unsigned int num);extern int platform_device_add_data(struct platform_device *pdev, const void *data, size_t size);extern int platform_device_add(struct platform_device *pdev);extern void platform_device_del(struct platform_device *pdev);extern void platform_device_put(struct platform_device *pdev); 4.2驱动接口123platform_driver_registe、platform_driver_unregister，platform driver的注册、注销接口。platform_driver_probe，主动执行probe动作。platform_set_drvdata、platform_get_drvdata，设置或者获取driver保存在device变量中的私有数据。 5.简单示例设备文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/device.h&gt;#include &lt;linux/interrupt.h&gt;#include &lt;linux/sched.h&gt;#include &lt;linux/irq.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;linux/input.h&gt;#include &lt;linux/platform_device.h&gt;// 设备资源static struct resource led_resource[] = &#123; //jz2440的参数，驱动未测试 [0] = &#123; .start = 0x56000010, .end = 0x56000010 + 8 - 1, .flags = IORESOURCE_MEM, &#125;, [1] = &#123; .start = 5, .end = 5, .flags = IORESOURCE_IRQ, &#125;,&#125;;static void led_release(struct device *dev)&#123;&#125;// 创建一个设备static struct platform_device led_dev = &#123; .name = &quot;myled&quot;, //设备名字 与 驱动相匹配 .id = -1, .num_resources = ARRAY_SIZE(led_resource), .resource = led_resource, .dev = &#123; .release = led_release, //.devt = MKDEV(252, 1), &#125;,&#125;;static int led_dev_init(void)&#123; //向bus注册led_dev match drv链表进行配对 platform_device_register(&amp;led_dev); return 0;&#125;static void led_dev_exit(void)&#123; platform_device_unregister(&amp;led_dev);&#125;module_init(led_dev_init);module_exit(led_dev_exit);MODULE_LICENSE(&quot;GPL&quot;); 驱动文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/device.h&gt;#include &lt;linux/interrupt.h&gt;#include &lt;linux/sched.h&gt;#include &lt;linux/irq.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;linux/platform_device.h&gt;#include &lt;linux/io.h&gt;static int major;static struct class *cls;static struct device *dev;static volatile unsigned long *gpio_con;static volatile unsigned long *gpio_dat;static int pin;static int led_open(struct inode *inode, struct file *file)&#123; *gpio_con &amp;= ~(0x03 &lt;&lt; (pin*2)); *gpio_con |= (0x01 &lt;&lt; (pin*2)); return 0;&#125;static ssize_t led_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)&#123; int val; copy_from_user(&amp;val, buf, count); if(val == 1)&#123; *gpio_dat &amp;= ~(1&lt;&lt;pin); &#125;else&#123; *gpio_dat &amp;= (1&lt;&lt;pin); &#125; return 0;&#125;static struct file_operations led_fops = &#123; .owner = THIS_MODULE, .open = led_open, .write = led_write,&#125;;static int led_probe(struct platform_device *pdev)&#123; struct resource *res; // 最后一个参数 0 表示第1个该类型的资源 res = platform_get_resource(pdev, IORESOURCE_MEM, 0); gpio_con = ioremap(res-&gt;start, res-&gt;end - res-&gt;start + 1); gpio_dat = gpio_con + 1; res = platform_get_resource(pdev, IORESOURCE_IRQ, 0); pin = res-&gt;start; printk(&quot;led_probe, found led\\n&quot;); // 注册设备驱动 创建设备节点 major = register_chrdev(0, &quot;myled&quot;, &amp;led_fops); // 创建类 cls = class_create(THIS_MODULE, &quot;myled&quot;); // 创建设备节点 dev = device_create(cls, NULL, MKDEV(major, 0), NULL, &quot;led&quot;); return 0;&#125;static int led_remove(struct platform_device *pdev)&#123; printk(&quot;led_remove, remove led\\n&quot;); // 删除设备节点 device_unregister(dev); // 销毁类 class_destroy(cls); // 取消注册设备驱动 unregister_chrdev(major, &quot;myled&quot;); // 取消内存映射 iounmap(gpio_con); return 0;&#125;struct platform_driver led_drv = &#123; .probe = led_probe, //匹配到dev之后调用probe .remove = led_remove, .driver = &#123; .name = &quot;myled&quot;, &#125;,&#125;;static int led_drv_init(void)&#123; platform_driver_register(&amp;led_drv); return 0;&#125;static void led_drv_exit(void)&#123; platform_driver_unregister(&amp;led_drv);&#125;module_init(led_drv_init);module_exit(led_drv_exit);MODULE_LICENSE(&quot;GPL&quot;);","categories":[{"name":"Linux","slug":"Linux","permalink":"http://coderdock.com/categories/Linux/"},{"name":"基础知识","slug":"Linux/基础知识","permalink":"http://coderdock.com/categories/Linux/基础知识/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://coderdock.com/tags/Linux/"},{"name":"平台设备","slug":"平台设备","permalink":"http://coderdock.com/tags/平台设备/"}]},{"title":"ARM指令之必知必会","slug":"Basic/ARM指令之必知必会","date":"2016-12-27T07:53:33.000Z","updated":"2018-01-03T00:06:56.479Z","comments":true,"path":"2016/12/27/Basic/ARM指令之必知必会/","link":"","permalink":"http://coderdock.com/2016/12/27/Basic/ARM指令之必知必会/","excerpt":"&emsp;&emsp;作为一个嵌入式开发者，ARM汇编指令虽然用的不多。但也是一个必须要掌握的项目。","text":"&emsp;&emsp;作为一个嵌入式开发者，ARM汇编指令虽然用的不多。但也是一个必须要掌握的项目。 跳转指令b bl这两条指令都是跳转到相应的标号处，所不同的是bl还会将返回地址保存在lr返回寄存器中。 内存传送指令mov会是我们经常要用到的一条指令。有寄存器转移mov r1, r0和立即数转移两种方式mov r1, #1224 地址读取伪指令 ldr也有两种方式ldr r1, =1234 和取标号地址ldr r1, =label 内存访问指令 1234ldr r1, [r2, #3] //将r2+3地址处的内容读取到r1中ldr r1, [r2], #4 //将r2地址处的内容读取到r1，然后r2=r2+4str r1, [r2, #4] //将r1中的内容保存到 r2+4 地址处str r1, [r2], #4 //将r1中的数据保存到r2地址处，然后r2=r2+4 加减指令 12add r1, r2, #1 // r1 = r2 + 1sub r1, r2, #1 // r1 = r2 - 1 状态寄存器访问指令 12msr cpsr, r0 //cpsp = r0mrs r0, cpsr //r0 = cpsr","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://coderdock.com/categories/基础知识/"},{"name":"ARM指令","slug":"基础知识/ARM指令","permalink":"http://coderdock.com/categories/基础知识/ARM指令/"}],"tags":[{"name":"ARM指令","slug":"ARM指令","permalink":"http://coderdock.com/tags/ARM指令/"}]},{"title":"ARM要分清","slug":"Basic/ARM要分清","date":"2016-12-24T03:06:52.000Z","updated":"2017-12-24T09:45:05.380Z","comments":true,"path":"2016/12/24/Basic/ARM要分清/","link":"","permalink":"http://coderdock.com/2016/12/24/Basic/ARM要分清/","excerpt":"&emsp;&emsp;总是有人在说，我是搞ARM的，到底是说的ARM架构还是ARM系列，这点要搞清楚！","text":"&emsp;&emsp;总是有人在说，我是搞ARM的，到底是说的ARM架构还是ARM系列，这点要搞清楚！&emsp;&emsp;在Dock看来，ARM有两个概念，ARM架构、ARM系列,不同的架构，不同的系列在性能、功耗、尤其是价格方面有着很大的不同。 1. ARM公司&emsp;&emsp;ARM(Advanced RISC Machine)公司作为半导体行业最为著名的公司，你不能不知道。详情看度娘ARM。下面我们重点说架构和系列两个概念。 2. ARM架构&emsp;&emsp;ARM架构指的就是这颗芯片内核所用的指令集的版本。C++语言还有C++10、C++11版本之说，更何况内核呢？ &emsp;&emsp;最为显著的就是总线宽度。”Thumb指令集”为16位，”ARM指令集”为32位,以及”ISA指令集”为64位。这也就从根本上区分了每一个ARM内核有所不同。当然ARM还有很多很多不同的拓展功能，如Java加速器-Jazelle、TrustZone技术、SIMD等，这些不同的组合就组成了不同的ARM架构。 2.1 ARMv4 ARMv5 ARMv6 ARMv7&emsp;&emsp;这是市面上最老的ARM架构版本了。只支持32位地址空间，ARM7系列的一些芯片用到了这个指令集。 &emsp;&emsp;ARMv5相较于v4架构增加了DSP指令优化。 &emsp;&emsp;ARMv6 在存储系统、异常处理等方面做了很多改进，最为重要的是增加了对多媒体处理的支持。 &emsp;&emsp;ARMv7增加了NEON GPU多媒体处理支持，将DSP和媒体处理能力提高了近四倍，并且支持改良的浮点运算。满足下一代3D图形应用的需求，也就是从v7开始，ARMv7架构的处理器芯片开始应用于智能终端设备。 2.2 ARMv8&emsp;&emsp;2011年11月，ARM公司发布了新一代处理器架构ARMv8的部分技术细节。这是ARM公司的首款支持64位指令集的处理器架构。但其支持AArch32 AArch64两套指令集，为的就是向前兼容32位的应用。 2.3 拓展&emsp;&emsp;有时候我们又能看到ARMv5TEJ等词汇，这又是什么意思，后面的每一个字母代表一种拓展功能。如 T-Thumb指令集、E-增强型DSP指令 J-Java加速器。 3. ARM系列&emsp;&emsp;在相同的指令集下，搭配不同的部件就可以组成不同的功能的处理器。比如有无内存管理，有无调试功能等。 3.1 ARM7-11&emsp;&emsp;ARM7 - ARM11是比较老的一些处理器器了。其主要的分别大致如下： ARM7是低功耗的32位处理器，主要特点是没有MMU(内存管理)，如果有人给你说他用ARM7跑系统，你就可以呵呵了。 相较于ARM7,增加了MMU和Cache,指令集执行效率相比于ARM7有很大提高，最高可达300MIPS。 ARM11,基于ARMv6指令集架构，在实时性和浮点处理方面有很大提高。 3.2 ARM-Cortex&emsp;&emsp;在ARM11以后，ARM就不再以数字进行ARM处理器系列进行区分，而是使用Cortex进行命名。主要区分为一下三个系列： Cortex-A 和 Cortex-A50 系列 - 面向开放式操作系统的高性能处理器。 Cortex-R 系列- 面向实时应用的卓越性能。 Cortex-M 系列 - 面向具有确定性的微控制器应用的成本功耗敏感型解决方案。 &emsp;&emsp;ARM Cortex-A 内核基于ARMv7-A架构，基本上都可以支持ARM、Thumb-2、Thumb指令集、Java加速扩展的Jazelle技术、ThustZone的安全扩展、针对浮点FPU的VFP硬件扩展、DSP &amp; SIMD 扩展、并行多数据SIMD的NEON多媒体处理器扩展、主流的嵌入式OS（Linux、Android、Windows Mobile、Windows Phone、Symbian）、以及支持分支预测branch prediction。但各处理器在VFP/NEON的类型、半精度浮点（16-bit half precision floating-point）的支持、多核MPCore、流水线pipeline、单MHz处理性能、L1/L2 cache控制器、乱序执行、指令dual-issue并发等方面有略有不同。 &emsp;&emsp;Cortex-R系列的内核接触不多，主要用于实时控制领域。我所知道的在Xilinx的MPSOC芯片中就使用了两颗R-5内核作为对A-9内核的实时增强。 &emsp;&emsp;Cortex-M处理器家族更多的集中在低性能端，但是这些处理器相比于许多微控制器使用的传统处理器性能仍然很强大。例如，Cortex-M4和Cortex-M7处理器应用在许多高性能的微控制器产品中，最大的时钟频率可以达到400Mhz。如我们最熟悉的Stm32就是基于Cortex-M系列处理器。","categories":[{"name":"日常知识","slug":"日常知识","permalink":"http://coderdock.com/categories/日常知识/"},{"name":"ARM","slug":"日常知识/ARM","permalink":"http://coderdock.com/categories/日常知识/ARM/"}],"tags":[{"name":"ARM","slug":"ARM","permalink":"http://coderdock.com/tags/ARM/"},{"name":"ARM架构","slug":"ARM架构","permalink":"http://coderdock.com/tags/ARM架构/"},{"name":"ARM系列","slug":"ARM系列","permalink":"http://coderdock.com/tags/ARM系列/"}]},{"title":"交叉编译之必知必会","slug":"Basic/交叉编译之必知必会","date":"2016-10-25T04:25:39.000Z","updated":"2018-01-03T00:06:56.367Z","comments":true,"path":"2016/10/25/Basic/交叉编译之必知必会/","link":"","permalink":"http://coderdock.com/2016/10/25/Basic/交叉编译之必知必会/","excerpt":"&emsp;&emsp;做嵌入式开发，最熟悉的莫过于交叉编译了。在这篇文章中，记录自己经常使用到的相关知识，以共查阅。","text":"&emsp;&emsp;做嵌入式开发，最熟悉的莫过于交叉编译了。在这篇文章中，记录自己经常使用到的相关知识，以共查阅。 1. 编译器&emsp;&emsp;嵌入式开发和桌面应用的一个很大不同就是：我们必须自己准备配置所需的工具环境。并不像Windows开发那样装一个VS就一切OK了，这其中最重要的就是编译器的准备。 在Ubuntu上我一般是使用sudo apt-get install arm-linux-gnu命令进行交叉编译工具的安装。但大多数时候这是行不通的。因为arm架构或者特定ARM芯片的特性（如是否支持浮点运算），导致后期使用时故障频出。 使用开发板提供商或芯片提供商提供的开发套件，这些往往对某些特性做了优化，是最能契合我们的芯片开发的一种方式。 去Linaro下载对应架构的编译程序，这些开发环境适用性很好，在没能找到官方提供的套件的时候，这是一个很好的选择。 &emsp;&emsp;当然，下载安装完成后需要将可执行文件的路径加到系统的 PATH路径中 2.交叉编译器选项2.1 编译步骤&emsp;&emsp;编译程序分为4个步骤： 1.预处理，生成预编译文件（.文件）： Gcc –E hello.c –o hello.i 2.编译，生成汇编代码（.s文件）： Gcc –S hello.i –o hello.s 3.汇编，生成目标文件（.o文件）： Gcc –c hello.s –o hello.o 4.链接，生成可执行文件： Gcc hello.o –o hello 记住这三个选项只要记住键盘左上角的按键 ESC即可，是不是很简单 2.2 警告选项&emsp;&emsp;在默认情况下，警告选项是默认不打开的，后来Dock在开发的实践过程中，返现使用-Wall选项可以事先发现很多简单错误，为后期免去很多麻烦： 判断语句 if(a = b) 缺少 default分支 类型不匹配对比int a = 0; long b = 2; if(a == b) 其他Dock还未遇到的 &emsp;&emsp;就是这三个简单的错误，曾经让Dock花费很多时间去调试。错误应该消灭在萌芽。 2.3 包含链接选项&emsp;&emsp;Gcc编译器默认是会自动寻找包含编译环境中的头文件和链接库，但是在使用自己的头文件和链接库时，需要自己手动指定。 -I[path-to-include_file] 使用 -I 指定头文件的路径 -L[path-to-lib] 使用-L 指定库文件的路径 -lxx.so 使用-l 选项指定要链接的库文件，默认 l代替lib文件，如链接libmath.so要使用 -lmath -nostartfiles 不链接启动文件，即暂时不链接main函数 -nostdlib 不链接标准库文件，在裸机程序中比较常用，如uboot中就会使用到这个选项，因为链接标准库的话，程序就会变得很大。 -static 静态链接，这样就不会使用动态库，但后边有时需要制定 libxx.a静态库文件，同时文件体积会变得很大 2.4 objcpy objdump&emsp;&emsp;虽然说能够编译出程序并且能够运行就已经够了，但是这两个程序使我们做嵌入式程序所不能忽视的。 2.4.1 ELF格式 ELF(Executable and Linking Format)是unix-like系统下的一种文件格式，它是一种对象文件的格式，用于定义不同类型的对象文件(Object files)中都放了什么东西、以及都以什么样的格式去放这些东西。即是在程序的头部加上了一段信息： 1234567891011121314151617181920ELF Header: Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 Data: 2&apos;s complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: EXEC (Executable file) Machine: Advanced Micro Devices X86-64 Version: 0x1 Entry point address: 0x42dfe0 Start of program headers: 64 (bytes into file) Start of section headers: 67460488 (bytes into file) Flags: 0x0 Size of this header: 64 (bytes) Size of program headers: 56 (bytes) Number of program headers: 8 Size of section headers: 64 (bytes) Number of section headers: 40 Section header string table index: 37 对应的结构体为：12345678910111213141516typedef struct&#123; unsigned char e_ident[EI_NIDENT]; /* 魔数和相关信息 */ Elf32_Half e_type; /* 目标文件类型 */ Elf32_Half e_machine; /* 硬件体系 */ Elf32_Word e_version; /* 目标文件版本 */ Elf32_Addr e_entry; /* 程序进入点 */ Elf32_Off e_phoff; /* 程序头部偏移量 */ Elf32_Off e_shoff; /* 节头部偏移量 */ Elf32_Word e_flags; /* 处理器特定标志 */ Elf32_Half e_ehsize; /* ELF头部长度 */ Elf32_Half e_phentsize; /* 程序头部中一个条目的长度 */ Elf32_Half e_phnum; /* 程序头部条目个数 */ Elf32_Half e_shentsize; /* 节头部中一个条目的长度 */ Elf32_Half e_shnum; /* 节头部条目个数 */ Elf32_Half e_shstrndx; &emsp;&emsp;但是在uboot等环境中，是无法识别这些信息的。裸机程序总是从头一条一条指令的进行执行。所以在有些情况下我们需要去掉这些信息。那就用到了objcopy命令： objcopy用于将object的部分获全部内容拷贝到另一个object，从而可以实现格式的变换。 如 arm-linux-gnu-objcopy -O binary boot.elf boot.bin就常用来将elf转换为RAW格式，从而在裸机上运行。 2.4.2 objdump&emsp;&emsp;objdumpb即是常用的反汇编程序，Dock常用的两条命令为： arm--linux-objdump -d boot.elf将 elf反汇编 arm--linux-objdump -d -b binary -m arm boot.bin 将 bin反汇编","categories":[{"name":"日常知识","slug":"日常知识","permalink":"http://coderdock.com/categories/日常知识/"},{"name":"工具","slug":"日常知识/工具","permalink":"http://coderdock.com/categories/日常知识/工具/"}],"tags":[{"name":"交叉编译","slug":"交叉编译","permalink":"http://coderdock.com/tags/交叉编译/"},{"name":"arm-linux","slug":"arm-linux","permalink":"http://coderdock.com/tags/arm-linux/"}]},{"title":"Hello CoderDock","slug":"Hello-CoderDock","date":"2016-08-26T14:28:13.000Z","updated":"2018-01-03T00:06:56.502Z","comments":true,"path":"2016/08/26/Hello-CoderDock/","link":"","permalink":"http://coderdock.com/2016/08/26/Hello-CoderDock/","excerpt":"","text":"Hi, I am Coder Dock!欢迎来到我的博客，我会在这里一点点记录自己成为一个技术大牛的历程（期待吧）。","categories":[{"name":"日常记录","slug":"日常记录","permalink":"http://coderdock.com/categories/日常记录/"}],"tags":[{"name":"日常","slug":"日常","permalink":"http://coderdock.com/tags/日常/"}]}]}